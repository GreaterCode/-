{
	"ID": "20220811164625-sb3oe09",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20220811164625-sb3oe09",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20220811164625-ib0whfj\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230406103156-y3s5pbh\u0026quot;,\u0026quot;scrollTop\u0026quot;:4376,\u0026quot;focusId\u0026quot;:\u0026quot;20220811164625-ib0whfj\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "kubebuilder之controller-runtime源码分析 | Larioy",
		"updated": "20230419101030"
	},
	"Children": [
		{
			"ID": "20220811164625-ib0whfj",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20220811164625-ib0whfj"
			}
		},
		{
			"ID": "20220811164625-550d36s",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220811164625-550d36s",
				"updated": "20230419101030"
			},
			"Children": [
				{
					"ID": "20220811164625-mz0zia4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220811164625-mz0zia4",
						"updated": "20230419101030"
					},
					"Children": [
						{
							"ID": "20220811164625-497763j",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-497763j",
								"updated": "20230419101030"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://larioy.gst.monster/2021/06/27/kubernetes-kai-fa/controller-runtime-yuan-ma-fen-xi/#toc-heading-9",
									"TextMarkTextContent": "https://larioy.gst.monster/2021/06/27/kubernetes-kai-fa/controller-runtime-yuan-ma-fen-xi/#toc-heading-9"
								}
							]
						}
					]
				},
				{
					"ID": "20220811164625-8u1hjm0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220811164625-8u1hjm0"
					},
					"Children": [
						{
							"ID": "20220811164625-59l9m88",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-59l9m88"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "每一个没有朋友圈动态的日子都在踏实努力着"
								}
							]
						}
					]
				},
				{
					"ID": "20220811164625-ulw95yk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220811164625-ulw95yk"
					},
					"Children": [
						{
							"ID": "20220811164625-26dpbo7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-26dpbo7"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2022-08-11 16:46:25"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220811164625-u84aq8z",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20220811164625-u84aq8z"
			}
		},
		{
			"ID": "20220811164625-iuttnnd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-iuttnnd"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在正文开始前， 将看到的优秀的方便理解的文章放到参考文章中： "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://mp.weixin.qq.com/s/N585A2OaT5WKn-9S8q9NAQ",
					"TextMarkTextContent": "K8s源码分析(6)-Resource Content 序列化"
				},
				{
					"Type": "NodeText",
					"Data": "， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://qiankunli.github.io/2020/08/10/controller_runtime.html",
					"TextMarkTextContent": "controller-runtime源码分析"
				},
				{
					"Type": "NodeText",
					"Data": "， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://maao.cloud/2021/02/26/Kubernetes-Controller%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-controller-runtime/",
					"TextMarkTextContent": "Kubernetes Controller开发利器:controller-runtime"
				},
				{
					"Type": "NodeText",
					"Data": "， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://morven.life/posts/the_k8s_api-1/",
					"TextMarkTextContent": "初识 Kubernetes API 的组织结构"
				},
				{
					"Type": "NodeText",
					"Data": "， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://fankangbest.github.io/2017/07/27/Scheme%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB(%E4%B8%80)-Scheme-v1-5-2/",
					"TextMarkTextContent": "Scheme机制解读(一)-Scheme-v1.5.2"
				},
				{
					"Type": "NodeText",
					"Data": "， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://fankangbest.github.io/2017/07/29/Scheme%E6%9C%BA%E5%88%B6%E8%A7%A3%E8%AF%BB(%E4%BA%8C)-Converter-v1-5-2/",
					"TextMarkTextContent": "Scheme机制解读(二)-Converter-v1.5.2"
				},
				{
					"Type": "NodeText",
					"Data": "， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://fankangbest.github.io/2017/07/24/RESTMapper%E8%A7%A3%E8%AF%BB(%E4%B8%89)-%E5%85%B6%E4%BB%96RESTMapper-v1-5-2/",
					"TextMarkTextContent": "RESTMapper解读(三)-其他RESTMapper-v1.5.2"
				}
			]
		},
		{
			"ID": "20220811164625-houmjwx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-houmjwx"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从main.go入口进行分析， 主要做了如下事情"
				}
			]
		},
		{
			"ID": "20220811164625-kq6wtej",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20220811164625-kq6wtej"
			},
			"Children": [
				{
					"ID": "20220811164625-k8kqs79",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20220811164625-k8kqs79"
					},
					"Children": [
						{
							"ID": "20220811164625-c08exer",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-c08exer"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "生成controllerManager，将自定义资源添加到controller中"
								}
							]
						}
					]
				},
				{
					"ID": "20220811164625-vion95x",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20220811164625-vion95x"
					},
					"Children": [
						{
							"ID": "20220811164625-22bjwgz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-22bjwgz"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用生成的controllerManager的相关属性生成创建crd控制器并注册到mgr中"
								}
							]
						}
					]
				},
				{
					"ID": "20220811164625-y3pclgu",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20220811164625-y3pclgu"
					},
					"Children": [
						{
							"ID": "20220811164625-woeuyvo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-woeuyvo"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "添加自定义资源的webhook"
								}
							]
						}
					]
				},
				{
					"ID": "20220811164625-m1lfbc3",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20220811164625-m1lfbc3"
					},
					"Children": [
						{
							"ID": "20220811164625-2m5jkit",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-2m5jkit"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "拉起mgr"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220811164625-w19dvdz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-w19dvdz",
				"updated": "20220811164625"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "controller部分的逻辑： 先创建ControllerManager—\u003e创建Cache—-\u003e创建controller—-\u003e调用controller.Watch添加监控对象(controller.watchers数组中添加)—–\u003eControllerManager.Start启动—-\u003e启动controller.Start—–\u003e启动controller.watchers.xxx.Start"
				}
			]
		},
		{
			"ID": "20220811164625-65pcur6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-65pcur6"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/larioy.xyz/main.go\nfunc main() {\n    var metricsAddr string\n    var enableLeaderElection bool\n    flag.StringVar(\u0026metricsAddr, \"metrics-addr\", \":8080\", \"The address the metric endpoint binds to.\")\n    flag.BoolVar(\u0026enableLeaderElection, \"enable-leader-election\", false,\n        \"Enable leader election for controller manager. \"+\n            \"Enabling this will ensure there is only one active controller manager.\")\n    flag.Parse()\n\n    ctrl.SetLogger(zap.New(zap.UseDevMode(true)))\n\n    // 第一步先生成controllerManager\n    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n        Scheme:             scheme,\n        MetricsBindAddress: metricsAddr,\n        Port:               9443,\n        LeaderElection:     enableLeaderElection,\n        LeaderElectionID:   \"032e4682.larioy.xyz\",\n    })\n    if err != nil {\n        setupLog.Error(err, \"unable to start manager\")\n        os.Exit(1)\n    }\n\n    if err = (\u0026controllers.NodePoolReconciler{\n        Client:   mgr.GetClient(),\n        Log:      ctrl.Log.WithName(\"controllers\").WithName(\"NodePool\"),\n        Scheme:   mgr.GetScheme(),\n        Recorder: mgr.GetEventRecorderFor(\"NodePool\"),\n    }).SetupWithManager(mgr); err != nil {\n        setupLog.Error(err, \"unable to create controller\", \"controller\", \"NodePool\")\n        os.Exit(1)\n    }\n    // 添加webhook\n    if err = (\u0026larioyv1.NodePool{}).SetupWebhookWithManager(mgr); err != nil {\n        setupLog.Error(err, \"unable to create webhook\", \"webhook\", \"NodePool\")\n        os.Exit(1)\n    }\n    // +kubebuilder:scaffold:builder\n    setupLog.Info(\"starting manager\")\n    // 拉起manager, # todo 在创建controller的时候不是已经将manager拉起来了吗？\n    if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {\n        setupLog.Error(err, \"problem running manager\")\n        os.Exit(1)\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-1mjau6s",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220811164625-1mjau6s"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建controllerManager"
				}
			]
		},
		{
			"ID": "20220811164625-45qeywj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-45qeywj"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "填充option， 设置默认的值"
				}
			]
		},
		{
			"ID": "20220811164625-43s0gyo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-43s0gyo"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建MapperProvider： RESTMapper作为GVK到GVR的映射， GVK可以从资源对象json或yaml文件中提取， 通过GVK可以得到GVR， 通过GVR可以拼接出资源的http api请求路径如： GET /apis/apps/v1/namespaces/{namespace}/deployments/{name}。主要作用是在listWatch时， 根据Schema定义的类型GVK解析出GVR， 向apiserver发起http请求获取资源， 然后watch。 watch基于http的Chunk实现，维护长连接。 mapper主要是在ListAndWatch中使用到"
				}
			]
		},
		{
			"ID": "20220811164625-7jtpu7w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-7jtpu7w"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建cache： 使用默认的cache.New创建, cache中可以储存原生api对象也可以存储crd对象"
				}
			]
		},
		{
			"ID": "20220811164625-9ouvc6l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-9ouvc6l"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建apiReader： 只读的， 不与本地cache交互， 直接与apiserver进行交互"
				}
			]
		},
		{
			"ID": "20220811164625-bmiufug",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-bmiufug"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建writeClient： 与本地cache交互， 存放缓存"
				}
			]
		},
		{
			"ID": "20220811164625-5hj5wer",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-5hj5wer"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "选举、事件记录(方便通过kubectl查看资源对象得到)、监控指标、健康检查"
				}
			]
		},
		{
			"ID": "20220811164625-8g13jw9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-8g13jw9",
				"updated": "20220811164625"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "完成controllerManager实例化所在的文件为src/sigs.k8s.io/controller-runtime/pkg/manager/internal.go"
				}
			]
		},
		{
			"ID": "20220811164625-par1267",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-par1267"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\n// 创建controllerManager用于创建Controllers.\nfunc New(config *rest.Config, options Options) (Manager, error) {\n    if config == nil {\n        return nil, fmt.Errorf(\"must specify Config\")\n    }\n\n    // 设置了很多的默认值包括NewCache,NewClient等\n    options = setOptionsDefaults(options)\n\n    // mapperProvider是什么东西？\n    mapper, err := options.MapperProvider(config)\n    if err != nil {\n        log.Error(err, \"Failed to get API Group-Resources\")\n        return nil, err\n    }\n\n    // 实例化一个funcCache, 还没创建对象\n    cache, err := options.NewCache(config, cache.Options{Scheme: options.Scheme, Mapper: mapper, Resync: options.SyncPeriod, Namespace: options.Namespace})\n    if err != nil {\n        return nil, err\n    }\n\n    // 创建reader客户端\n    apiReader, err := client.New(config, client.Options{Scheme: options.Scheme, Mapper: mapper})\n    if err != nil {\n        return nil, err\n    }\n\n    // 创建write客户端\n    writeObj, err := options.NewClient(cache, config, client.Options{Scheme: options.Scheme, Mapper: mapper})\n    if err != nil {\n        return nil, err\n    }\n  \n    // 事件记录, 便于kubectl进行查看\n    recorderProvider, err := options.newRecorderProvider(config, options.Scheme, log.WithName(\"events\"), options.EventBroadcaster)\n    if err != nil {\n        return nil, err\n    }\n\n    // Create the resource lock to enable leader election)\n    resourceLock, err := options.newResourceLock(config, recorderProvider, leaderelection.Options{\n        LeaderElection:          options.LeaderElection,\n        LeaderElectionID:        options.LeaderElectionID,\n        LeaderElectionNamespace: options.LeaderElectionNamespace,\n    })\n    if err != nil {\n        return nil, err\n    }\n\n    metricsListener, err := options.newMetricsListener(options.MetricsBindAddress)\n    if err != nil {\n        return nil, err\n    }\n\n    // Create health probes listener. This will throw an error if the bind\n    // address is invalid or already in use.\n    healthProbeListener, err := options.newHealthProbeListener(options.HealthProbeBindAddress)\n    if err != nil {\n        return nil, err\n    }\n\n    stop := make(chan struct{})\n\n    return \u0026controllerManager{\n        config:                config,\n        scheme:                options.Scheme,\n        cache:                 cache,\n        fieldIndexes:          cache,\n        client:                writeObj,\n        apiReader:             apiReader,\n        recorderProvider:      recorderProvider,\n        resourceLock:          resourceLock,\n        mapper:                mapper,\n        metricsListener:       metricsListener,\n        internalStop:          stop,\n        internalStopper:       stop,\n        port:                  options.Port,\n        host:                  options.Host,\n        certDir:               options.CertDir,\n        leaseDuration:         *options.LeaseDuration,\n        renewDeadline:         *options.RenewDeadline,\n        retryPeriod:           *options.RetryPeriod,\n        healthProbeListener:   healthProbeListener,\n        readinessEndpointName: options.ReadinessEndpointName,\n        livenessEndpointName:  options.LivenessEndpointName,\n    }, nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-5ibsepy",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-5ibsepy"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建Cache"
				}
			]
		},
		{
			"ID": "20220811164625-l5z3pc8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-l5z3pc8"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "controller-runtime对cache做了一层抽象，所有的资源的informer都放在InformersMap结构体中， 资源又包括结构化的和非结构化的都放在specificInformersMap结构体中。在开发的过程中一般很少和Cache打交道。"
				}
			]
		},
		{
			"ID": "20220811164625-8n1g6zq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-8n1g6zq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "specificInformersMap的informersByGVK就是用client-go创建的具体的某个资源的多个版本informers容器.  即最底层用的还是client-go那一套。 对缓存(client-go的indexer)的操作也全放在specificInformersMap.informersByGVK.gvk.Reader中"
				}
			]
		},
		{
			"ID": "20220811164625-m6bysmz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-m6bysmz"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "cache包内各接口和结构体之间的关系"
				}
			]
		},
		{
			"ID": "20220811164625-52zof7f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-52zof7f"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "src/sigs.k8s.io/controller-runtime/pkg/cache/informer_cache.go 的 informerCache结构体实现了Cache接口, 作为cache包的上层管理接口对外提供服务"
				}
			]
		},
		{
			"ID": "20220811164625-jy29imm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-jy29imm"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "src/sigs.k8s.io/controller-runtime/pkg/cache/internal/deleg_map.go 的 InformersMap结构体实现了Informers接口，包含结构化和非结构化资源的informer。"
				}
			]
		},
		{
			"ID": "20220811164625-dy7mt1i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-dy7mt1i"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "src/sigs.k8s.io/controller-runtime/pkg/cache/internal/informers_map.go 的specificInformersMap结构体变量informersByGVK为GVK到informer的映射。"
				}
			]
		},
		{
			"ID": "20220811164625-ead8blt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-ead8blt"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "specificInformersMap.Get函数会调用specificInformersMap.addInformerToMap创建informer， 其他包可以通过cache.GetInformer获取或创建informer。"
				}
			]
		},
		{
			"ID": "20220811164625-6u2pbv6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-6u2pbv6"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用client-go创建的NewSharedIndexInformer放到MapEntry中， MapEntry提供对informer indexer缓存操作的功能， 集成在src/sigs.k8s.io/controller-runtime/pkg/cache/internal/cache_reader.go的CacheReader中"
				}
			]
		},
		{
			"ID": "20220811164625-suysif7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-suysif7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-ap14qb4",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-ap14qb4"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// cache接口和相关结构体\ntype Cache interface {\n    // 作为cache的客户端, 从cache中读取数据\n    client.Reader\n    // Cache loads informers and adds field indices.\n    Informers\n}\n\ntype Informers interface {\n    GetInformer(obj runtime.Object) (Informer, error)\n    GetInformerForKind(gvk schema.GroupVersionKind) (Informer, error)\n    Start(stopCh \u003c-chan struct{}) error\n    WaitForCacheSync(stop \u003c-chan struct{}) bool\n    client.FieldIndexer\n}\n\n// 用于沟通底层的informer\ntype Informer interface {\n    AddEventHandler(handler toolscache.ResourceEventHandler)\n    AddEventHandlerWithResyncPeriod(handler toolscache.ResourceEventHandler, resyncPeriod time.Duration)\n    // todo 原生的client-go的informer的indexer支持自定义吗? 好像是默认的\n    AddIndexers(indexers toolscache.Indexers) error\n    HasSynced() bool\n}\n\n\n/*\n    src/sigs.k8s.io/controller-runtime/pkg/cache/informer_cache.go 的 informerCache结构体实现了Cache接口, 作为上层的管理接口使用\n    src/sigs.k8s.io/controller-runtime/pkg/cache/internal/deleg_map.go 的 InformersMap结构体实现了Informers接口, 作为底层的干活接口使用\n*/\n// informerCache基于InformersMap, 额外再增加写结构体方法\ntype informerCache struct {\n    *internal.InformersMap\n}\n\ntype InformersMap struct {\n    structured   *specificInformersMap\n    unstructured *specificInformersMap\n    Scheme *runtime.Scheme\n    }\n  \n// specificInformersMap的informersByGVK为MapEntry, 其为client-go创建的informer的载体\ntype MapEntry struct {\n    Informer cache.SharedIndexInformer\n    Reader CacheReader\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-1pkyclo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-1pkyclo",
				"updated": "20220811164625"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以下是cache的具体创建过程， 注意： 在创建cache的过程并没有创建对应资源的informer， informer的创建在最后面的Kind.Start。"
				}
			]
		},
		{
			"ID": "20220811164625-mj46vu7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-mj46vu7"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/manager/manager.go  \noptions.NewCache = cache.New\ncache, err := options.NewCache(config, cache.Options{Scheme: options.Scheme, Mapper: mapper, Resync: options.SyncPeriod, Namespace: options.Namespace})\n\n// src/sigs.k8s.io/controller-runtime/pkg/cache/cache.go\nfunc New(config *rest.Config, opts Options) (Cache, error) {\n    opts, err := defaultOpts(config, opts)\n    if err != nil {\n        return nil, err\n    }\n    im := internal.NewInformersMap(config, opts.Scheme, opts.Mapper, *opts.Resync, opts.Namespace)\n    return \u0026informerCache{InformersMap: im}, nil\n}\n\n\n// src/sigs.k8s.io/controller-runtime/pkg/cache/internal/deleg_map.go\nfunc NewInformersMap(config *rest.Config,\n    scheme *runtime.Scheme,\n    mapper meta.RESTMapper,\n    resync time.Duration,\n    namespace string) *InformersMap {\n\n    return \u0026InformersMap{\n        structured:   newStructuredInformersMap(config, scheme, mapper, resync, namespace),\n        unstructured: newUnstructuredInformersMap(config, scheme, mapper, resync, namespace),\n\n        Scheme: scheme,\n    }\n}\n\nfunc newStructuredInformersMap(config *rest.Config, scheme *runtime.Scheme, mapper meta.RESTMapper, resync time.Duration, namespace string) *specificInformersMap {\n    return newSpecificInformersMap(config, scheme, mapper, resync, namespace, createStructuredListWatch)\n}\n\n// src/sigs.k8s.io/controller-runtime/pkg/cache/internal/informers_map.go\n/*\n    所有监控的资源都放到specificInformersMap中\n    且在specificInformersMap中没有看到client-go中的informer, 在specificInformersMap.informersByGVK.xxxx.Informer\n*/\nfunc newSpecificInformersMap(config *rest.Config,\n    scheme *runtime.Scheme,\n    mapper meta.RESTMapper,\n    resync time.Duration,\n    namespace string,\n    createListWatcher createListWatcherFunc) *specificInformersMap {\n    ip := \u0026specificInformersMap{\n        config:            config,\n        Scheme:            scheme,\n        mapper:            mapper,                                         // GVK与GVR的映射\n        informersByGVK:    make(map[schema.GroupVersionKind]*MapEntry),    // 每种资源GVK与其Informer的映射\n        codecs:            serializer.NewCodecFactory(scheme),             // 编解码, 结构化和非结构化都用相同的解码器？\n        paramCodec:        runtime.NewParameterCodec(scheme),              // 未理解\n        resync:            resync,\n        startWait:         make(chan struct{}),\n        createListWatcher: createListWatcher,                              //\n        namespace:         namespace,\n    }\n    return ip\n}\n\n\n// 从specificInformersMap中获取指定资源版本的Informer, 如果不存在则新建\nfunc (ip *specificInformersMap) Get(gvk schema.GroupVersionKind, obj runtime.Object) (bool, *MapEntry, error) {\n    i, started, ok := func() (*MapEntry, bool, bool) {\n        ip.mu.RLock()\n        defer ip.mu.RUnlock()\n        i, ok := ip.informersByGVK[gvk]\n        return i, ip.started, ok\n    }()\n\n    // 如果这个版本资源没有在map中, 则将其添加到map中\n    if !ok {\n        var err error\n        if i, started, err = ip.addInformerToMap(gvk, obj); err != nil {\n            return started, nil, err\n        }\n    }\n\n    //  如果该版本的资源informer启动并且已经同步完, 这返回状态和nil\n    if started \u0026\u0026 !i.Informer.HasSynced() {\n        // Wait for it to sync before returning the Informer so that folks don't read from a stale cache.\n        if !cache.WaitForCacheSync(ip.stop, i.Informer.HasSynced) {\n            return started, nil, fmt.Errorf(\"failed waiting for %T Informer to sync\", obj)\n        }\n    }\n\n    return started, i, nil\n}\n\n/*\n    调用client-go创建具体的某一版本资源的informer, 保存在MapEntry中。 MapEntry包含informer与缓存Indexer\n    然后将MapEntry保存在specificInformersMap.informersByGVK中\n*/\nfunc (ip *specificInformersMap) addInformerToMap(gvk schema.GroupVersionKind, obj runtime.Object) (*MapEntry, bool, error) {\n    ip.mu.Lock()\n    defer ip.mu.Unlock()\n\n    // 如果已经创建了对应资源版本的informer则返回\n    if i, ok := ip.informersByGVK[gvk]; ok {\n        return i, ip.started, nil\n    }\n\n    // 没有则informer则新建informer并添加到map中\n    var lw *cache.ListWatch\n    // 创建对应版本资源的ListAndWatch函数, 针对结构化和非结构化的数据创建, 抽象成一个接口\n    lw, err := ip.createListWatcher(gvk, ip)\n    if err != nil {\n        return nil, false, err\n    }\n    // 看这里最终也是落到了client-go的sharedIndexInformer\n    ni := cache.NewSharedIndexInformer(lw, obj, resyncPeriod(ip.resync)(), cache.Indexers{\n        cache.NamespaceIndex: cache.MetaNamespaceIndexFunc,\n    })\n    i := \u0026MapEntry{\n        Informer: ni,\n        // Reader最终也是client-go的indexer\n        Reader:   CacheReader{indexer: ni.GetIndexer(), groupVersionKind: gvk},\n    }\n    ip.informersByGVK[gvk] = i\n\n\n    // TODO(seans): write thorough tests and document what happens here - can you add indexers?\n    // can you add eventhandlers?\n    // 如果总开关开启了, 则将informer也启动。 因为我们在初始化和启动cache的时候并没有添加对应资源的informer.\n    // 所以在动态添加资源的informer时, cache启动了就可以将informer也启动了\n    if ip.started {\n        go i.Informer.Run(ip.stop)\n    }\n    return i, ip.started, nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-kgaxt4c",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220811164625-kgaxt4c"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Controller与监控资源初始化"
				}
			]
		},
		{
			"ID": "20220811164625-zf8bl41",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-zf8bl41"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Controller的创建都由Builder完成， 通过链式调用完成controller的创建，crd reconcil与controller的关联并将controller注册到controllerManager。主要文件在： src/sigs.k8s.io/controller-runtime/pkg/builder/controller.go"
				}
			]
		},
		{
			"ID": "20220811164625-akx0pcr",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-akx0pcr"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Controller相关接口与结构体"
				}
			]
		},
		{
			"ID": "20220811164625-fku3kdi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-fku3kdi"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "kubebuilder中的controller和client-go的controller不是同一个东西， kubebuilder对controller进行了一次封装。接口和实例分别如下"
				}
			]
		},
		{
			"ID": "20220811164625-67k27yq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-67k27yq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-3hfslnz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-3hfslnz"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/controller/controller.go\n/*\n    Controller实现了一个k8s api. controller管理一个work queue来处理reconcile对source.Sources的请求\n    Work从reconcile.Reconciler中获取每一个enqueued item执行处理逻辑\n*/\ntype Controller interface {\n    // Reconciler is called to reconcile an object by Namespace/Name\n    reconcile.Reconciler\n    // Watch可能在event进入EventHandler前会提供一个或多个filter预处理器， 当所有预处理器处理正确后event将被送进EventHandler处理\n    Watch(src source.Source, eventhandler handler.EventHandler, predicates ...predicate.Predicate) error\n    Start(stop \u003c-chan struct{}) error\n}\n\n\n//  src/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go\ntype Controller struct {\n    // Name唯一的凭证用于跟踪、日志和监控\n    Name string\n\n    // 最大的并发Reconciles数量, 默认是1\n    MaxConcurrentReconciles int\n\n    // 用户自己实现的reconcile, 实际状态到用户期望状态的处理逻辑都在这里完成\n    Do reconcile.Reconciler\n\n    // Client is a lazily initialized Client.  The controllerManager will initialize this when Start is called.\n    Client client.Client\n\n    // Scheme在controllerManager.Start被调用时注入\n    Scheme *runtime.Scheme\n\n    // informers在controllerManager启动的时候被注入\n    Cache cache.Cache\n\n    // 与apiserver沟通的config配置.  默认值从in-cluster, 指定环境变量, 或 ~/.kube/Config中提取\n    Config *rest.Config\n\n    // 当controller准备启动时, MakeQueue 为该Controller构建queue\n    // MakeQueue存在的原因: 标准的k8s workqueues会立即启动, 在controller.New重新启动的时候会导致goroutine泄漏\n    MakeQueue func() workqueue.RateLimitingInterface\n\n    // Queue is an listeningQueue that listens for events from Informers and adds object keys to\n    // the Queue for processing\n    Queue workqueue.RateLimitingInterface\n\n    // SetFields被用于注入依赖如: Sources, EventHandlers and Predicates\n    // 最终是在controllerManager.SetFields的递归, 起作用的就是它\n    SetFields func(i interface{}) error\n\n    // mu is used to synchronize Controller setup\n    mu sync.Mutex\n\n    // JitterPeriod allows tests to reduce the JitterPeriod so they complete faster\n    JitterPeriod time.Duration\n\n    // 表示Cache.WaitForCacheSync\n    WaitForCacheSync func(stopCh \u003c-chan struct{}) bool\n\n    Started bool\n\n    // Recorder is an event recorder for recording Event resources to the\n    // Kubernetes API.\n    Recorder record.EventRecorder\n\n    // TODO(community): Consider initializing a logger with the Controller Name as the tag\n\n    // watches maintains a list of sources, handlers, and predicates to start when the controller is started.\n    // 可以用来监控多个资源对象    todo  什么时候才需要监控多个资源， \n    watches []watchDescription\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-kdwmgg4",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-kdwmgg4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Builder整体视角创建Controller"
				}
			]
		},
		{
			"ID": "20220811164625-nctjeo6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-nctjeo6",
				"updated": "20220811164625"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Controller的创建过程如下， 先将创建crd的reconcile， 再创建controller并将其与reconcile关联， 再将controller注册到mgr中。 主要由Builder完成"
				}
			]
		},
		{
			"ID": "20220811164625-j077gnh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-j077gnh"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/builder/controller.go\nif err = (\u0026controllers.NodePoolReconciler{\n        Client:   mgr.GetClient(),\n        Log:      ctrl.Log.WithName(\"controllers\").WithName(\"NodePool\"),\n        Scheme:   mgr.GetScheme(),\n        Recorder: mgr.GetEventRecorderFor(\"NodePool\"),\n    }).SetupWithManager(mgr); err != nil {\n        setupLog.Error(err, \"unable to create controller\", \"controller\", \"NodePool\")\n        os.Exit(1)\n    }\n  \n\n// src/larioy.xyz/controllers/nodepool_controller.go\n// 这个是主要的链式调用, 最终将自己的reconciler注册到controller中, 并把controller拉起来\nfunc (r *NodePoolReconciler) SetupWithManager(mgr ctrl.Manager) error {\n    // 可以在这里添加额外的资源监控, 使用Own()函数链式调用添加\n    return ctrl.NewControllerManagedBy(mgr).\n        For(\u0026nodesv1.NodePool{}).\n        Complete(r)\n}\n\n// src/sigs.k8s.io/controller-runtime/pkg/builder/controller.go\nfunc (blder *Builder) Complete(r reconcile.Reconciler) error {\n    _, err := blder.Build(r)\n    return err\n}\n\n// Builder中最主要的函数, 实现controller和监控资源的初始化\nfunc (blder *Builder) Build(r reconcile.Reconciler) (controller.Controller, error) {\n    if r == nil {\n        return nil, fmt.Errorf(\"must provide a non-nil Reconciler\")\n    }\n    if blder.mgr == nil {\n        return nil, fmt.Errorf(\"must provide a non-nil Manager\")\n    }\n    // Set the Config\n    blder.loadRestConfig()\n    // 将crd的Reconciler传递进去给controllerManager管理\n    if err := blder.doController(r); err != nil {\n        return nil, err\n    }\n    if err := blder.doWatch(); err != nil {\n        return nil, err\n    }\n\n    return blder.ctrl, nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-k841au0",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20220811164625-k841au0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "doController完成Controller初始化"
				}
			]
		},
		{
			"ID": "20220811164625-oq48587",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-oq48587"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在doController中完成controller的创建并注册到mgr"
				}
			]
		},
		{
			"ID": "20220811164625-gk8i09h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-gk8i09h"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-vsla668",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-vsla668"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\n// 将crd的Reconciler传递进去给controllerManager管理\nfunc (blder *Builder) doController(r reconcile.Reconciler) error {\n    name, err := blder.getControllerName()\n    if err != nil {\n        return err\n    }\n    ctrlOptions := blder.ctrlOptions\n    ctrlOptions.Reconciler = r\n    // 进入到这里开始执行创建controller\n    blder.ctrl, err = newController(name, blder.mgr, ctrlOptions)\n    return err\n}\n\nvar newController = controller.New\n\n\n\n// src/sigs.k8s.io/controller-runtime/pkg/controller/controller.go\n/*\n    完成controller的创建并将其注册到controllerManager中\n*/\nfunc New(name string, mgr manager.Manager, options Options) (Controller, error) {\n    if options.Reconciler == nil {\n        return nil, fmt.Errorf(\"must specify Reconciler\")\n    }\n\n    if len(name) == 0 {\n        return nil, fmt.Errorf(\"must specify Name for Controller\")\n    }\n\n    if options.MaxConcurrentReconciles \u003c= 0 {\n        options.MaxConcurrentReconciles = 1\n    }\n\n    // todo \n    if err := mgr.SetFields(options.Reconciler); err != nil {\n        return nil, err\n    }\n\n    // 完成最原始的controller的创建, 向crd开发一样\n    c := \u0026controller.Controller{\n        // 用户自己实现的reconciler\n        Do:       options.Reconciler,\n        Cache:    mgr.GetCache(),\n        Config:   mgr.GetConfig(),\n        Scheme:   mgr.GetScheme(),\n        Client:   mgr.GetClient(),\n        Recorder: mgr.GetEventRecorderFor(name),\n        // 使用MakeQueue的原因见结构体分析\n        MakeQueue: func() workqueue.RateLimitingInterface {\n            return workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), name)\n        },\n        MaxConcurrentReconciles: options.MaxConcurrentReconciles,\n        Name:                    name,\n    }\n    // 将controller添加到controller中进行管理\n    return c, mgr.Add(c)\n}\n\n// 可以传入不同的runnable实例, 只要实现Runable接口就行\nfunc (cm *controllerManager) Add(r Runnable) error {\n    cm.mu.Lock()\n    defer cm.mu.Unlock()\n\n    // 见依赖注入\n    if err := cm.SetFields(r); err != nil {\n        return err\n    }\n\n    var shouldStart bool\n\n    // Add the runnable to the leader election or the non-leaderelection list\n    if leRunnable, ok := r.(LeaderElectionRunnable); ok \u0026\u0026 !leRunnable.NeedLeaderElection() {\n        shouldStart = cm.started\n        cm.nonLeaderElectionRunnables = append(cm.nonLeaderElectionRunnables, r)\n    } else {\n        shouldStart = cm.startedLeader\n        cm.leaderElectionRunnables = append(cm.leaderElectionRunnables, r)\n    }\n\n    // 如果controllerManager已经启动了, 则将启动controller\n    if shouldStart {\n        go func() {\n            // 启动controller， r就是controller\n            if err := r.Start(cm.internalStop); err != nil {\n                cm.errSignal.SignalError(err)\n            }\n        }()\n    }\n\n    return nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-506yjda",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-506yjda"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如上已经完成controller的创建与注册"
				}
			]
		},
		{
			"ID": "20220811164625-iwv9u3i",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20220811164625-iwv9u3i"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向controller中添加监控资源"
				}
			]
		},
		{
			"ID": "20220811164625-3osbq8q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-3osbq8q"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向controller中添加监控资源是在Builder.doWarch中实现的，doWatch会可以watch多种资源类型， 比如监控pod并调用Builder.Owner监控deployment。"
				}
			]
		},
		{
			"ID": "20220811164625-hkmnr5f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-hkmnr5f"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "被watch的对象在kubebuiler被抽象为Source接口， 实现Source接口的有Kind， Channel， Informer， 实际生效的是Kind。"
				}
			]
		},
		{
			"ID": "20220811164625-gjyh135",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-gjyh135"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-xd22vbv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-xd22vbv"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/builder/controller.go\nfunc (blder *Builder) doWatch() error {\n    src := \u0026source.Kind{Type: blder.apiType}\n    hdler := \u0026handler.EnqueueRequestForObject{}\n  \n    // 调用controller的Watch函数, 将主要的监控对象启动\n    err := blder.ctrl.Watch(src, hdler, blder.predicates...)\n    if err != nil {\n        return err\n    }\n\n    for _, obj := range blder.managedObjects {\n        src := \u0026source.Kind{Type: obj}\n        hdler := \u0026handler.EnqueueRequestForOwner{\n            OwnerType:    blder.apiType,\n            IsController: true,\n        }\n        if err := blder.ctrl.Watch(src, hdler, blder.predicates...); err != nil {\n            return err\n        }\n    }\n\n    // 需要被管理的资源\n    for _, w := range blder.watchRequest {\n        if err := blder.ctrl.Watch(w.src, w.eventhandler, blder.predicates...); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-bxl8r6v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-bxl8r6v"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "doWatch中关键的函数是controller.Watch函数， 其根据eventhandler、监控资源source生成watchDescription结构并添加到controller的watches数组中， 实现监控资源与Controller的绑定，等待controllerManager的启动"
				}
			]
		},
		{
			"ID": "20220811164625-tcwrby7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-tcwrby7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-m6xo24r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-m6xo24r"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go\n// todo 一般传入进来的src, evthdler和prct是从哪里来的呢?\nfunc (c *Controller) Watch(src source.Source, evthdler handler.EventHandler, prct ...predicate.Predicate) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    // 将Cache注入src中\n    if err := c.SetFields(src); err != nil {\n        return err\n    }\n    if err := c.SetFields(evthdler); err != nil {\n        return err\n    }\n    for _, pr := range prct {\n        if err := c.SetFields(pr); err != nil {\n            return err\n        }\n    }\n\n    c.watches = append(c.watches, watchDescription{src: src, handler: evthdler, predicates: prct})\n    if c.Started {\n        log.Info(\"Starting EventSource\", \"controller\", c.Name, \"source\", src)\n        // 启动src, 进入真正的资源监控行列\n        return src.Start(evthdler, c.Queue, prct...)\n    }\n\n    return nil\n}\n\n\ntype watchDescription struct {\n    src        source.Source               // 被监控的资源\n    handler    handler.EventHandler        // 监控资源对象入队前需要被EventHandler处理\n    predicates []predicate.Predicate       // event过滤器, 可以在暴露的接口中添加\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-ossjqy9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-ossjqy9"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "doWatch函数的hdler变量为EventHandler用于监控资源添加到Controller.Queue前的处理， 分析见下文"
				}
			]
		},
		{
			"ID": "20220811164625-vp7sq0a",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20220811164625-vp7sq0a"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "EventHandler分析"
				}
			]
		},
		{
			"ID": "20220811164625-ookl4au",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-ookl4au"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "handler相关的文件在： src/sigs.k8s.io/controller-runtime/pkg/source/internal/eventsource.go和src/sigs.k8s.io/controller-runtime/pkg/source/internal/eventsource.go。src/sigs.k8s.io/controller-runtime/pkg/handler/eventhandler.go中定义了EventHandler接口，实现EventHandler接口的结构体是EnqueueRequestForObject和EnqueueRequestForOwner。"
				}
			]
		},
		{
			"ID": "20220811164625-38hfxnc",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220811164625-38hfxnc"
			},
			"Children": [
				{
					"ID": "20220811164625-4hpqi62",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220811164625-4hpqi62"
					},
					"Children": [
						{
							"ID": "20220811164625-08u6kpl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-08u6kpl"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "EnqueueRequestForObject用于处理元素按照namespace+name的方式"
								}
							]
						}
					]
				},
				{
					"ID": "20220811164625-kugfj9v",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220811164625-kugfj9v"
					},
					"Children": [
						{
							"ID": "20220811164625-pn05w0x",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-pn05w0x"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "EnqueueRequestForOwner用于将object的owner添加到queue， 比如当object是Deployment Pod则其Owner是Deployment。实现是初始化EnqueueRequestForOwner为Deployment类型， 将object添加到队列前， 解析object的owner和EnqueueRequestForOwner相关字段匹配则构造新的reconcile.Requests添加到队列中。 添加到队列中的元素为reconcile.Requests结构体, 在EnqueueRequestForOwner与EnqueueRequestForObject相关方法中构造"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220811164625-gx240xw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-gx240xw"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "handler相关结构体分析："
				}
			]
		},
		{
			"ID": "20220811164625-s8douhq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-s8douhq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-wxdc7ot",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-wxdc7ot"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "type EventHandler interface {\n    Create(event.CreateEvent, workqueue.RateLimitingInterface)\n    Update(event.UpdateEvent, workqueue.RateLimitingInterface)\n    Delete(event.DeleteEvent, workqueue.RateLimitingInterface)\n    Generic(event.GenericEvent, workqueue.RateLimitingInterface)\n}\n\ntype EnqueueRequestForOwner struct {\n    // owner的类型\n    OwnerType runtime.Object\n    // 是true则只返回第一个owner\n    IsController bool\n    // groupKind is the cached Group and Kind from OwnerType\n    groupKind schema.GroupKind\n    // mapper maps GroupVersionKinds to Resources\n    mapper meta.RESTMapper\n}\n\ntype EnqueueRequestForObject struct{}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-mx7acdr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-mx7acdr"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "reconcile.Request结构体是什么对象， 是拿来干什么的??"
				}
			]
		},
		{
			"ID": "20220811164625-o9z3hj7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-o9z3hj7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "明确入队的元素是： object.name+object.namespace, 不是元素的实例， 最终从缓存中拿的才是实例元素， 队列里的元素可以理解是资源定位。"
				}
			]
		},
		{
			"ID": "20220811164625-1zv0qrc",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220811164625-1zv0qrc"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "SetFields依赖注入"
				}
			]
		},
		{
			"ID": "20220811164625-1e950a5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-1e950a5"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如上中看到较多的SetFields函数调用， 探探其是干嘛的。"
				}
			]
		},
		{
			"ID": "20220811164625-8cuq25z",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-8cuq25z"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "依赖注入框架"
				}
			]
		},
		{
			"ID": "20220811164625-4ssm2m1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-4ssm2m1"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "kubebuilder通过controllerManager结构体初始化大部分变量， 这些变量会在其他结构体初始化的使用引用， controllerManager结构体中的这些变量就变成他们的依赖了。这种依赖还存在递归注入的可能。 先查看有哪些变量可以执行依赖注入， 相关文件在： src/sigs.k8s.io/controller-runtime/pkg/runtime/inject/inject.go"
				}
			]
		},
		{
			"ID": "20220811164625-d0njvwv",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20220811164625-d0njvwv"
			},
			"Children": [
				{
					"ID": "20220811164625-qmnjtw7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220811164625-qmnjtw7"
					},
					"Children": [
						{
							"ID": "20220811164625-euqsw8l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-euqsw8l"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "结构类： Cache、APIReader、Config、Client、Scheme、Stoppable、Mapper、Logger"
								}
							]
						}
					]
				},
				{
					"ID": "20220811164625-59h1pmo",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20220811164625-59h1pmo"
					},
					"Children": [
						{
							"ID": "20220811164625-vyjx6gt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20220811164625-vyjx6gt"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "函数类： Injector， 用于实现递归依赖注入"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20220811164625-1qeii6z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-1qeii6z"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "每一种类型的注入定义都是interface+func类型， 在func中先判断被注入的对象是否实现了对应接口， 实现了则可以注入"
				}
			]
		},
		{
			"ID": "20220811164625-b1jgs43",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-b1jgs43"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-tsu1sv2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-tsu1sv2"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "type Cache interface {\n    InjectCache(cache cache.Cache) error\n}\n\nfunc CacheInto(c cache.Cache, i interface{}) (bool, error) {\n    if s, ok := i.(Cache); ok {\n        return true, s.InjectCache(c)\n    }\n    return false, nil\n}\n....\n\n// Func injects dependencies into i.\ntype Func func(i interface{}) error\n\n// Injector is used by the ControllerManager to inject Func into Controllers\ntype Injector interface {\n    InjectFunc(f Func) error\n}\n\n\nfunc InjectorInto(f Func, i interface{}) (bool, error) {\n    if ii, ok := i.(Injector); ok {\n        return true, ii.InjectFunc(f)\n    }\n    return false, nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-g6zfijy",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-g6zfijy"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "依赖注入示例"
				}
			]
		},
		{
			"ID": "20220811164625-7kbzbkq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-7kbzbkq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以下按照controllerManager—-\u003econtroller—\u003esrc的顺序验证依赖注入。 先看ControllerManager到Controller的依赖注入，在创建好controller后添加到controllerManager中(mgr.Add函数)， 实现将ControllerManager结构体实例的部分成员变量注册到Controller结构体实例中， 此时只要controller实现被注入对象的接口和注入方法即可，可以查看Controller的定义。"
				}
			]
		},
		{
			"ID": "20220811164625-glbljw7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-glbljw7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-9e0huuo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-9e0huuo"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/manager/internal.go\nfunc (cm *controllerManager) Add(r Runnable) error {\n    ...\n    if err := cm.SetFields(r); err != nil {\n        return err\n    }\n\n    ...\n}\n\n// 查看Controller的定义, 看其集成了哪些ControllerManager结构体变量的接口, 集成并实现注入方法。Controller一下变量均采用初始化完成的\n// src/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go\ntype Controller struct{\n    ....\n    Client client.Client\n    Scheme *runtime.Scheme\n    Cache cache.Cache\n    Config *rest.Config\n    ....\n}\n\n// Controller实现递归注入的函数, 将ControllerManager.SetFields赋给Controller.SetFields\nfunc (c *Controller) InjectFunc(f inject.Func) error {\n    c.SetFields = f\n    return nil\n}\n\n// 设置控制器结构体的字段信息.\nfunc (cm *controllerManager) SetFields(i interface{}) error {\n    if _, err := inject.ConfigInto(cm.config, i); err != nil {\n        return err\n    }\n    if _, err := inject.ClientInto(cm.client, i); err != nil {\n        return err\n    }\n    if _, err := inject.APIReaderInto(cm.apiReader, i); err != nil {\n        return err\n    }\n    if _, err := inject.SchemeInto(cm.scheme, i); err != nil {\n        return err\n    }\n    if _, err := inject.CacheInto(cm.cache, i); err != nil {\n        return err\n    }\n    // 递归注入函数\n    if _, err := inject.InjectorInto(cm.SetFields, i); err != nil {\n        return err\n    }\n    if _, err := inject.StopChannelInto(cm.internalStop, i); err != nil {\n        return err\n    }\n    if _, err := inject.MapperInto(cm.mapper, i); err != nil {\n        return err\n    }\n    return nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-a413yhx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-a413yhx"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "完成Controller的依赖注入后有： Controller.SetFields=ControllerManager.SetFields， 继续看Controller到Src的依赖注入，相关函数为Build.doWatch和Controller.Watch， 相关结构体是Kind"
				}
			]
		},
		{
			"ID": "20220811164625-i51vkq0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-i51vkq0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-g6wmj03",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-g6wmj03"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/builder/controller.go\nfunc (blder *Builder) doWatch() error {\n    ...\n    src := \u0026source.Kind{Type: blder.apiType}\n    hdler := \u0026handler.EnqueueRequestForObject{}\n    err := blder.ctrl.Watch(src, hdler, blder.predicates...)\n    ...\n}\n\n// src/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go\nfunc (c *Controller) Watch(src source.Source, evthdler handler.EventHandler, prct ...predicate.Predicate) error {\n    ...\n    if err := c.SetFields(src); err != nil {\n        return err\n    }\n    if err := c.SetFields(evthdler); err != nil {\n        return err\n    }\n    for _, pr := range prct {\n        if err := c.SetFields(pr); err != nil {\n            return err\n        }\n    }\n    ...\n}\n\n// 查看Kind的结构体和其实现的注入方法\ntype Kind struct {\n    // Type is the type of object to watch.  e.g. \u0026v1.Pod{}\n    Type runtime.Object\n\n    // cache used to watch APIs\n    cache cache.Cache\n}\n\nfunc (ks *Kind) InjectCache(c cache.Cache) error {\n    if ks.cache == nil {\n        ks.cache = c\n    }\n    return nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-zgqddtg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-zgqddtg"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如上， 在执行Controller.Watch时会将ControllerManager.cache注入进src(Kind)"
				}
			]
		},
		{
			"ID": "20220811164625-qsipce8",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220811164625-qsipce8"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Controller生产端启动过程"
				}
			]
		},
		{
			"ID": "20220811164625-p0zb3k4",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-p0zb3k4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "启动ControllerManager"
				}
			]
		},
		{
			"ID": "20220811164625-2plchez",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-2plchez"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "controller被ControllerManager托管， controller的启动也是从ControllerManager启动自顶向下的， 最终是在ControllerManager.startNonLeaderElectionRunnables中启动controller。startNonLeaderElectionRunnables先等待cache的启动再将controller拉起"
				}
			]
		},
		{
			"ID": "20220811164625-0qbvgrh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-0qbvgrh"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-vp97pen",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-vp97pen"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/larioy.xyz/main.go\nif err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {\n        setupLog.Error(err, \"problem running manager\")\n        os.Exit(1)\n    }\n\n// src/sigs.k8s.io/controller-runtime/pkg/manager/internal.go\nfunc (cm *controllerManager) Start(stop \u003c-chan struct{}) error {\n    defer close(cm.internalStopper)\n\n    cm.errSignal = \u0026errSignaler{errSignal: make(chan struct{})}\n\n    if cm.metricsListener != nil {\n        go cm.serveMetrics(cm.internalStop)\n    }\n\n    if cm.healthProbeListener != nil {\n        go cm.serveHealthProbes(cm.internalStop)\n    }\n\n    // 最终在这里面启动\n    go cm.startNonLeaderElectionRunnables()\n\n    if cm.resourceLock != nil {\n        err := cm.startLeaderElection()\n        if err != nil {\n            return err\n        }\n    } else {\n        go cm.startLeaderElectionRunnables()\n    }\n\n    select {\n    case \u003c-stop:\n        return nil\n    case \u003c-cm.errSignal.GotError():\n        return cm.errSignal.Error()\n    }\n}\n\n\nfunc (cm *controllerManager) startNonLeaderElectionRunnables() {\n    cm.mu.Lock()\n    defer cm.mu.Unlock()\n\n    // 等待cache启动\n    cm.waitForCache()\n\n    // Start the non-leaderelection Runnables after the cache has synced\n    for _, c := range cm.nonLeaderElectionRunnables {\n        ctrl := c\n        go func() {\n            if err := ctrl.Start(cm.internalStop); err != nil {\n                cm.errSignal.SignalError(err)\n            }\n            log.V(1).Info(\"non-leader-election runnable finished\", \"runnable type\", fmt.Sprintf(\"%T\", ctrl))\n        }()\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-is03rpj",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-is03rpj"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "启动cache"
				}
			]
		},
		{
			"ID": "20220811164625-1e6nq4o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-1e6nq4o"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "startNonLeaderElectionRunnables函数优先等待cache的启动。在实例化controllerManager时，传入了cache对象， 就是第一步分析创建的cache实例InformerMap， 所在文件为： src/sigs.k8s.io/controller-runtime/pkg/cache/internal/deleg_map.go。 其启动函数是启动每一个GVK的informer， 此时的ip.informersByGVK为空， 所以在cache的启动中暂时没有informer运行， Start函数只是将specificInformersMap设置为started状态。留下疑问： ip.informersByGVK是在哪里被赋值，然后启动informer的。"
				}
			]
		},
		{
			"ID": "20220811164625-nnwwr8n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-nnwwr8n"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-8wxbh69",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-8wxbh69"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/manager/internal.go\nfunc (cm *controllerManager) waitForCache() {\n    if cm.started {\n        return\n    }\n\n    if cm.startCache == nil {\n        cm.startCache = cm.cache.Start\n    }\n    go func() {\n        if err := cm.startCache(cm.internalStop); err != nil {\n            cm.errSignal.SignalError(err)\n        }\n    }()\n\n    cm.cache.WaitForCacheSync(cm.internalStop)\n    cm.started = true\n}\n\n// src/sigs.k8s.io/controller-runtime/pkg/cache/internal/deleg_map.go\nfunc (m *InformersMap) Start(stop \u003c-chan struct{}) error {\n    go m.structured.Start(stop)\n    go m.unstructured.Start(stop)\n    \u003c-stop\n    return nil\n}\n\n// src/sigs.k8s.io/controller-runtime/pkg/cache/internal/informers_map.go\n// 开启所有的specificInformer下管理的所有informer\nfunc (ip *specificInformersMap) Start(stop \u003c-chan struct{}) {\n    func() {\n        ip.mu.Lock()\n        defer ip.mu.Unlock()\n        ip.stop = stop\n\n        // 启动每一个informer\n        for _, informer := range ip.informersByGVK {\n            go informer.Informer.Run(stop)\n        }\n\n        // Set started to true so we immediately start any informers added later.\n        ip.started = true\n        close(ip.startWait)\n    }()\n    \u003c-stop\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-ge81cg2",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-ge81cg2"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "启动controller"
				}
			]
		},
		{
			"ID": "20220811164625-kachn61",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-kachn61"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接着继续分析controller的启动, 在startNonLeaderElectionRunnables中启动了controller， 转到controller.Start。"
				}
			]
		},
		{
			"ID": "20220811164625-k5so8u5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-k5so8u5"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-kt9ne43",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-kt9ne43"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go\nfunc (c *Controller) Start(stop \u003c-chan struct{}) error {\n    c.mu.Lock()\n\n    c.Queue = c.MakeQueue()\n    defer c.Queue.ShutDown() \n\n    err := func() error {\n        defer c.mu.Unlock()\n\n        defer utilruntime.HandleCrash()\n\n        // 将Builder.doWatch中添加的watches给启动起来\n        for _, watch := range c.watches {\n            log.Info(\"Starting EventSource\", \"controller\", c.Name, \"source\", watch.src)\n            if err := watch.src.Start(watch.handler, c.Queue, watch.predicates...); err != nil {\n                return err\n            }\n        }\n\n        log.Info(\"Starting Controller\", \"controller\", c.Name)\n\n        // 给等待本地缓存同步完赋值, 赋值为缓存函数\n        if c.WaitForCacheSync == nil {\n            c.WaitForCacheSync = c.Cache.WaitForCacheSync\n        }\n\n        // 之前已经启动cache的  在mgr.Start---\u003estartNonLeaderElectionRunnables---\u003ecm.waitForCache()启动的\n         // 但是那当时的cache是关闭的, 但是通过watch.src.Start真实的创建了informer后就需要等待informer同步完成了\n        if ok := c.WaitForCacheSync(stop); !ok {\n            err := fmt.Errorf(\"failed to wait for %s caches to sync\", c.Name)\n            log.Error(err, \"Could not wait for Cache to sync\", \"controller\", c.Name)\n            return err\n        }\n\n        if c.JitterPeriod == 0 {\n            c.JitterPeriod = 1 * time.Second\n        }\n\n        // Launch workers to process resources\n        log.Info(\"Starting workers\", \"controller\", c.Name, \"worker count\", c.MaxConcurrentReconciles)\n        for i := 0; i \u003c c.MaxConcurrentReconciles; i++ {\n            // 启动处理， worker是什么\n            go wait.Until(c.worker, c.JitterPeriod, stop)\n        }\n\n        c.Started = true\n        return nil\n    }()\n    if err != nil {\n        return err\n    }\n\n    \u003c-stop\n    log.Info(\"Stopping workers\", \"controller\", c.Name)\n    return nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-len4c02",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-len4c02"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "controller.Start将每一个controller.watches启动， 看到Controller.Start仍然是套娃， 也没看到informer的创建和启动， 得继续深入到watch.src.Start。 src是在Builder.doWatch中传递进来的， 其为Kind结构体"
				}
			]
		},
		{
			"ID": "20220811164625-kof4n5z",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20220811164625-kof4n5z"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "启动Source(Kind)"
				}
			]
		},
		{
			"ID": "20220811164625-983io1a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-983io1a"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在src/sigs.k8s.io/controller-runtime/pkg/source/source.go文件中有几个结构体实现了Source接口， 有Kind、Channel、Informer。 看源码Channel像是拿来测试的， 在kubebuiler中实际使用的Source的实现是Kind结构体。Kind完成informer的创建、并将事件回调与informer关联起来， kubebuiler层面为了支持预处理等也没有使用client-go的eventHandler，而是实现了自己的eventHandler(src/sigs.k8s.io/controller-runtime/pkg/source/internal/eventsource.go)。 informer的事件回调只是将元素添加到queue中，等待reconcile从queue中取出处理。"
				}
			]
		},
		{
			"ID": "20220811164625-4hnp6t4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-4hnp6t4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-hjg8rfx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-hjg8rfx"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/source/source.go\nfunc (ks *Kind) Start(handler handler.EventHandler, queue workqueue.RateLimitingInterface,\n    prct ...predicate.Predicate) error {\n\n    if ks.Type == nil {\n        return fmt.Errorf(\"must specify Kind.Type\")\n    }\n\n    // 必须确保cache已经创建\n    if ks.cache == nil {\n        return fmt.Errorf(\"must call CacheInto on Kind before calling Start\")\n    }\n\n    // 从cache中获取或使用client-go创建informer, 可回看cache创建部分\n    i, err := ks.cache.GetInformer(ks.Type)\n    if err != nil {\n        if kindMatchErr, ok := err.(*meta.NoKindMatchError); ok {\n            log.Error(err, \"if kind is a CRD, it should be installed before calling Start\",\n                \"kind\", kindMatchErr.GroupKind)\n        }\n        return err\n    }\n    // 添加事件回调\n    i.AddEventHandler(internal.EventHandler{Queue: queue, EventHandler: handler, Predicates: prct})\n    return nil\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-362en52",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-362en52"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在controller.Start函数中，将controller.Queue传递给src， 这个queue是controller.MakeQueue创建的。 handler是创建Kind时生成的， handler是专门在监控对象加入controller.Queue前进行处理的， 相当于是中间件。  handler相关的文件在： src/sigs.k8s.io/controller-runtime/pkg/source/internal/eventsource.go和src/sigs.k8s.io/controller-runtime/pkg/source/internal/eventsource.go。ks.cache.GetInformer分析见上面cache创建过程"
				}
			]
		},
		{
			"ID": "20220811164625-ilbj98s",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220811164625-ilbj98s"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Controller消费端"
				}
			]
		},
		{
			"ID": "20220811164625-lgrfvfw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-lgrfvfw"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "kubebuilder原则上只处理一种类型的资源， 在Controller.processNextWorkItem中处理， 遵循常规的controller套路。如下， 主要重点考虑Reconcile失败后kubebuiler是怎么处理元素的， kubebuiler暴露给开发者的接口有哪些属性和方法可以使用。在用户自定义资源实现的Reconcile处理函数中执行失败有两种重试方法，立即加入限速队列或者加入延时队列等待重新被消费。"
				}
			]
		},
		{
			"ID": "20220811164625-2xggej8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-2xggej8"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "go"
				}
			]
		},
		{
			"ID": "20220811164625-qo5nyoi",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20220811164625-qo5nyoi"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Z28="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// src/sigs.k8s.io/controller-runtime/pkg/internal/controller/controller.go\nfunc (c *Controller) Start(stop \u003c-chan struct{}) error {\n    ...\n        for i := 0; i \u003c c.MaxConcurrentReconciles; i++ {\n            // 启动处理\n            go wait.Until(c.worker, c.JitterPeriod, stop)\n        }\n    ...\n}\n\nfunc (c *Controller) worker() {\n    for c.processNextWorkItem() {\n    }\n}\n\nfunc (c *Controller) processNextWorkItem() bool {\n    obj, shutdown := c.Queue.Get()\n    if shutdown {\n        return false\n    }\n\n    defer c.Queue.Done(obj)\n\n    return c.reconcileHandler(obj)\n}\n\nfunc (c *Controller) reconcileHandler(obj interface{}) bool {\n    reconcileStartTS := time.Now()\n    defer func() {\n        c.updateMetrics(time.Now().Sub(reconcileStartTS))\n    }()\n\n    var req reconcile.Request\n    var ok bool\n    // 将不是reconcile.Request类型的object丢弃\n    if req, ok = obj.(reconcile.Request); !ok {\n        c.Queue.Forget(obj)\n        log.Error(nil, \"Queue item was not a Request\",\n            \"controller\", c.Name, \"type\", fmt.Sprintf(\"%T\", obj), \"value\", obj)\n        return true\n    }\n    // 传入namespace/Name字符串格式的resource等待被处理..., 是由用户实现的Reconcile来处理元素, 用户可以根据namespace/Name到缓存中查找资源对象\n    if result, err := c.Do.Reconcile(req); err != nil {\n        c.Queue.AddRateLimited(req)\n        log.Error(err, \"Reconciler error\", \"controller\", c.Name, \"request\", req)\n        ctrlmetrics.ReconcileErrors.WithLabelValues(c.Name).Inc()\n        ctrlmetrics.ReconcileTotal.WithLabelValues(c.Name, \"error\").Inc()\n        return false\n    } else if result.RequeueAfter \u003e 0 {\n        // 将处理失败的对象延迟放到队列中\n        c.Queue.Forget(obj)\n        c.Queue.AddAfter(req, result.RequeueAfter)\n        ctrlmetrics.ReconcileTotal.WithLabelValues(c.Name, \"requeue_after\").Inc()\n        return true\n    } else if result.Requeue {\n        c.Queue.AddRateLimited(req)\n        ctrlmetrics.ReconcileTotal.WithLabelValues(c.Name, \"requeue\").Inc()\n        return true\n    }\n\n    // 元素被正确处理, 达到了期望的状态, 将元素从队列中移除掉\n    c.Queue.Forget(obj)\n\n    log.V(1).Info(\"Successfully Reconciled\", \"controller\", c.Name, \"request\", req)\n\n    ctrlmetrics.ReconcileTotal.WithLabelValues(c.Name, \"success\").Inc()\n    // Return true, don't take a break\n    return true\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20220811164625-zjqgyyw",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20220811164625-zjqgyyw"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结"
				}
			]
		},
		{
			"ID": "20220811164625-lwqesit",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-lwqesit"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "把controller-runtime的执行逻辑大概分析了， 还有webhook等没有分析， controller-runtime底层还是使用到了client-go的那一套东东， 然后再对controller、cache、EventHandler等做了一定的改造。"
				}
			]
		},
		{
			"ID": "20220811164625-2ushg5k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-2ushg5k"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "kubebuilder的结构体有明显的分层：Kind—\u003ewatchDescription.src—\u003econtroller.watches—\u003econtrollerManager的分层， Builder.doController中crd的Reconcile在Controller创建时绑定到Controller.Do上， 监控对象封装结构体watchDescription和Controller的绑定是在Builder.doWatch中完成。 最最重要的informer创建只有到最后一级Kind.Start才完成， Controller也才算跑起来"
				}
			]
		},
		{
			"ID": "20220811164625-79elps9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20220811164625-79elps9"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "也分析了controllerManager、Controller、Kind等的创建即相关绑定，Controller queue的生产和消费端的数据传输的过程，即informer和Controller queue连接以及Controller queue与crd Reconcile的连接"
				}
			]
		},
		{
			"ID": "20230406103156-y3s5pbh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230406103156-y3s5pbh",
				"updated": "20230406103156"
			}
		}
	]
}