{
	"ID": "20241107163840-m8t40u2",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20241107163840-m8t40u2",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20241107163840-lahx8xm\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20241107163840-d9m3c34\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20241107163840-68gmm01\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "25 张图，一万字，拆解 Linux 网络包发送过程",
		"updated": "20241107163840"
	},
	"Children": [
		{
			"ID": "20241107163840-lahx8xm",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20241107163840-lahx8xm",
				"updated": "20241107163840"
			}
		},
		{
			"ID": "20241107163840-z7n420s",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20241107163840-z7n420s",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"ID": "20241107163840-f7ish8v",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-f7ish8v",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-0yzu4bs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-0yzu4bs",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026mid=2247485146\u0026idx=1\u0026sn=e5bfc79ba915df1f6a8b32b87ef0ef78\u0026chksm=a6e307e191948ef748dc73a4b9a862a22ce1db806a486afce57475d4331d905827d6ca161711\u0026scene=21#wechat_redirect",
									"TextMarkTextContent": "https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026amp;mid=2247485146\u0026amp;idx=1\u0026amp;sn=e5bfc79ba915df1f6a8b32b87ef0ef78\u0026amp;chksm=a6e307e191948ef748dc73a4b9a862a22ce1db806a486afce57475d4331d905827d6ca161711\u0026amp;scene=21#wechat_redirect - 微信公众平台"
								}
							]
						}
					]
				},
				{
					"ID": "20241107163840-rykgvlc",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-rykgvlc",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-ts6lxbb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-ts6lxbb",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "今天我们来聊另一个深度的话题，那就是 Linux 内核是怎么样将一个网络包发送出去的呢？"
								}
							]
						}
					]
				},
				{
					"ID": "20241107163840-i3pyjd5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-i3pyjd5",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-xway7mk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-xway7mk",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2024-11-07 16:38:40"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20241107163840-dh20586",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20241107163840-dh20586",
				"updated": "20241107163840"
			}
		},
		{
			"ID": "20241107163840-x6mchtj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-x6mchtj",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大家好，我是飞哥!"
				}
			]
		},
		{
			"ID": "20241107163840-kdm0dls",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-kdm0dls",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "半年前我以源码的方式描述了网络包的接收过程。之后不断有粉丝提醒我还没聊发送过程呢。好，安排！"
				}
			]
		},
		{
			"ID": "20241107163840-stypr1e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-stypr1e",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在开始今天的文章之前，我先来请大家思考几个小问题。"
				}
			]
		},
		{
			"ID": "20241107163840-96i01g9",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20241107163840-96i01g9",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"ID": "20241107163840-409914z",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-409914z",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-atz59ah",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-atz59ah",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？"
								}
							]
						}
					]
				},
				{
					"ID": "20241107163840-58bp7z9",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-58bp7z9",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-y7j59gz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-y7j59gz",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "问2：为什么你服务器上的 /proc/softirqs 里 NET_RX 要比 NET_TX 大的多的多？"
								}
							]
						}
					]
				},
				{
					"ID": "20241107163840-hfkuneq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-hfkuneq",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-ap3o4l4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-ap3o4l4",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "问3：发送网络数据的时候都涉及到哪些内存拷贝操作？"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20241107163840-ad7cztk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ad7cztk",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这些问题虽然在线上经常看到，但我们似乎很少去深究。如果真的能透彻地把这些问题理解到位，我们对性能的掌控能力将会变得更强。"
				}
			]
		},
		{
			"ID": "20241107163840-5i6vb9y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-5i6vb9y",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "带着这三个问题，我们开始今天对 Linux 内核网络发送过程的深度剖析。还是按照我们之前的传统，先从一段简单的代码作为切入。如下代码是一个典型服务器程序的典型的缩微代码："
				}
			]
		},
		{
			"ID": "20241107163840-vb5d2rc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-vb5d2rc",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int main(){\n fd = socket(AF_INET, SOCK_STREAM, 0);\n bind(fd, ...);\n listen(fd, ...); cfd = accept(fd, ...); // 接收用户请求\n read(cfd, ...); // 用户请求处理\n dosometing();  // 给用户返回结果\n send(cfd, buf, sizeof(buf), 0);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-68gmm01",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-68gmm01",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "今天我们来讨论上述代码中，调用 send 之后内核是怎么样把数据包发送出去的。本文基于Linux 3.10，网卡驱动采用Intel的igb网卡举例。"
				}
			]
		},
		{
			"ID": "20241107163840-cpc4eqp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cpc4eqp",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "预警：本文共有一万多字，25 张图，长文慎入！"
				}
			]
		},
		{
			"ID": "20241107163840-vbgeik4",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107163840-vbgeik4",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一、Linux 网络发送过程总览"
				}
			]
		},
		{
			"ID": "20241107163840-n6n9mng",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-n6n9mng",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我觉得看 Linux 源码最重要的是得有整体上的把握，而不是一开始就陷入各种细节。"
				}
			]
		},
		{
			"ID": "20241107163840-7z2djze",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-7z2djze",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我这里先给大家准备了一个总的流程图，简单阐述下 send 发送了的数据是如何一步一步被发送到网卡的。"
				}
			]
		},
		{
			"ID": "20241107163840-mj0zecx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-mj0zecx",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-zs1ve8a"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-7bgli5c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-7bgli5c",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这幅图中，我们看到用户数据被拷贝到内核态，然后经过协议栈处理后进入到了 RingBuffer 中。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知 CPU，然后清理 RingBuffer。"
				}
			]
		},
		{
			"ID": "20241107163840-ukkdblw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ukkdblw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为文章后面要进入源码，所以我们再从源码的角度给出一个流程图。"
				}
			]
		},
		{
			"ID": "20241107163840-34y26sy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-34y26sy",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-uqb872e"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-9dd4g0v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-9dd4g0v",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。"
				}
			]
		},
		{
			"ID": "20241107163840-02was4g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-02was4g",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图："
				}
			]
		},
		{
			"ID": "20241107163840-3gixu0v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-3gixu0v",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-jtyi8u7"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-s6bmcsb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-s6bmcsb",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意，我们今天的主题虽然是发送数据，但是硬中断最终触发的软中断却是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ ！！！（T 是 transmit 的缩写，R 表示 receive）"
				}
			]
		},
		{
			"ID": "20241107163840-ygs7cuz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ygs7cuz",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "意不意外，惊不惊喜？？？"
				}
			]
		},
		{
			"ID": "20241107163840-sb0nqfw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-sb0nqfw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以这就是开篇问题 1 的一部分的原因（注意，这只是一部分原因）。"
				}
			]
		},
		{
			"ID": "20241107163840-tj8m27b",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20241107163840-tj8m27b",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20241107163840-97uvo3f",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20241107163840-97uvo3f",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "问1：在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？"
						}
					]
				}
			]
		},
		{
			"ID": "20241107163840-1zs4tcw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-1zs4tcw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "传输完成最终会触发 NET_RX，而不是 NET_TX。所以自然你观测 /proc/softirqs 也就能看到 NET_RX 更多了。"
				}
			]
		},
		{
			"ID": "20241107163840-0xjusye",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-0xjusye",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好，现在你已经对内核是怎么发送网络包的有一个全局上的把握了。不要得意，我们需要了解的细节才是更有价值的地方，让我们继续！！"
				}
			]
		},
		{
			"ID": "20241107163840-eo8s8r8",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107163840-eo8s8r8",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "二、网卡启动准备"
				}
			]
		},
		{
			"ID": "20241107163840-0whnjyu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-0whnjyu",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在的服务器上的网卡一般都是支持多队列的。每一个队列上都是由一个 RingBuffer 表示的，开启了多队列以后的的网卡就会对应有多个 RingBuffer。"
				}
			]
		},
		{
			"ID": "20241107163840-lmm0060",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-lmm0060",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-xyjpe6y"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-vh32754",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-vh32754",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "网卡在启动时最重要的任务之一就是分配和初始化 RingBuffer，理解了 RingBuffer 将会非常有助于后面我们掌握发送。因为今天的主题是发送，所以就以传输队列为例，我们来看下网卡启动时分配 RingBuffer 的实际过程。"
				}
			]
		},
		{
			"ID": "20241107163840-y12giye",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-y12giye",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在网卡启动的时候，会调用到 __igb_open 函数，RingBuffer 就是在这里分配的。"
				}
			]
		},
		{
			"ID": "20241107163840-6n944la",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-6n944la",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic int __igb_open(struct net_device *netdev, bool resuming)\n{\n struct igb_adapter *adapter = netdev_priv(netdev); //分配传输描述符数组\n err = igb_setup_all_tx_resources(adapter); //分配接收描述符数组\n err = igb_setup_all_rx_resources(adapter); //开启全部队列\n netif_tx_start_all_queues(netdev);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-qd4gllm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-qd4gllm",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在上面 __igb_open 函数调用 igb_setup_all_tx_resources 分配所有的传输 RingBuffer, 调用 igb_setup_all_rx_resources 创建所有的接收 RingBuffer。"
				}
			]
		},
		{
			"ID": "20241107163840-0sgvyc0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-0sgvyc0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic int igb_setup_all_tx_resources(struct igb_adapter *adapter)\n{\n //有几个队列就构造几个 RingBuffer\n for (i = 0; i \u003c adapter-\u003enum_tx_queues; i++) {\n  igb_setup_tx_resources(adapter-\u003etx_ring[i]);\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-cp1zonl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cp1zonl",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "真正的 RingBuffer 构造过程是在 igb_setup_tx_resources 中完成的。"
				}
			]
		},
		{
			"ID": "20241107163840-ywzj73g",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-ywzj73g",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nint igb_setup_tx_resources(struct igb_ring *tx_ring)\n{\n //1.申请 igb_tx_buffer 数组内存\n size = sizeof(struct igb_tx_buffer) * tx_ring-\u003ecount;\n tx_ring-\u003etx_buffer_info = vzalloc(size); //2.申请 e1000_adv_tx_desc DMA 数组内存\n tx_ring-\u003esize = tx_ring-\u003ecount * sizeof(union e1000_adv_tx_desc);\n tx_ring-\u003esize = ALIGN(tx_ring-\u003esize, 4096);\n tx_ring-\u003edesc = dma_alloc_coherent(dev, tx_ring-\u003esize,\n        \u0026tx_ring-\u003edma, GFP_KERNEL); //3.初始化队列成员\n tx_ring-\u003enext_to_use = 0;\n tx_ring-\u003enext_to_clean = 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-ab7pgoy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ab7pgoy",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从上述源码可以看到，实际上一个 RingBuffer 的内部不仅仅是一个环形队列数组，而是有两个。"
				}
			]
		},
		{
			"ID": "20241107163840-ql6g0hf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ql6g0hf",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1）igb_tx_buffer 数组：这个数组是内核使用的，通过 vzalloc 申请的。\n2）e1000_adv_tx_desc 数组：这个数组是网卡硬件使用的，硬件是可以通过 DMA 直接访问这块内存，通过 dma_alloc_coherent 分配。"
				}
			]
		},
		{
			"ID": "20241107163840-gxkjgtx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-gxkjgtx",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。"
				}
			]
		},
		{
			"ID": "20241107163840-vxnm325",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-vxnm325",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-4g1qbjt"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-4tp0pcq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-4tp0pcq",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最后调用 netif_tx_start_all_queues 开启队列。另外，对于硬中断的处理函数 igb_msix_ring 其实也是在 __igb_open 中注册的。"
				}
			]
		},
		{
			"ID": "20241107163840-lqv8ptz",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107163840-lqv8ptz",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "三、accept 创建新 socket"
				}
			]
		},
		{
			"ID": "20241107163840-ndpb58j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ndpb58j",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在发送数据之前，我们往往还需要一个已经建立好连接的 socket。"
				}
			]
		},
		{
			"ID": "20241107163840-5fbyavt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-5fbyavt",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们就以开篇服务器缩微源代码中提到的 accept 为例，当 accept 之后，进程会创建一个新的 socket 出来，然后把它放到当前进程的打开文件列表中，专门用于和对应的客户端通信。"
				}
			]
		},
		{
			"ID": "20241107163840-ddhi197",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ddhi197",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "假设服务器进程通过 accept 和客户端建立了两条连接，我们来简单看一下这两条连接和进程的关联关系。"
				}
			]
		},
		{
			"ID": "20241107163840-dzv0h73",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-dzv0h73",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-ixjresr"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-266b1cz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-266b1cz",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中代表一条连接的 socket 内核对象更为具体一点的结构图如下。"
				}
			]
		},
		{
			"ID": "20241107163840-79gh7lm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-79gh7lm",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-0bnjfmo"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-famkf27",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-famkf27",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了避免喧宾夺主，accept 详细的源码过程这里就不介绍了，感兴趣请参考 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026mid=2247484905\u0026idx=1\u0026sn=a74ed5d7551c4fb80a8abe057405ea5e\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》"
				},
				{
					"Type": "NodeText",
					"Data": "。一文中的第一部分。"
				}
			]
		},
		{
			"ID": "20241107163840-eo68q4x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-eo68q4x",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "今天我们还是把重点放到数据发送过程上。"
				}
			]
		},
		{
			"ID": "20241107163840-dl9fa9x",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107163840-dl9fa9x",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "四、发送数据真正开始"
				}
			]
		},
		{
			"ID": "20241107163840-4fav0q0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-4fav0q0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.1 send 系统调用实现"
				}
			]
		},
		{
			"ID": "20241107163840-e5x9yle",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-e5x9yle",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "send 系统调用的源码位于文件 net/socket.c 中。在这个系统调用里，内部其实真正使用的是 sendto 系统调用。整个调用链条虽然不短，但其实主要只干了两件简单的事情，"
				}
			]
		},
		{
			"ID": "20241107163840-9s0rp7d",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20241107163840-9s0rp7d",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"ID": "20241107163840-cwwsb2z",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-cwwsb2z",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-gampn86",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-gampn86",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一是在内核中把真正的 socket 找出来，在这个对象里记录着各种协议栈的函数地址。"
								}
							]
						}
					]
				},
				{
					"ID": "20241107163840-va7ypwf",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107163840-va7ypwf",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"ID": "20241107163840-mrs0biv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107163840-mrs0biv",
								"updated": "20241107163840"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第二是构造一个 struct msghdr 对象，把用户传入的数据，比如 buffer地址、数据长度啥的，统统都装进去."
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20241107163840-2rklaa0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-2rklaa0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "剩下的事情就交给下一层，协议栈里的函数 inet_sendmsg 了，其中 inet_sendmsg 函数的地址是通过 socket 内核对象里的 ops 成员找到的。大致流程如图。"
				}
			]
		},
		{
			"ID": "20241107163840-j6zbdlu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-j6zbdlu",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-484gcg6"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-hels4ka",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-hels4ka",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有了上面的了解，我们再看起源码就要容易许多了。源码如下："
				}
			]
		},
		{
			"ID": "20241107163840-j3853he",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-j3853he",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/socket.c\nSYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,\n  unsigned int, flags)\n{\n return sys_sendto(fd, buff, len, flags, NULL, 0);\n}SYSCALL_DEFINE6(......)\n{\n //1.根据 fd 查找到 socket\n sock = sockfd_lookup_light(fd, \u0026err, \u0026fput_needed); //2.构造 msghdr\n struct msghdr msg;\n struct iovec iov; iov.iov_base = buff;\n iov.iov_len = len;\n msg.msg_iovlen = 1; msg.msg_iov = \u0026iov;\n msg.msg_flags = flags;\n ...... //3.发送数据\n sock_sendmsg(sock, \u0026msg, len);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-ldxlcng",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ldxlcng",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。"
				}
			]
		},
		{
			"ID": "20241107163840-slj11c0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-slj11c0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。"
				}
			]
		},
		{
			"ID": "20241107163840-cwh5z1z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cwh5z1z",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接着调用了 sock_sendmsg =\u003e __sock_sendmsg ==\u003e  __sock_sendmsg_nosec。在__sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。"
				}
			]
		},
		{
			"ID": "20241107163840-uucq1vh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-uucq1vh",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/socket.c\nstatic inline int __sock_sendmsg_nosec(...)\n{\n ......\n return sock-\u003eops-\u003esendmsg(iocb, sock, msg, size);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-im0q6k3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-im0q6k3",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过第三节里的 socket 内核对象结构图，我们可以看到，这里调用的是 sock-\u003eops-\u003esendmsg 实际执行的是 inet_sendmsg。这个函数是 AF_INET 协议族提供的通用发送函数。"
				}
			]
		},
		{
			"ID": "20241107163840-dbnpxyn",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-dbnpxyn",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.2 传输层处理"
				}
			]
		},
		{
			"ID": "20241107163840-0h0ewm2",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20241107163840-0h0ewm2",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1）传输层拷贝"
				}
			]
		},
		{
			"ID": "20241107163840-li7emrq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-li7emrq",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在进入到协议栈 inet_sendmsg 以后，内核接着会找到 socket 上的具体协议发送函数。对于 TCP 协议来说，那就是 tcp_sendmsg（同样也是通过 socket 内核对象找到的）。"
				}
			]
		},
		{
			"ID": "20241107163840-sty3nyv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-sty3nyv",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这个函数中，内核会申请一个内核态的 skb 内存，将用户待发送的数据拷贝进去。注意这个时候不一定会真正开始发送，如果没有达到发送条件的话很可能这次调用直接就返回了。大概过程如图："
				}
			]
		},
		{
			"ID": "20241107163840-f09z92x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-f09z92x",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-6gxtxgk"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-3e6m5u2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-3e6m5u2",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们来看 inet_sendmsg 函数的源码。"
				}
			]
		},
		{
			"ID": "20241107163840-q4n3jxt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-q4n3jxt",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/af_inet.c\nint inet_sendmsg(......)\n{\n ......\n return sk-\u003esk_prot-\u003esendmsg(iocb, sk, msg, size);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-itwnd5e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-itwnd5e",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这个函数中会调用到具体协议的发送函数。同样参考第三节里的 socket 内核对象结构图，我们看到对于 TCP 协议下的 socket 来说，来说 sk-\u003esk_prot-\u003esendmsg 指向的是 tcp_sendmsg（对于 UPD 来说是 udp_sendmsg）。"
				}
			]
		},
		{
			"ID": "20241107163840-eo75wqv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-eo75wqv",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "tcp_sendmsg 这个函数比较长，我们分多次来看它。先看这一段"
				}
			]
		},
		{
			"ID": "20241107163840-e87d7pd",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-e87d7pd",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/tcp.c\nint tcp_sendmsg(...)\n{\n while(...){\n  while(...){\n   //获取发送队列\n   skb = tcp_write_queue_tail(sk);   //申请skb 并拷贝\n   ......\n  }\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-ite415n",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-ite415n",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: include/net/tcp.h\nstatic inline struct sk_buff *tcp_write_queue_tail(const struct sock *sk)\n{\n return skb_peek_tail(\u0026sk-\u003esk_write_queue);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-17s8i6o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-17s8i6o",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "理解对 socket 调用 tcp_write_queue_tail 是理解发送的前提。如上所示，这个函数是在获取 socket 发送队列中的最后一个 skb。skb 是 struct sk_buff 对象的简称，用户的发送队列就是该对象组成的一个链表。"
				}
			]
		},
		{
			"ID": "20241107163840-cm9ns5x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cm9ns5x",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-xh03ya2"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-jlmqwrj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-jlmqwrj",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们再接着看 tcp_sendmsg 的其它部分。"
				}
			]
		},
		{
			"ID": "20241107163840-i3x6n3f",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-i3x6n3f",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/tcp.c\nint tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n  size_t size)\n{\n //获取用户传递过来的数据和标志\n iov = msg-\u003emsg_iov; //用户数据地址\n iovlen = msg-\u003emsg_iovlen; //数据块数为1\n flags = msg-\u003emsg_flags; //各种标志 //遍历用户层的数据块\n while (--iovlen \u003e= 0) {  //待发送数据块的地址\n  unsigned char __user *from = iov-\u003eiov_base;  while (seglen \u003e 0) {   //需要申请新的 skb\n   if (copy \u003c= 0) {    //申请 skb，并添加到发送队列的尾部\n    skb = sk_stream_alloc_skb(sk,\n         select_size(sk, sg),\n         sk-\u003esk_allocation);    //把 skb 挂到socket的发送队列上\n    skb_entail(sk, skb);\n   }   // skb 中有足够的空间\n   if (skb_availroom(skb) \u003e 0) {\n    //拷贝用户空间的数据到内核空间，同时计算校验和\n    //from是用户空间的数据地址 \n    skb_add_data_nocache(sk, skb, from, copy);\n   } \n   ......\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-abq98dx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-abq98dx",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个函数比较长，不过其实逻辑并不复杂。其中 msg-\u003emsg_iov 存储的是用户态内存的要发送的数据的 buffer。接下来在内核态申请内核内存，比如 skb，并把用户内存里的数据拷贝到内核态内存中。​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "这就会涉及到一次或者几次内存拷贝的开销"
				},
				{
					"Type": "NodeText",
					"Data": "​。"
				}
			]
		},
		{
			"ID": "20241107163840-zoddnb5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-zoddnb5",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-1h13gtb"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-l38akyh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-l38akyh",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "至于内核什么时候真正把 skb 发送出去。在 tcp_sendmsg 中会进行一些判断。"
				}
			]
		},
		{
			"ID": "20241107163840-5jdwxd3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-5jdwxd3",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/tcp.c\nint tcp_sendmsg(...)\n{\n while(...){\n  while(...){\n   //申请内核内存并进行拷贝   //发送判断\n   if (forced_push(tp)) {\n    tcp_mark_push(tp, skb);\n    __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);\n   } else if (skb == tcp_send_head(sk))\n    tcp_push_one(sk, mss_now);  \n   }\n   continue;\n  }\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-ph3k7in",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ph3k7in",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "只有满足 forced_push(tp) 或者 skb == tcp_send_head(sk) 成立的时候，内核才会真正启动发送数据包。其中 forced_push(tp) 判断的是未发送的数据数据是否已经超过最大窗口的一半了。"
				}
			]
		},
		{
			"ID": "20241107163840-ewa2kbz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ewa2kbz",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "条件都不满足的话，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "这次的用户要发送的数据只是拷贝到内核就算完事了！"
				}
			]
		},
		{
			"ID": "20241107163840-b4x9c1j",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20241107163840-b4x9c1j",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2）传输层发送"
				}
			]
		},
		{
			"ID": "20241107163840-30eqfj6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-30eqfj6",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "假设现在内核发送条件已经满足了，我们再来跟踪一下实际的发送过程。对于上小节函数中，当满足真正发送条件的时候，无论调用的是 __tcp_push_pending_frames 还是 tcp_push_one 最终都实际会执行到 tcp_write_xmit。"
				}
			]
		},
		{
			"ID": "20241107163840-jz6ox8a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-jz6ox8a",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以我们直接从 tcp_write_xmit 看起，这个函数处理了传输层的拥塞控制、滑动窗口相关的工作。满足窗口要求的时候，设置一下 TCP 头然后将 skb 传到更低的网络层进行处理。"
				}
			]
		},
		{
			"ID": "20241107163840-2go10ad",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-2go10ad",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-7adifax"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-et47v64",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-et47v64",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们来看下 tcp_write_xmit 的源码。"
				}
			]
		},
		{
			"ID": "20241107163840-s83sphn",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-s83sphn",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/tcp_output.c\nstatic bool tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,\n      int push_one, gfp_t gfp)\n{\n //循环获取待发送 skb\n while ((skb = tcp_send_head(sk))) \n {\n  //滑动窗口相关\n  cwnd_quota = tcp_cwnd_test(tp, skb);\n  tcp_snd_wnd_test(tp, skb, mss_now);\n  tcp_mss_split_point(...);\n  tso_fragment(sk, skb, ...);\n  ......  //真正开启发送\n  tcp_transmit_skb(sk, skb, 1, gfp);\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-mti7d9e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-mti7d9e",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看到我们之前在网络协议里学的滑动窗口、拥塞控制就是在这个函数中完成的，这部分就不过多展开了，感兴趣同学自己找这段源码来读。我们今天只看发送主过程，那就走到了 tcp_transmit_skb。"
				}
			]
		},
		{
			"ID": "20241107163840-cden5lk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-cden5lk",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/tcp_output.c\nstatic int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,\n    gfp_t gfp_mask)\n{\n //1.克隆新 skb 出来\n if (likely(clone_it)) {\n  skb = skb_clone(skb, gfp_mask);\n  ......\n } //2.封装 TCP 头\n th = tcp_hdr(skb);\n th-\u003esource  = inet-\u003einet_sport;\n th-\u003edest  = inet-\u003einet_dport;\n th-\u003ewindow  = ...;\n th-\u003eurg   = ...;\n ...... //3.调用网络层发送接口\n err = icsk-\u003eicsk_af_ops-\u003equeue_xmit(skb, \u0026inet-\u003ecork.fl);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-tjk72kq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-tjk72kq",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第一件事是先克隆一个新的 skb，这里重点说下为什么要复制一个 skb 出来呢？"
				}
			]
		},
		{
			"ID": "20241107163840-kmpipwi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-kmpipwi",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "是因为 skb 后续在调用网络层，最后到达网卡发送完成的时候，这个 skb 会被释放掉。而我们知道 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 skb 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 skb 的一个拷贝。等收到 ACK 再真正删除。"
				}
			]
		},
		{
			"ID": "20241107163840-pa71ozq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-pa71ozq",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第二件事是修改 skb 中的 TCP header，根据实际情况把 TCP 头设置好。这里要介绍一个小技巧，skb 内部其实包含了网络协议中所有的 header。在设置 TCP 头的时候，只是把指针指向 skb 的合适位置。后面再设置 IP 头的时候，在把指针挪一挪就行，避免频繁的内存申请和拷贝，效率很高。"
				}
			]
		},
		{
			"ID": "20241107163840-auelrx0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-auelrx0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-dmpdl68"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-cmhvnt3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cmhvnt3",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "tcp_transmit_skb 是发送数据位于传输层的最后一步，接下来就可以进入到网络层进行下一层的操作了。调用了网络层提供的发送接口icsk-\u003eicsk_af_ops-\u003equeue_xmit()。"
				}
			]
		},
		{
			"ID": "20241107163840-cjiof1x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cjiof1x",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在下面的这个源码中，我们的知道了 queue_xmit 其实指向的是 ip_queue_xmit 函数。"
				}
			]
		},
		{
			"ID": "20241107163840-fdsd3db",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-fdsd3db",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/tcp_ipv4.c\nconst struct inet_connection_sock_af_ops ipv4_specific = {\n .queue_xmit    = ip_queue_xmit,\n .send_check    = tcp_v4_send_check,\n ...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-2gyxlbu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-2gyxlbu",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "自此，传输层的工作也就都完成了。数据离开了传输层，接下来将会进入到内核在网络层的实现里。"
				}
			]
		},
		{
			"ID": "20241107163840-z38o5b1",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-z38o5b1",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.3 网络层发送处理"
				}
			]
		},
		{
			"ID": "20241107163840-mg6x8bw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-mg6x8bw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Linux 内核网络层的发送的实现位于 net/ipv4/ip_output.c 这个文件。传输层调用到的 ip_queue_xmit 也在这里。（从文件名上也能看出来进入到 IP 层了，源文件名已经从 tcp_xxx 变成了 ip_xxx。）"
				}
			]
		},
		{
			"ID": "20241107163840-zsljjsa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-zsljjsa",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在网络层里主要处理路由项查找、IP 头设置、netfilter 过滤、skb 切分（大于 MTU 的话）等几项工作，处理完这些工作后会交给更下层的邻居子系统来处理。"
				}
			]
		},
		{
			"ID": "20241107163840-pkllxly",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-pkllxly",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-udd5snf"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-2upx4fx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-2upx4fx",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们来看网络层入口函数 ip_queue_xmit 的源码："
				}
			]
		},
		{
			"ID": "20241107163840-r7g3dxw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-r7g3dxw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/ip_output.c\nint ip_queue_xmit(struct sk_buff *skb, struct flowi *fl)\n{\n //检查 socket 中是否有缓存的路由表\n rt = (struct rtable *)__sk_dst_check(sk, 0);\n if (rt == NULL) {\n  //没有缓存则展开查找\n  //则查找路由项， 并缓存到 socket 中\n  rt = ip_route_output_ports(...);\n  sk_setup_caps(sk, \u0026rt-\u003edst);\n } //为 skb 设置路由表\n skb_dst_set_noref(skb, \u0026rt-\u003edst); //设置 IP header\n iph = ip_hdr(skb);\n iph-\u003eprotocol = sk-\u003esk_protocol;\n iph-\u003ettl      = ip_select_ttl(inet, \u0026rt-\u003edst);\n iph-\u003efrag_off = ...; //发送\n ip_local_out(skb);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-ld5kb26",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ld5kb26",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ip_queue_xmit 已经到了网络层，在这个函数里我们看到了网络层相关的功能路由项查找，如果找到了则设置到 skb 上（没有路由的话就直接报错返回了）。"
				}
			]
		},
		{
			"ID": "20241107163840-1qzk7ug",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-1qzk7ug",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Linux 上通过 route 命令可以看到你本机的路由配置。"
				}
			]
		},
		{
			"ID": "20241107163840-qqhwo5j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-qqhwo5j",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-pr5b08w"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-03v5gvh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-03v5gvh",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在路由表中，可以查到某个目的网络应该通过哪个 Iface（网卡），哪个 Gateway（网卡）发送出去。查找出来以后缓存到 socket 上，下次再发送数据就不用查了。"
				}
			]
		},
		{
			"ID": "20241107163840-3p5a0aq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-3p5a0aq",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接着把路由表地址也放到 skb 里去。"
				}
			]
		},
		{
			"ID": "20241107163840-drlamvf",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-drlamvf",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: include/linux/skbuff.h\nstruct sk_buff {\n //保存了一些路由相关信息\n unsigned long  _skb_refdst;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-674s1hg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-674s1hg",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来就是定位到 skb 里的 IP 头的位置上，然后开始按照协议规范设置 IP header。"
				}
			]
		},
		{
			"ID": "20241107163840-teyk9sw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-teyk9sw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-p14a0e0"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-5unim95",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-5unim95",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再通过 ip_local_out 进入到下一步的处理。"
				}
			]
		},
		{
			"ID": "20241107163840-braf14c",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-braf14c",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/ip_output.c  \nint ip_local_out(struct sk_buff *skb)\n{\n //执行 netfilter 过滤\n err = __ip_local_out(skb); //开始发送数据\n if (likely(err == 1))\n  err = dst_output(skb);\n ......\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-xesyo0z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-xesyo0z",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 ip_local_out =\u003e __ip_local_out =\u003e nf_hook 会执行 netfilter 过滤。如果你使用 iptables 配置了一些规则，那么这里将检测是否命中规则。​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "如果你设置了非常复杂的 netfilter 规则，在这个函数这里将会导致你的进程 CPU 开销会极大增加"
				},
				{
					"Type": "NodeText",
					"Data": "​。"
				}
			]
		},
		{
			"ID": "20241107163840-kyik03f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-kyik03f",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "还是不多展开说，继续只聊和发送有关的过程 dst_output。"
				}
			]
		},
		{
			"ID": "20241107163840-5phfdd0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-5phfdd0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: include/net/dst.h\nstatic inline int dst_output(struct sk_buff *skb)\n{\n return skb_dst(skb)-\u003eoutput(skb);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-d9m3c34",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-d9m3c34",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此函数找到到这个 skb 的路由表（dst 条目） ，然后调用路由表的 output 方法。这又是一个函数指针，指向的是 ip_output 方法。"
				}
			]
		},
		{
			"ID": "20241107163840-v9bqjd5",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-v9bqjd5",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/ip_output.c\nint ip_output(struct sk_buff *skb)\n{\n //统计\n ..... //再次交给 netfilter，完毕后回调 ip_finish_output\n return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb, NULL, dev,\n    ip_finish_output,\n    !(IPCB(skb)-\u003eflags \u0026 IPSKB_REROUTED));\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-mdpyvee",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-mdpyvee",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 ip_output 中进行一些简单的，统计工作，再次执行 netfilter 过滤。过滤通过之后回调 ip_finish_output。"
				}
			]
		},
		{
			"ID": "20241107163840-bjgq5hn",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-bjgq5hn",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/ip_output.c\nstatic int ip_finish_output(struct sk_buff *skb)\n{\n //大于 mtu 的话就要进行分片了\n if (skb-\u003elen \u003e ip_skb_dst_mtu(skb) \u0026\u0026 !skb_is_gso(skb))\n  return ip_fragment(skb, ip_finish_output2);\n else\n  return ip_finish_output2(skb);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-me4szn7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-me4szn7",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 ip_finish_output 中我们看到，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "如果数据大于 MTU 的话，是会执行分片的。"
				}
			]
		},
		{
			"ID": "20241107163840-wd8jreq",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20241107163840-wd8jreq",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20241107163840-y61rujr",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20241107163840-y61rujr",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "实际 MTU 大小确定依赖 MTU 发现，以太网帧为 1500 字节。之前 QQ 团队在早期的时候，会尽量控制自己数据包尺寸小于 MTU，通过这种方式来优化网络性能。因为分片会带来两个问题：1、需要进行额外的切分处理，有额外性能开销。2、只要一个分片丢失，整个包都得重传。所以避免分片既杜绝了分片开销，也大大降低了重传率。"
						}
					]
				}
			]
		},
		{
			"ID": "20241107163840-4vkl53w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-4vkl53w",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 ip_finish_output2 中，终于发送过程会进入到下一层，邻居子系统中。"
				}
			]
		},
		{
			"ID": "20241107163840-9vgl519",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-9vgl519",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/ipv4/ip_output.c\nstatic inline int ip_finish_output2(struct sk_buff *skb)\n{\n //根据下一跳 IP 地址查找邻居项，找不到就创建一个\n nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-\u003edaddr);  \n neigh = __ipv4_neigh_lookup_noref(dev, nexthop);\n if (unlikely(!neigh))\n  neigh = __neigh_create(\u0026arp_tbl, \u0026nexthop, dev, false); //继续向下层传递\n int res = dst_neigh_output(dst, neigh, skb);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-tc3e9l6",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-tc3e9l6",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.4 邻居子系统"
				}
			]
		},
		{
			"ID": "20241107163840-t2p6rck",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-t2p6rck",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是对网络层提供一个封装，让网络层不必关心下层的地址信息，让下层来决定发送到哪个 MAC 地址。"
				}
			]
		},
		{
			"ID": "20241107163840-dk2kftg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-dk2kftg",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而且这个邻居子系统并不位于协议栈 net/ipv4/ 目录内，而是位于 net/core/neighbour.c。因为无论是对于 IPv4 还是 IPv6 ，都需要使用该模块。"
				}
			]
		},
		{
			"ID": "20241107163840-pks98hp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-pks98hp",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-cvt5ub3"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-r92t21i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-r92t21i",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在邻居子系统里主要是查找或者创建邻居项，在创造邻居项的时候，有可能会发出实际的 arp 请求。然后封装一下 MAC 头，将发送过程再传递到更下层的网络设备子系统。大致流程如图。"
				}
			]
		},
		{
			"ID": "20241107163840-iktul35",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-iktul35",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-ibd7xf1"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-n8ufehr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-n8ufehr",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "理解了大致流程，我们再回头看源码。在上面小节 ip_finish_output2 源码中调用了 __ipv4_neigh_lookup_noref。它是在 arp 缓存中进行查找，其第二个参数传入的是路由下一跳 IP 信息。"
				}
			]
		},
		{
			"ID": "20241107163840-b8ybr49",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-b8ybr49",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: include/net/arp.h\nextern struct neigh_table arp_tbl;\nstatic inline struct neighbour *__ipv4_neigh_lookup_noref(\n struct net_device *dev, u32 key)\n{\n struct neigh_hash_table *nht = rcu_dereference_bh(arp_tbl.nht); //计算 hash 值，加速查找\n hash_val = arp_hashfn(......);\n for (n = rcu_dereference_bh(nht-\u003ehash_buckets[hash_val]);\n   n != NULL;\n   n = rcu_dereference_bh(n-\u003enext)) {\n  if (n-\u003edev == dev \u0026\u0026 *(u32 *)n-\u003eprimary_key == key)\n   return n;\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-d48k6ls",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-d48k6ls",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果查找不到，则调用 __neigh_create 创建一个邻居。"
				}
			]
		},
		{
			"ID": "20241107163840-2cgp7s9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-2cgp7s9",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/neighbour.c\nstruct neighbour *__neigh_create(......)\n{\n //申请邻居表项\n struct neighbour *n1, *rc, *n = neigh_alloc(tbl, dev); //构造赋值\n memcpy(n-\u003eprimary_key, pkey, key_len);\n n-\u003edev = dev;\n n-\u003eparms-\u003eneigh_setup(n); //最后添加到邻居 hashtable 中\n rcu_assign_pointer(nht-\u003ehash_buckets[hash_val], n);\n ......\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-9dea4ha",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-9dea4ha",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有了邻居项以后，此时仍然还不具备发送 IP 报文的能力，因为目的 MAC 地址还未获取。调用 dst_neigh_output 继续传递 skb。"
				}
			]
		},
		{
			"ID": "20241107163840-bj1n2oi",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-bj1n2oi",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: include/net/dst.h\nstatic inline int dst_neigh_output(struct dst_entry *dst, \n     struct neighbour *n, struct sk_buff *skb)\n{\n ......\n return n-\u003eoutput(n, skb);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-l6n59jd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-l6n59jd",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "调用 output，实际指向的是 neigh_resolve_output。在这个函数内部有可能会发出 arp 网络请求。"
				}
			]
		},
		{
			"ID": "20241107163840-q32kahm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-q32kahm",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/neighbour.c\nint neigh_resolve_output(){ //注意：这里可能会触发 arp 请求\n if (!neigh_event_send(neigh, skb)) {  //neigh-\u003eha 是 MAC 地址\n  dev_hard_header(skb, dev, ntohs(skb-\u003eprotocol),\n           neigh-\u003eha, NULL, skb-\u003elen);\n  //发送\n  dev_queue_xmit(skb);\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-e24wi9j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-e24wi9j",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当获取到硬件 MAC 地址以后，就可以封装 skb 的 MAC 头了。最后调用 dev_queue_xmit 将 skb 传递给 Linux 网络设备子系统。"
				}
			]
		},
		{
			"ID": "20241107163840-us0n4pq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-us0n4pq",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.5 网络设备子系统"
				}
			]
		},
		{
			"ID": "20241107163840-p2qrh9g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-p2qrh9g",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-axgw2q4"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-857xily",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-857xily",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "邻居子系统通过 dev_queue_xmit 进入到网络设备子系统中来。"
				}
			]
		},
		{
			"ID": "20241107163840-byq3ed3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-byq3ed3",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/dev.c \nint dev_queue_xmit(struct sk_buff *skb)\n{\n //选择发送队列\n txq = netdev_pick_tx(dev, skb); //获取与此队列关联的排队规则\n q = rcu_dereference_bh(txq-\u003eqdisc); //如果有队列，则调用__dev_xmit_skb 继续处理数据\n if (q-\u003eenqueue) {\n  rc = __dev_xmit_skb(skb, q, dev, txq);\n  goto out;\n } //没有队列的是回环设备和隧道设备\n ......\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-y174e5k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-y174e5k",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "开篇第二节网卡启动准备里我们说过，网卡是有多个发送队列的（尤其是现在的网卡）。上面对 netdev_pick_tx 函数的调用就是选择一个队列进行发送。"
				}
			]
		},
		{
			"ID": "20241107163840-izn7o39",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-izn7o39",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "netdev_pick_tx 发送队列的选择受 XPS 等配置的影响，而且还有缓存，也是一套小复杂的逻辑。这里我们只关注两个逻辑，首先会获取用户的 XPS 配置，否则就自动计算了。代码见 netdev_pick_tx =\u003e __netdev_pick_tx。"
				}
			]
		},
		{
			"ID": "20241107163840-u521uds",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-u521uds",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/flow_dissector.c\nu16 __netdev_pick_tx(struct net_device *dev, struct sk_buff *skb)\n{\n //获取 XPS 配置\n int new_index = get_xps_queue(dev, skb); //自动计算队列\n if (new_index \u003c 0)\n  new_index = skb_tx_hash(dev, skb);}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-66pffm3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-66pffm3",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后获取与此队列关联的 qdisc。在 linux 上通过 tc 命令可以看到 qdisc 类型，例如对于我的某台多队列网卡机器上是 mq disc。"
				}
			]
		},
		{
			"ID": "20241107163840-dr6la9o",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-dr6la9o",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#tc qdisc\nqdisc mq 0: dev eth0 root\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-7ja1qav",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-7ja1qav",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大部分的设备都有队列（回环设备和隧道设备除外），所以现在我们进入到 __dev_xmit_skb。"
				}
			]
		},
		{
			"ID": "20241107163840-t41mnfw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-t41mnfw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/dev.c\nstatic inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,\n     struct net_device *dev,\n     struct netdev_queue *txq)\n{\n //1.如果可以绕开排队系统\n if ((q-\u003eflags \u0026 TCQ_F_CAN_BYPASS) \u0026\u0026 !qdisc_qlen(q) \u0026\u0026\n     qdisc_run_begin(q)) {\n  ......\n } //2.正常排队\n else {  //入队\n  q-\u003eenqueue(skb, q)  //开始发送\n  __qdisc_run(q);\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-qgan4xh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-qgan4xh",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上述代码中分两种情况，1 是可以 bypass（绕过）排队系统的，另外一种是正常排队。我们只看第二种情况。"
				}
			]
		},
		{
			"ID": "20241107163840-tr4jxw9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-tr4jxw9",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "先调用 q-\u003eenqueue 把 skb 添加到队列里。然后调用 __qdisc_run 开始发送。"
				}
			]
		},
		{
			"ID": "20241107163840-erroksy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-erroksy",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/sched/sch_generic.c\nvoid __qdisc_run(struct Qdisc *q)\n{\n int quota = weight_p; //循环从队列取出一个 skb 并发送\n while (qdisc_restart(q)) {    // 如果发生下面情况之一，则延后处理：\n  // 1. quota 用尽\n  // 2. 其他进程需要 CPU\n  if (--quota \u003c= 0 || need_resched()) {\n   //将触发一次 NET_TX_SOFTIRQ 类型 softirq\n   __netif_schedule(q);\n   break;\n  }\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-sjkayyv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-sjkayyv",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在上述代码中，我们看到 while 循环不断地从队列中取出 skb 并进行发送。注意，这个时候其实都占用的是用户进程的系统态时间(sy)。只有当 quota 用尽或者其它进程需要 CPU 的时候才触发软中断进行发送。"
				}
			]
		},
		{
			"ID": "20241107163840-qlp0e73",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-qlp0e73",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "所以这就是为什么一般服务器上查看 /proc/softirqs，一般 NET_RX 都要比 NET_TX 大的多的第二个原因"
				},
				{
					"Type": "NodeText",
					"Data": "​。对于读来说，都是要经过 NET_RX 软中断，而对于发送来说，只有系统态配额用尽才让软中断上。"
				}
			]
		},
		{
			"ID": "20241107163840-8sol3mp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-8sol3mp",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们来把精力在放到 qdisc_restart 上，继续看发送过程。"
				}
			]
		},
		{
			"ID": "20241107163840-77xa95c",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-77xa95c",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "static inline int qdisc_restart(struct Qdisc *q)\n{\n //从 qdisc 中取出要发送的 skb\n skb = dequeue_skb(q);\n ... return sch_direct_xmit(skb, q, dev, txq, root_lock);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-9ionkjf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-9ionkjf",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "qdisc_restart 从队列中取出一个 skb，并调用 sch_direct_xmit 继续发送。"
				}
			]
		},
		{
			"ID": "20241107163840-17233wy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-17233wy",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/sched/sch_generic.c\nint sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,\n   struct net_device *dev, struct netdev_queue *txq,\n   spinlock_t *root_lock)\n{\n //调用驱动程序来发送数据\n ret = dev_hard_start_xmit(skb, dev, txq);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-9auhg2z",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-9auhg2z",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.6 软中断调度"
				}
			]
		},
		{
			"ID": "20241107163840-23f0gz9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-23f0gz9",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 4.5 咱们看到了如果系统态 CPU 发送网络包不够用的时候，会调用 __netif_schedule 触发一个软中断。该函数会进入到 __netif_reschedule，由它来实际发出 NET_TX_SOFTIRQ 类型软中断。"
				}
			]
		},
		{
			"ID": "20241107163840-luz5str",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-luz5str",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "软中断是由内核线程来运行的，该线程会进入到 net_tx_action 函数，在该函数中能获取到发送队列，并也最终调用到驱动程序里的入口函数 dev_hard_start_xmit。"
				}
			]
		},
		{
			"ID": "20241107163840-setmgtj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-setmgtj",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-ywzd96g"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-7su2gxw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-7su2gxw",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/dev.c\nstatic inline void __netif_reschedule(struct Qdisc *q)\n{\n sd = \u0026__get_cpu_var(softnet_data);\n q-\u003enext_sched = NULL;\n *sd-\u003eoutput_queue_tailp = q;\n sd-\u003eoutput_queue_tailp = \u0026q-\u003enext_sched; ......\n raise_softirq_irqoff(NET_TX_SOFTIRQ);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-xpd9ks7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-xpd9ks7",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在该函数里在软中断能访问到的 softnet_data 里设置了要发送的数据队列，添加到了 output_queue 里了。紧接着触发了 NET_TX_SOFTIRQ 类型的软中断。（T 代表 transmit 传输）"
				}
			]
		},
		{
			"ID": "20241107163840-6uf88e3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-6uf88e3",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "软中断的入口代码我这里也不详细扒了，感兴趣的同学参考"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026mid=2247484058\u0026idx=1\u0026sn=a2621bc27c74b313528eefbc81ee8c0f\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "《图解Linux网络包接收过程》"
				},
				{
					"Type": "NodeText",
					"Data": "一文中的 3.2 小节 - ksoftirqd内核线程处理软中断。"
				}
			]
		},
		{
			"ID": "20241107163840-6t3adj0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-6t3adj0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们直接从 NET_TX_SOFTIRQ softirq 注册的回调函数 net_tx_action讲起。用户态进程触发完软中断之后，会有一个软中断内核线程会执行到 net_tx_action。"
				}
			]
		},
		{
			"ID": "20241107163840-fo41sup",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-fo41sup",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "牢记，这以后发送数据消耗的 CPU 就都显示在 si 这里了，不会消耗用户进程的系统时间了"
				},
				{
					"Type": "NodeText",
					"Data": "​。"
				}
			]
		},
		{
			"ID": "20241107163840-mhzkhca",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-mhzkhca",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/dev.c\nstatic void net_tx_action(struct softirq_action *h)\n{\n //通过 softnet_data 获取发送队列\n struct softnet_data *sd = \u0026__get_cpu_var(softnet_data); // 如果 output queue 上有 qdisc\n if (sd-\u003eoutput_queue) {  // 将 head 指向第一个 qdisc\n  head = sd-\u003eoutput_queue;  //遍历 qdsics 列表\n  while (head) {\n   struct Qdisc *q = head;\n   head = head-\u003enext_sched;   //发送数据\n   qdisc_run(q);\n  }\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-znyevqe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-znyevqe",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "软中断这里会获取 softnet_data。前面我们看到进程内核态在调用 __netif_reschedule 的时候把发送队列写到 softnet_data 的 output_queue 里了。软中断循环遍历 sd-\u003eoutput_queue 发送数据帧。"
				}
			]
		},
		{
			"ID": "20241107163840-q04rao8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-q04rao8",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "来看 qdisc_run，它和进程用户态一样，也会调用到 __qdisc_run。"
				}
			]
		},
		{
			"ID": "20241107163840-nhagg37",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-nhagg37",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: include/net/pkt_sched.h\nstatic inline void qdisc_run(struct Qdisc *q)\n{\n if (qdisc_run_begin(q))\n  __qdisc_run(q);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-cvwx149",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cvwx149",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后一样就是进入 qdisc_restart =\u003e sch_direct_xmit，直到驱动程序函数 dev_hard_start_xmit。"
				}
			]
		},
		{
			"ID": "20241107163840-haya9zu",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-haya9zu",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.7 igb 网卡驱动发送"
				}
			]
		},
		{
			"ID": "20241107163840-wwxecor",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-wwxecor",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们前面看到，无论是对于用户进程的内核态，还是对于软中断上下文，都会调用到网络设备子系统中的 dev_hard_start_xmit 函数。在这个函数中，会调用到驱动里的发送函数 igb_xmit_frame。"
				}
			]
		},
		{
			"ID": "20241107163840-w3ggpu5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-w3ggpu5",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在驱动函数里，将 skb 会挂到 RingBuffer上，驱动调用完毕后，数据包将真正从网卡发送出去。"
				}
			]
		},
		{
			"ID": "20241107163840-lbi6ycn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-lbi6ycn",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-fh6urlg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-sai1fqj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-sai1fqj",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们来看看实际的源码："
				}
			]
		},
		{
			"ID": "20241107163840-y4hbbsj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-y4hbbsj",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: net/core/dev.c\nint dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,\n   struct netdev_queue *txq)\n{\n //获取设备的回调函数集合 ops\n const struct net_device_ops *ops = dev-\u003enetdev_ops; //获取设备支持的功能列表\n features = netif_skb_features(skb); //调用驱动的 ops 里面的发送回调函数 ndo_start_xmit 将数据包传给网卡设备\n skb_len = skb-\u003elen;\n rc = ops-\u003endo_start_xmit(skb, dev);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-d4jqabp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-d4jqabp",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中 ndo_start_xmit 是网卡驱动要实现的一个函数，是在 net_device_ops 中定义的。"
				}
			]
		},
		{
			"ID": "20241107163840-gjcpmq1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-gjcpmq1",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: include/linux/netdevice.h\nstruct net_device_ops {\n netdev_tx_t  (*ndo_start_xmit) (struct sk_buff *skb,\n         struct net_device *dev);}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-9106f5q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-9106f5q",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 igb 网卡驱动源码中，我们找到了。"
				}
			]
		},
		{
			"ID": "20241107163840-n4zmyud",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-n4zmyud",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic const struct net_device_ops igb_netdev_ops = {\n .ndo_open  = igb_open,\n .ndo_stop  = igb_close,\n .ndo_start_xmit  = igb_xmit_frame, \n ...\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-hei9fgg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-hei9fgg",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "也就是说，对于网络设备层定义的 ndo_start_xmit， igb 的实现函数是 igb_xmit_frame。这个函数是在网卡驱动初始化的时候被赋值的。具体初始化过程参见"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026mid=2247484058\u0026idx=1\u0026sn=a2621bc27c74b313528eefbc81ee8c0f\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "《图解Linux网络包接收过程》"
				},
				{
					"Type": "NodeText",
					"Data": "一文中的 2.4 节，网卡驱动初始化。"
				}
			]
		},
		{
			"ID": "20241107163840-7902wja",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-7902wja",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以在上面网络设备层调用 ops-\u003endo_start_xmit 的时候，会实际上进入 igb_xmit_frame 这个函数中。我们进入这个函数来看看驱动程序是如何工作的。"
				}
			]
		},
		{
			"ID": "20241107163840-ywzdghe",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-ywzdghe",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic netdev_tx_t igb_xmit_frame(struct sk_buff *skb,\n      struct net_device *netdev)\n{\n ......\n return igb_xmit_frame_ring(skb, igb_tx_queue_mapping(adapter, skb));\n}netdev_tx_t igb_xmit_frame_ring(struct sk_buff *skb,\n    struct igb_ring *tx_ring)\n{\n //获取TX Queue 中下一个可用缓冲区信息\n first = \u0026tx_ring-\u003etx_buffer_info[tx_ring-\u003enext_to_use];\n first-\u003eskb = skb;\n first-\u003ebytecount = skb-\u003elen;\n first-\u003egso_segs = 1; //igb_tx_map 函数准备给设备发送的数据。\n igb_tx_map(tx_ring, first, hdr_len);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-43uwyip",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-43uwyip",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这里从网卡的发送队列的 RingBuffer 中取下来一个元素，并将 skb 挂到元素上。"
				}
			]
		},
		{
			"ID": "20241107163840-n657tst",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-n657tst",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-p9s5sgs"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-gxkaaqf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-gxkaaqf",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "igb_tx_map 函数处理将 skb 数据映射到网卡可访问的内存 DMA 区域。"
				}
			]
		},
		{
			"ID": "20241107163840-l7cgg5d",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-l7cgg5d",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic void igb_tx_map(struct igb_ring *tx_ring,\n      struct igb_tx_buffer *first,\n      const u8 hdr_len)\n{\n //获取下一个可用描述符指针\n tx_desc = IGB_TX_DESC(tx_ring, i); //为 skb-\u003edata 构造内存映射，以允许设备通过 DMA 从 RAM 中读取数据\n dma = dma_map_single(tx_ring-\u003edev, skb-\u003edata, size, DMA_TO_DEVICE); //遍历该数据包的所有分片,为 skb 的每个分片生成有效映射\n for (frag = \u0026skb_shinfo(skb)-\u003efrags[0];; frag++) {  tx_desc-\u003eread.buffer_addr = cpu_to_le64(dma);\n  tx_desc-\u003eread.cmd_type_len = ...;\n  tx_desc-\u003eread.olinfo_status = 0;\n } //设置最后一个descriptor\n cmd_type |= size | IGB_TXD_DCMD;\n tx_desc-\u003eread.cmd_type_len = cpu_to_le32(cmd_type); /* Force memory writes to complete before letting h/w know there\n  * are new descriptors to fetch\n  */\n wmb();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-yhhj4d6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-yhhj4d6",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当所有需要的描述符都已建好，且 skb 的所有数据都映射到 DMA 地址后，驱动就会进入到它的最后一步，触发真实的发送。"
				}
			]
		},
		{
			"ID": "20241107163840-lu6jay8",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107163840-lu6jay8",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.8 发送完成硬中断"
				}
			]
		},
		{
			"ID": "20241107163840-tfqblsa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-tfqblsa",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当数据发送完成以后，其实工作并没有结束。因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存。"
				}
			]
		},
		{
			"ID": "20241107163840-lmfgva0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-lmfgva0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026mid=2247484058\u0026idx=1\u0026sn=a2621bc27c74b313528eefbc81ee8c0f\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "《图解Linux网络包接收过程》"
				},
				{
					"Type": "NodeText",
					"Data": " 一文中的 3.1 和 3.2 小节，我们详细讲述过硬中断和软中断的处理过程。"
				}
			]
		},
		{
			"ID": "20241107163840-0t079z2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-0t079z2",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在发送完成硬中断里，会执行 RingBuffer 内存的清理工作，如图。"
				}
			]
		},
		{
			"ID": "20241107163840-hppyv5g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-hppyv5g",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-zvf2dwm"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-x8o5me0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-x8o5me0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再回头看一下硬中断触发软中断的源码。"
				}
			]
		},
		{
			"ID": "20241107163840-vgfjydf",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-vgfjydf",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic inline void ____napi_schedule(...){\n list_add_tail(\u0026napi-\u003epoll_list, \u0026sd-\u003epoll_list);\n __raise_softirq_irqoff(NET_RX_SOFTIRQ);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-qv1bjq4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-qv1bjq4",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里有个很有意思的细节，无论硬中断是因为是有数据要接收，还是说发送完成通知，​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "从硬中断触发的软中断都是 NET_RX_SOFTIRQ"
				},
				{
					"Type": "NodeText",
					"Data": "​。这个我们在第一节说过了，这是软中断统计中 RX 要高于 TX 的一个原因。"
				}
			]
		},
		{
			"ID": "20241107163840-07tq5ax",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-07tq5ax",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "好我们接着进入软中断的回调函数 igb_poll。在这个函数里，我们注意到有一行 igb_clean_tx_irq，参见源码："
				}
			]
		},
		{
			"ID": "20241107163840-alpfyp7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-alpfyp7",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic int igb_poll(struct napi_struct *napi, int budget)\n{\n //performs the transmit completion operations\n if (q_vector-\u003etx.ring)\n  clean_complete = igb_clean_tx_irq(q_vector);\n ...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-zjdqncj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-zjdqncj",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们来看看当传输完成的时候，igb_clean_tx_irq 都干啥了。"
				}
			]
		},
		{
			"ID": "20241107163840-k2ccryv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20241107163840-k2ccryv",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//file: drivers/net/ethernet/intel/igb/igb_main.c\nstatic bool igb_clean_tx_irq(struct igb_q_vector *q_vector)\n{\n //free the skb\n dev_kfree_skb_any(tx_buffer-\u003eskb); //clear tx_buffer data\n tx_buffer-\u003eskb = NULL;\n dma_unmap_len_set(tx_buffer, len, 0); // clear last DMA location and unmap remaining buffers */\n while (tx_desc != eop_desc) {\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20241107163840-el3tvlb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-el3tvlb",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "无非就是清理了 skb，解除了 DMA 映射等等。到了这一步，传输才算是基本完成了。"
				}
			]
		},
		{
			"ID": "20241107163840-2z1ddwd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-2z1ddwd",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为啥我说是基本完成，而不是全部完成了呢？因为传输层需要保证可靠性，所以 skb 其实还没有删除。它得等收到对方的 ACK 之后才会真正删除，那个时候才算是彻底的发送完毕。"
				}
			]
		},
		{
			"ID": "20241107163840-s9fhqb4",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107163840-s9fhqb4",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最后"
				}
			]
		},
		{
			"ID": "20241107163840-p6au5h9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-p6au5h9",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用一张图总结一下整个发送过程"
				}
			]
		},
		{
			"ID": "20241107163840-07wpdh6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-07wpdh6",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-alyh2ae"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-q4i4clz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-q4i4clz",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "了解了整个发送过程以后，我们回头再来回顾开篇提到的几个问题。"
				}
			]
		},
		{
			"ID": "20241107163840-hrflw3t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-hrflw3t",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "1.我们在监控内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？"
				}
			]
		},
		{
			"ID": "20241107163840-atlowm9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-atlowm9",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在网络包的发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的事情都干了。只有当内核态进程被切走前才会发起软中断。发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。"
				}
			]
		},
		{
			"ID": "20241107163840-6zbodo1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-6zbodo1",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "只有一少部分情况下才会触发软中断（NET_TX 类型），由软中断 ksoftirqd 内核进程来发送。"
				}
			]
		},
		{
			"ID": "20241107163840-xnfdz34",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-xnfdz34",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以，在监控网络 IO 对服务器造成的 CPU 开销的时候，不能仅仅只看 si，而是应该把 si、sy 都考虑进来。"
				}
			]
		},
		{
			"ID": "20241107163840-463yjji",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-463yjji",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "2. 在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？"
				}
			]
		},
		{
			"ID": "20241107163840-eiu3lrl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-eiu3lrl",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "之前我认为 NET_RX 是读取，NET_TX 是传输。对于一个既收取用户请求，又给用户返回的 Server 来说。这两块的数字应该差不多才对，至少不会有数量级的差异。但事实上，飞哥手头的一台服务器是这样的："
				}
			]
		},
		{
			"ID": "20241107163840-ebqenle",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-ebqenle",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-ty971wr"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-cbtar3i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-cbtar3i",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "经过今天的源码分析，发现这个问题的原因有两个。"
				}
			]
		},
		{
			"ID": "20241107163840-iq1ysuh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-iq1ysuh",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第一个原因是当数据发送完成以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收，还是对于发送完毕，触发的软中断都是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。"
				}
			]
		},
		{
			"ID": "20241107163840-2l00qu0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-2l00qu0",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第二个原因是对于读来说，都是要经过 NET_RX 软中断的，都走 ksoftirqd 内核进程。而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出 NET_TX，让软中断上。"
				}
			]
		},
		{
			"ID": "20241107163840-v9pg4zk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-v9pg4zk",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "综上两个原因，那么在机器上查看 NET_RX 比 NET_TX 大的多就不难理解了。"
				}
			]
		},
		{
			"ID": "20241107163840-wxypu5u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-wxypu5u",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "3.发送网络数据的时候都涉及到哪些内存拷贝操作？"
				}
			]
		},
		{
			"ID": "20241107163840-75utzc2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-75utzc2",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里的内存拷贝，我们只特指待发送数据的内存拷贝。"
				}
			]
		},
		{
			"ID": "20241107163840-8rr34rs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-8rr34rs",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第一次拷贝操作是内核申请完 skb 之后，这时候会将用户传递进来的 buffer 里的数据内容都拷贝到 skb 中。如果要发送的数据量比较大的话，这个拷贝操作开销还是不小的。"
				}
			]
		},
		{
			"ID": "20241107163840-kk0rgfj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-kk0rgfj",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第二次拷贝操作是从传输层进入网络层的时候，每一个 skb 都会被克隆一个新的副本出来。网络层以及下面的驱动、软中断等组件在发送完成的时候会将这个副本删除。传输层保存着原始的 skb，在当网络对方没有 ack 的时候，还可以重新发送，以实现 TCP 中要求的可靠传输。"
				}
			]
		},
		{
			"ID": "20241107163840-q7gksmm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-q7gksmm",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第三次拷贝不是必须的，只有当 IP 层发现 skb 大于 MTU 时才需要进行。会再申请额外的 skb，并将原来的 skb 拷贝为多个小的 skb。"
				}
			]
		},
		{
			"ID": "20241107163840-z6ib8i7",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20241107163840-z6ib8i7",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20241107163840-d0fnao2",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20241107163840-d0fnao2",
						"updated": "20241107163840"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "这里插入个题外话，大家在网络性能优化中经常听到的零拷贝，我觉得这有点点夸张的成分。TCP 为了保证可靠性，第二次的拷贝根本就没法省。如果包再大于 MTU 的话，分片时的拷贝同样也避免不了。"
						}
					]
				}
			]
		},
		{
			"ID": "20241107163840-wvr9w5a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-wvr9w5a",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "看到这里，相信内核发送数据包对于你来说，已经不再是一个完全不懂的黑盒了。本文哪怕你只看懂十分之一，你也已经掌握了这个黑盒的打开方式。这在你将来优化网络性能时你就会知道从哪儿下手了。"
				}
			]
		},
		{
			"ID": "20241107163840-iv074n1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-iv074n1",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "还愣着干啥，赶紧帮飞哥"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "赞、再看、转发"
				},
				{
					"Type": "NodeText",
					"Data": "三连走起！"
				}
			]
		},
		{
			"ID": "20241107163840-vrmndhx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-vrmndhx",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Github:"
				},
				{
					"Type": "NodeText",
					"Data": "https://github.com/yanfeizhang/coder-kung-fu"
				}
			]
		},
		{
			"ID": "20241107163840-z4af07y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-z4af07y",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-30spov7"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-nt45lsl",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20241107163840-nt45lsl",
				"updated": "20241107163840"
			}
		},
		{
			"ID": "20241107163840-tdgjtmx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-tdgjtmx",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由于本文比较长，在公众号上看起来确实是有点费劲。所以飞哥搞了个 pdf，带目录结构，可快速跳转，看起来更方便。"
				}
			]
		},
		{
			"ID": "20241107163840-fe6ji3k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-fe6ji3k",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-rbfhpmn"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107163840-dhpd92q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-dhpd92q",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不过获取方式仍然有点小门槛："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "带任意推荐语转发本文到朋友圈，加飞哥微信知会"
				},
				{
					"Type": "NodeText",
					"Data": "即可。"
				}
			]
		},
		{
			"ID": "20241107163840-e0km8eu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107163840-e0km8eu",
				"updated": "20241107163840"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107163840-034xdk8"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		}
	]
}