{
	"ID": "20241107165014-q53ripg",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20241107165014-q53ripg",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20241107165014-de817wy\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20241107165014-3revqf6\u0026quot;,\u0026quot;scrollTop\u0026quot;:136,\u0026quot;focusId\u0026quot;:\u0026quot;20241107165014-de817wy\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "Linux 网络收发包路径简介",
		"updated": "20241107165014"
	},
	"Children": [
		{
			"ID": "20241107165014-de817wy",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20241107165014-de817wy",
				"updated": "20241107165014"
			}
		},
		{
			"ID": "20241107165014-8y5dlef",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20241107165014-8y5dlef",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"ID": "20241107165014-guvu6vv",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107165014-guvu6vv",
						"updated": "20241107165014"
					},
					"Children": [
						{
							"ID": "20241107165014-q4mzxld",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107165014-q4mzxld",
								"updated": "20241107165014"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://mp.weixin.qq.com/s?__biz=MzI0OTIzOTMzMA==\u0026mid=2247488059\u0026idx=1\u0026sn=4062df3f2f24d9d9ef1422629cb8e793\u0026chksm=e995d076dee259604b343e944ea0c76ef9f90ff52ce669e629d3168ff2be8f11b7543e6325ff\u0026scene=142\u0026scene=21#wechat_redirect",
									"TextMarkTextContent": "https://mp.weixin.qq.com/s?__biz=MzI0OTIzOTMzMA==\u0026amp;mid=2247488059\u0026amp;idx=1\u0026amp;sn=4062df3f2f24d9d9ef1422629cb8e793\u0026amp;chksm=e995d076dee259604b343e944ea0c76ef9f90ff52ce669e629d3168ff2be8f11b7543e6325ff\u0026amp;scene=142\u0026amp;scene=21#wechat_redirect - 微信公众平台"
								}
							]
						}
					]
				},
				{
					"ID": "20241107165014-xpsx237",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107165014-xpsx237",
						"updated": "20241107165014"
					},
					"Children": [
						{
							"ID": "20241107165014-rrfkatm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107165014-rrfkatm",
								"updated": "20241107165014"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为了最终写作《网络性能探案惊奇：三步揪出 CPU 软中断一直处于 100%的元凶》，今天先来介绍一下 Linux 网络收发包路径，并重点讲解收包路径。"
								}
							]
						}
					]
				},
				{
					"ID": "20241107165014-c5tgcgg",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20241107165014-c5tgcgg",
						"updated": "20241107165014"
					},
					"Children": [
						{
							"ID": "20241107165014-o9mncqz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107165014-o9mncqz",
								"updated": "20241107165014"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "2024-11-07 16:50:14"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20241107165014-9g22qm0",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20241107165014-9g22qm0",
				"updated": "20241107165014"
			}
		},
		{
			"ID": "20241107165014-88h527j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-88h527j",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了最终写作《​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "网络性能探案惊奇：三步揪出 CPU 软中断一直处于 100%的元凶"
				},
				{
					"Type": "NodeText",
					"Data": "​》，今天先来介绍一下 Linux 网络收发包路径，并重点讲解收包路径。"
				}
			]
		},
		{
			"ID": "20241107165014-bkqw3gg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-bkqw3gg",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "网上已经有很多文章，笔者也找到了一篇论文《​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "The Path of a Packet Through the Linux Kernel"
				},
				{
					"Type": "NodeText",
					"Data": "​》，译文附在文章末尾。"
				}
			]
		},
		{
			"ID": "20241107165014-4i0yrof",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-4i0yrof",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "相关文章推荐"
				}
			]
		},
		{
			"ID": "20241107165014-vnbxmvq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-vnbxmvq",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "原力注入"
				},
				{
					"Type": "NodeText",
					"Data": "​："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a strong",
					"TextMarkAHref": "http://mp.weixin.qq.com/s?__biz=MzI0OTIzOTMzMA==\u0026mid=2247486006\u0026idx=1\u0026sn=4ab7228b6e2b78033e0ee8cd1602b780\u0026chksm=e995c87bdee2416dbf8ad774eeae368a57ac7c9e341eca06a4757cdad2580c0797cd6e5f9eeb\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "性能分析实战篇 - Linux 网络性能优化指南"
				},
				{
					"Type": "NodeText",
					"Data": "，以及"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a strong",
					"TextMarkAHref": "http://mp.weixin.qq.com/s?__biz=MzI0OTIzOTMzMA==\u0026mid=2247488040\u0026idx=1\u0026sn=16656381f0beee828e9eb4996ded6a40\u0026chksm=e995d065dee2597333d88f643f9f55647c6a9669ee50bf37ea01b8be39b6d97468e0eb912b85\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "了解 Linux 中的中断、软中断和 Softnet 之原理篇"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20241107165014-jwzmyl2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-jwzmyl2",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "ArthurChiao（"
				},
				{
					"Type": "NodeText",
					"Data": "赵亚楠​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "）"
				},
				{
					"Type": "NodeText",
					"Data": "​：​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "Linux 网络栈接收数据（RX）：原理及内核实现"
				},
				{
					"Type": "NodeText",
					"Data": "​（https://arthurchiao.art/blog/linux-net-stack-zh/）。"
				}
			]
		},
		{
			"ID": "20241107165014-whgzsfb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-whgzsfb",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "张彦飞"
				},
				{
					"Type": "NodeText",
					"Data": "​："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "http://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026mid=2247484058\u0026idx=1\u0026sn=a2621bc27c74b313528eefbc81ee8c0f\u0026chksm=a6e303a191948ab7d06e574661a905ddb1fae4a5d9eb1d2be9f1c44491c19a82d95957a0ffb6\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "图解Linux网络包接收过程"
				},
				{
					"Type": "NodeText",
					"Data": "，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "http://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==\u0026mid=2247485146\u0026idx=1\u0026sn=e5bfc79ba915df1f6a8b32b87ef0ef78\u0026chksm=a6e307e191948ef748dc73a4b9a862a22ce1db806a486afce57475d4331d905827d6ca161711\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "25 张图以及一万字，拆解 Linux 网络包发送过程"
				},
				{
					"Type": "NodeText",
					"Data": "。公众号的内容有点落后了，张彦飞的《​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em",
					"TextMarkTextContent": "深入理解 Linux 网络"
				},
				{
					"Type": "NodeText",
					"Data": "​》做了更新。"
				}
			]
		},
		{
			"ID": "20241107165014-spk9t5r",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-spk9t5r",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "High Level 总结（不涉及具体代码）"
				}
			]
		},
		{
			"ID": "20241107165014-6n4vll2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-6n4vll2",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165013-8td3l0x"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-9yldir8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-9yldir8",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图一：整体了解：Network stack（来源不可考）"
				}
			]
		},
		{
			"ID": "20241107165014-8yxpfzb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-8yxpfzb",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165013-bbccaqc"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-5dedlok",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-5dedlok",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图二：TCP 数据包的发送路径（摘自：The Path of a Packet Through the Linux Kernel（论文））"
				}
			]
		},
		{
			"ID": "20241107165014-dxtuhw7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-dxtuhw7",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165013-v4cds4f"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-896vr6f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-896vr6f",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图三：TCP 数据包接收路径（摘自（The Path of a Packet Through the Linux Kernel（论文））"
				}
			]
		},
		{
			"ID": "20241107165014-2714ymv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-2714ymv",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-7f0hm5v"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-2wtmpn2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-2wtmpn2",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图四：UDP 收发之网络七层系统调用视角（摘自 The Path of a Packet Through the Linux Kernel（论文））"
				}
			]
		},
		{
			"ID": "20241107165014-kym2nnv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-kym2nnv",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-073z57z"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-qrkegl5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-qrkegl5",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图五：内核接收数据过程步骤（摘自：Linux 网络栈接收数据（RX）：原理及内核实现）"
				}
			]
		},
		{
			"ID": "20241107165014-lh0o9xy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-lh0o9xy",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-polphnu"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-qktizdb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-qktizdb",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图六：内核收包流程（摘自：《深入理解 Linux 网络》）"
				}
			]
		},
		{
			"ID": "20241107165014-ywad7kn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-ywad7kn",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-psl5rn5"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-96mgr0o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-96mgr0o",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图七：内核发包流程（摘自：《深入理解 Linux 网络》）"
				}
			]
		},
		{
			"ID": "20241107165014-kwig4fu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-kwig4fu",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-19its08"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-uzaw043",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-uzaw043",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图八：包过滤视角（原图：https://inai.de/images/nf-packet-flow.svg）"
				}
			]
		},
		{
			"ID": "20241107165014-sgtdequ",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-sgtdequ",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当一个网络包到达网卡后，系统的处理流程可以分为以下步骤："
				}
			]
		},
		{
			"ID": "20241107165014-fbn956r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-fbn956r",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "1. 网卡接收包并放入接收队列"
				}
			]
		},
		{
			"ID": "20241107165014-216mwsl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-216mwsl",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 1.1 网络包从物理链路到达网卡后，网卡使用​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "DMA"
				},
				{
					"Type": "NodeText",
					"Data": "​（Direct Memory Access）将包复制到内核的接收队列（Rx Queue）中，无需 CPU 参与。"
				}
			]
		},
		{
			"ID": "20241107165014-ggj01mq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-ggj01mq",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "2. 判断是否触发硬中断"
				}
			]
		},
		{
			"ID": "20241107165014-a3rlp1w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-a3rlp1w",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 2.1 网卡检测NAPI机制的状态："
				}
			]
		},
		{
			"ID": "20241107165014-colqbs2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-colqbs2",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• ​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "NAPI正在处理"
				},
				{
					"Type": "NodeText",
					"Data": "​：如果NAPI已在处理该队列的数据包，不触发新的硬中断。"
				}
			]
		},
		{
			"ID": "20241107165014-bowrx3j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-bowrx3j",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• ​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "NAPI未处理"
				},
				{
					"Type": "NodeText",
					"Data": "​：如果NAPI未在处理该队列中的包，网卡触发​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "硬中断（IRQ）"
				},
				{
					"Type": "NodeText",
					"Data": "​，通知系统有新包需要处理。"
				}
			]
		},
		{
			"ID": "20241107165014-w7x1o1f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-w7x1o1f",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "3. 硬中断处理"
				}
			]
		},
		{
			"ID": "20241107165014-q368abs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-q368abs",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 3.1 如果触发硬中断，系统执行以下步骤："
				}
			]
		},
		{
			"ID": "20241107165014-rzubp0j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-rzubp0j",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 3.1.1 暂停当前CPU上正在执行的进程，进入中断上下文。"
				}
			]
		},
		{
			"ID": "20241107165014-lpe9svv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-lpe9svv",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 3.1.2 硬中断处理函数执行，标记有新包待处理，激活软中断以通知NAPI开始处理接收队列中的包。"
				}
			]
		},
		{
			"ID": "20241107165014-6b3vs73",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-6b3vs73",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 3.1.3 硬中断处理完成后，恢复CPU原有的进程。"
				}
			]
		},
		{
			"ID": "20241107165014-tdk4uwi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-tdk4uwi",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "4. 软中断处理（NAPI 轮询）"
				}
			]
		},
		{
			"ID": "20241107165014-57709tf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-57709tf",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 4.1 触发软中断：硬中断或NAPI定期轮询会激活软中断，调用NAPI的poll()方法从接收队列中批量处理数据包。"
				}
			]
		},
		{
			"ID": "20241107165014-wzstpka",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-wzstpka",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 4.2 处理数据包："
				}
			]
		},
		{
			"ID": "20241107165014-8y1rgys",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-8y1rgys",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 4.2.1 ksoftirqd线程执行软中断处理，通过NAPI的poll()方法从接收队列中批量读取数据包。"
				}
			]
		},
		{
			"ID": "20241107165014-eefbiff",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-eefbiff",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 4.2.2 每个读取的数据包封装成skb（socket buffer）结构，以供上层协议栈处理。"
				}
			]
		},
		{
			"ID": "20241107165014-3dxhshu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-3dxhshu",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 4.3 轮询机制：NAPI会根据设定的上限批量提取包，避免长时间独占CPU。在高负载下，软中断会持续轮询队列，直到数据包处理完毕。"
				}
			]
		},
		{
			"ID": "20241107165014-knjjz0u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-knjjz0u",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "5. 协议栈处理"
				}
			]
		},
		{
			"ID": "20241107165014-9u8491o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-9u8491o",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 5.1 将skb结构传递给网络协议栈，依次执行以下处理："
				}
			]
		},
		{
			"ID": "20241107165014-lk35k2i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-lk35k2i",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 5.1.1 ​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "L2（数据链路层）"
				},
				{
					"Type": "NodeText",
					"Data": "​：进行MAC地址校验和解析。"
				}
			]
		},
		{
			"ID": "20241107165014-6cgylto",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-6cgylto",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 5.1.2 ​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "L3（网络层）"
				},
				{
					"Type": "NodeText",
					"Data": "​：进行IP地址解析和路由选择。"
				}
			]
		},
		{
			"ID": "20241107165014-wihx80q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-wihx80q",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 5.1.3 ​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "L4（传输层）"
				},
				{
					"Type": "NodeText",
					"Data": "​：处理传输层协议（如TCP/UDP），并将数据交付给对应的Socket。"
				}
			]
		},
		{
			"ID": "20241107165014-8eg8klv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-8eg8klv",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "6. 传递到应用层"
				}
			]
		},
		{
			"ID": "20241107165014-vs3f3nq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-vs3f3nq",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "• 6.1 数据包经过协议栈的处理后，最终被传递到相应的应用程序，由应用层处理网络数据。"
				}
			]
		},
		{
			"ID": "20241107165014-w1qof6s",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-w1qof6s",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "附论文"
				}
			]
		},
		{
			"ID": "20241107165014-tgao8s8",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20241107165014-tgao8s8",
				"updated": "20241107165014"
			}
		},
		{
			"ID": "20241107165014-0zsc1m9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-0zsc1m9",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "The Path of a Packet Through the Linux Kernel"
				}
			]
		},
		{
			"ID": "20241107165014-481y5f3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-481y5f3",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原文地址："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "https://www.net.in.tum.de/fileadmin/TUM/NET/NET-2024-04-1/NET-2024-04-1_16.pdf"
				}
			]
		},
		{
			"ID": "20241107165014-e4stgle",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-e4stgle",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Abstract"
				}
			]
		},
		{
			"ID": "20241107165014-66nhgji",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-66nhgji",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "网络堆栈是通信和信息交换的支柱。本文研究了最常见的服务器操作系统 Linux 的 TCP/IPv4 和 UDP/IPv4 网络堆栈。我们描述了 Linux 内核 5.10.8 中最关键的网络功能的踪迹。尽管存在 Linux 网络代码文档，但它通常已经过时或仅涵盖 IP 或 TCP 层等特定方面。我们从整体上解决这个问题，涵盖数据包通过 Linux 网络堆栈的出口和入口路径。此外，我们重点介绍了实现的复杂性，并介绍了 Linux 内核如何实现网络协议。我们的论文可以作为性能优化、安全分析、网络可观察性或调试的基础。"
				}
			]
		},
		{
			"ID": "20241107165014-desb47s",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-desb47s",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. 介绍"
				}
			]
		},
		{
			"ID": "20241107165014-1kkvwjo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-1kkvwjo",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如今，几乎所有东西都联网了，从个人电脑到冰箱[1]。尽管网络对于现代计算至关重要，但很少有人知道通过线路传输数据包的复杂性。鉴于基于 Linux 的服务器 [2]、[3] 的流行，数据包穿过 Linux 网络堆栈是很常见的。然而，了解 Linux 中复杂的数据包处理的复杂性需要时间和精力。然而，这些知识通常至关重要，因为它有助于性能优化、安全分析、调试和网络可观察性。"
				}
			]
		},
		{
			"ID": "20241107165014-8b59jpd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-8b59jpd",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们对入口和出口数据包路径的调查基于 Linux 内核 5.10.8 版本。它文档齐全、稳定，并包含现代功能，例如 Berkely 数据包过滤器的即时 (JIT) 编译器 [4]。首先，我们对内核源代码进行观察，并将其链接到引用的内核符号。"
				}
			]
		},
		{
			"ID": "20241107165014-xejv09h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-xejv09h",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "尽管 Linux 内核网络变得越来越多样化，例如。例如，通过添加多路径 TCP [5]，大多数流量都使用标准 TCP 和 UDP 协议栈。此外，尽管 IPv6 的采用加速，大多数设备仍然通过 IPv4 进行通信 [6]。因此，我们将此分析限制为 TCP/IPv4 和 UDP/IPv4。"
				}
			]
		},
		{
			"ID": "20241107165014-mcqv2s2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-mcqv2s2",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本文的其余部分具有以下结构：首先，我们将本文与第 2 节中的现有文献进行比较。然后，在第 3 节中，我们解释通用 Linux 网络堆栈和 sk_buff 数据结构的设计。在第 4 节中，我们检查入口和出口数据包路径的复杂性。最后，在第五节中，我们简要总结了最重要的发现。"
				}
			]
		},
		{
			"ID": "20241107165014-0ezca0u",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-0ezca0u",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2. 相关工作"
				}
			]
		},
		{
			"ID": "20241107165014-dglnvmz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-dglnvmz",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们尽我们所知评估了有关 Linux 网络堆栈的文献。在此过程中，我们进行了以下观察。"
				}
			]
		},
		{
			"ID": "20241107165014-swp1hye",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-swp1hye",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "过时的 Linux 内核版本"
				},
				{
					"Type": "NodeText",
					"Data": "​。更详细的论文出现在 2000 年代，使用 Linux 内核版本 2 或 3 [7]–[9]。尽管网络堆栈中旧协议的实现很稳定，但已经过去了很长时间。因此，我们调查可能的偏差。"
				}
			]
		},
		{
			"ID": "20241107165014-acfmrwr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-acfmrwr",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "碎片化的信息"
				},
				{
					"Type": "NodeText",
					"Data": "​。许多论文关注特定层，最常见的是 TCP 和 IP 实现 [10]–[13]。其他人确定网络开销的原因[14]、[15]。在这些情况下缺乏整体观点。特别是，即使作者描述了数据包在多个层中的路径 [7]-[10]，他们也省略了 UDP——与本文相反。"
				}
			]
		},
		{
			"ID": "20241107165014-mrpymjc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-mrpymjc",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然有一篇演讲涵盖了 Linux 版本 5 的整个入口和出口路径 [16]，但它是高层的，主要给出了一种直觉。因此，我们的目标是在详细的特定层信息和高级网络堆栈跟踪之间找到一个中间立场。"
				}
			]
		},
		{
			"ID": "20241107165014-mwdam3c",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-mwdam3c",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3. 背景"
				}
			]
		},
		{
			"ID": "20241107165014-0nxigig",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-0nxigig",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们假设您对 Linux 和网络有基本的熟悉。不过，我们将简要描述与整个数据包路径相关的基本 Linux 网络概念。"
				}
			]
		},
		{
			"ID": "20241107165014-m35b88f",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-m35b88f",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.1. Linux 网络堆栈"
				}
			]
		},
		{
			"ID": "20241107165014-kz3p9va",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-kz3p9va",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-fkwt6k0"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-b2xz5n5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-b2xz5n5",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "图 1：Linux 中标准 TCP/IP 和 UDP/IP 堆栈中使用的技术（从用户空间到线路）的描述。"
				}
			]
		},
		{
			"ID": "20241107165014-bxno6mf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-bxno6mf",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如图 1 所示，套接字要么将数据包传递到用户空间应用程序，要么从传输层协议的实现（即）接收数据包。例如，TCP 或 UDP。然后 IP 层将数据包路由到网络层。在此层之下，Linux 允许通过防火墙规则过滤流量。网络接口卡 (NIC) 将从接收 (RX) 缓冲区接收的数据包转发到内核，并传输从发送 (TX) 缓冲区读取的数据包。"
				}
			]
		},
		{
			"ID": "20241107165014-a73ggfk",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-a73ggfk",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.2.套接字缓冲区 (sk_buff)"
				}
			]
		},
		{
			"ID": "20241107165014-lp18grh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-lp18grh",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "内核将数据包保存在称为 sk_buff 的 C 结构中。数据包路径上的几乎所有功能都与其交互。sk_buff 跟踪数据包元数据并在内存中维护指向数据包数据的开始和结束指针[17]。使用对数据包数据的引用可以通过调整指针来进行有效的数据包修改，例如。例如，当剥离标题时。此外，sk_buff 结构可以使用内存引用在不同进程之间有效共享[17]。因此，克隆数据包也很有效，因为假设只读工作负载，只需复制元数据 [17]。我们在图 2 中展示了这一点。sk_buff 的这些属性构成了 Linux 上高效数据包处理的基础。"
				}
			]
		},
		{
			"ID": "20241107165014-tk4y4en",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-tk4y4en",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-xhclv3e"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-doj2vsh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-doj2vsh",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "图 2：两个简化的 sk_buff 结构指向同一数据包缓冲区内的不同位置。head 标记缓冲区的填充开始，而 tail 则指向实际数据包数据的末尾。data 指向当前处理的标头。"
				}
			]
		},
		{
			"ID": "20241107165014-jripg1t",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-jripg1t",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4. Packet Flow"
				}
			]
		},
		{
			"ID": "20241107165014-tmjs4z7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-tmjs4z7",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这里，我们对入口和出口路径都感兴趣。两条路径独立运行。"
				}
			]
		},
		{
			"ID": "20241107165014-v86omq6",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-v86omq6",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.1.出口路径"
				}
			]
		},
		{
			"ID": "20241107165014-tyv8cks",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-tyv8cks",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，我们分析出口路径，即 Linux 如何将数据包从用户空间应用程序发送到 NIC，如图 3 所示。本质上，出口端构建协议标头，将它们推送到 sk_buff 结构，然后将其发送出去。"
				}
			]
		},
		{
			"ID": "20241107165014-zfrcj3v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-zfrcj3v",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165013-bbccaqc"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-2hqq60p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-2hqq60p",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "图 3：TCP 情况下数据包的出口路径，如第 4.1 节中所述（摘自 [10]）。"
				}
			]
		},
		{
			"ID": "20241107165014-kal6l4y",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-kal6l4y",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.1.1.套接字层"
				}
			]
		},
		{
			"ID": "20241107165014-8256x0s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-8256x0s",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一切都以具有关联域的套接字开始，例如。例如，AF_UNIX、AF_XDP，或者在我们的例子中，用于 IPv4 的 AF_INET。像 write() 或 sendto() 这样的系统调用包装函数使我们能够通过套接字发送数据，例如：例如，由 GNU C 库 [18] 提供。在本文中，我们选择 write(filedescriptor, buffer, length) 以避免不必要的复杂性。写入文件描述符是 UNIX 哲学“一切皆文件”的一个主要示例，因为文件描述符抽象了套接字 [19]。"
				}
			]
		},
		{
			"ID": "20241107165014-w4eqqzd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-w4eqqzd",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于套接字，write() 调用 sock_sendmsg() 函数。它从用户空间应用程序提供的文件描述符中获取套接字结构 sock。通常，套接字对包含进程的进程 ID (PID)、用户 ID (UID) 和组 ID (GID) [19] 的套接字控制消息进行操作。sock_sendmsg() 从 task_struct（一个 Linux 数据结构，其中包含调用进程的此信息）中检索此控制消息。有了这些信息，sock_sendmsg() 通常会将数据包通过 Linux 安全模块（例如 SELinux）来过滤流量。"
				}
			]
		},
		{
			"ID": "20241107165014-y1jq4q6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-y1jq4q6",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最后，它通过宏 INDIRECT_CALL_INET 调用相应的传输层处理程序，在我们的例子中是 TCP 或 UDP。该宏根据 sk_prot（sk_buff 的一个字段）中指定的协议自主选择传输协议入口函数的相应 IPv4 或 IPv6 变体。"
				}
			]
		},
		{
			"ID": "20241107165014-18yw1uq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-18yw1uq",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.1.2.传输层"
				}
			]
		},
		{
			"ID": "20241107165014-l8z4p1i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-l8z4p1i",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这里，我们到达与 IPv4 相关的入口函数，TCP 的 tcp_sendmsg() 和 UDP 的 udp_sendmsg()。"
				}
			]
		},
		{
			"ID": "20241107165014-31z8amo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-31z8amo",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "TCP。"
				},
				{
					"Type": "NodeText",
					"Data": " tcp_sendmsg() 首先等待 TCP 连接建立。然后，它为段分配 sk_buff 结构并将它们排入套接字写入队列，如图 3 所示。tcp_sendmsg() 还保证遵守最大段大小 (MSS)。处理完队列后，内核调用 tcp_write_queue_tail()。它还构建 TCP 标头并将数据从用户空间推送到 sk_buff。如果数据适合现有缓冲区，则使用 skb_add_data_nocache()。否则，它会创建新的缓冲区，这会更昂贵。然后它将 Transport_header 指针设置为此标头的开头。接下来，它按照套接字选项中指定的方式构建网络层协议标头，例如：例如，AF_INET 的 IPv4。tcp_write_xmit() 保证内核在拥塞控制限制的情况下保留数据。它还设置重传定时器，即。即，如果没有及时收到ACK，则重新发送数据包。最后，tcp_transmit_skb()读取包含先前构造的段的写入队列，并通过套接字中指定的queue_xmit()函数将它们传递到网络层。"
				}
			]
		},
		{
			"ID": "20241107165014-3ci248j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-3ci248j",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "UDP。"
				},
				{
					"Type": "NodeText",
					"Data": "类似的还有udp_sendmsg()。该函数再次写入套接字写入队列。接下来，该函数等待，直到 UDP 数据报文没有待处理的帧。和以前一样，该函数构建标头，设置目标端口和其他字段。"
				}
			]
		},
		{
			"ID": "20241107165014-a2kbemg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-a2kbemg",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "存在 Corking 和非 Corking 两种情况：Corking 描述了等待帧来批处理多个 UDP 数据报文。非 Corking 意味着直接构建 sk_buff。构建数据报文后，ip_route_output_flow() 路由数据报文并构建网络层协议标头。最后，ip_append_data() 创建一个组合多个 UDP 数据报文的 IP 数据包。总体而言，简单性和无锁定表明 UDP 实现比 TCP 实现更高效。"
				}
			]
		},
		{
			"ID": "20241107165014-639qm72",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-639qm72",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.1.3. IP层"
				}
			]
		},
		{
			"ID": "20241107165014-6wdz145",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-6wdz145",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "IP 处理从函数 __ip_queue_xmit() 开始。首先，该函数确定到达目的地的路线。如果路由已经在 sk_buff-\u003e_skb_refdst 中，则跳过路由过程。在这种情况下，该函数立即构建标头。但是，如果没有目的地，则路由过程将继续。它从 sk_buff 的套接字字段确定目的地，即，e。例如，如果套接字先前接收到 IP 数据包，则设置。如果这不可能，它会查询路由缓存，称为转发信息库 (FIB)，这是一个根据 IP 路由表生成的表。最终，如果仍然没有路由，则返回主机不可达并停止处理。否则，如果内核找到路由，则会构建 IP 标头。"
				}
			]
		},
		{
			"ID": "20241107165014-jghko71",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-jghko71",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在，调用 ip_options_build() 来设置 IP 选项。它使用 sk_buff 的 network_header 字段标记标头的开始。接下来，它会触发Linux防火墙机制netfilter的LOCAL_OUT阶段。之后，dst_output() 通过函数指针调用实际的路由函数。"
				}
			]
		},
		{
			"ID": "20241107165014-sb5ny1d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-sb5ny1d",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后，内核为最常见的单播数据包调用 ip_output() 路由函数。当路由完成时，此阶段称为 POST_ROUTING。它更新数据包元数据并调用 NF_INET_POST_ROUTING 挂钩。它设置 sk_buff 元数据并再次调用 netfilter。此外，如果数据包超过最大长度（最大传输单元），它会对数据包进行分段。"
				}
			]
		},
		{
			"ID": "20241107165014-ndb6mj6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-ndb6mj6",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后，在将数据包传递给 NF_INET_LOCAL_OUT 挂钩后，ip_output() 调用 ip_finish_output()。它增加多播和广播数据包的计数器。它还检查 sk_buff 是否有足够的空间容纳 MAC 标头。目标 MAC 地址要么被缓存，要么由邻居输出函数 neigh_resolve_output() 确定。后者利用地址解析协议（ARP）[20]。如果没有 ARP 回复，它会再次将数据包排队。获得MAC地址后，内核构造以太网头，将其添加到sk_buff中。"
				}
			]
		},
		{
			"ID": "20241107165014-blv6pjd",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-blv6pjd",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.1.4.以太网层"
				}
			]
		},
		{
			"ID": "20241107165014-kvdqi31",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-kvdqi31",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，dev_queue_xmit()设置sk_buff中的mac_header字段，然后将其传递给tc_egress()。它按照排队规则（qdisc）对数据包进行排队[21]。只要 NIC 缓冲区已满，__qdisc_run() 就会将数据包从缓冲区中出列。在 validate_xmit_skb() 中进行一些后处理后，e。例如，计算以太网校验和或添加 VLAN 标记，内核调用 ndo_start_xmit，然后将数据包添加到 NIC 的 TX 环。最终，NIC 的队列可能已满。在这种情况下，内核停止 qdisc [21] 并对 sk_buff 进行排队。最后，在添加更多 sk_buff 元数据后，它将数据包映射到内存中的固定位置以进行直接内存访问 (DMA)。dev_direct_xmit 允许绕过 qdisc [21]，直接将数据包写入 NIC 的 TX 环。eXpress 数据路径 (XDP) [22] 就是这种情况的一个用例。最终，该函数通过中断通知NIC结束处理并释放sk_buff。"
				}
			]
		},
		{
			"ID": "20241107165014-1a50ik1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-1a50ik1",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.2.入口路径"
				}
			]
		},
		{
			"ID": "20241107165014-qv1qdv6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-qv1qdv6",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在，我们跟踪到达 NIC 的数据包的路径，直到用户空间应用程序通过套接字读取该数据包，请参见图 4。最值得注意的是，它分析标头以确定以下函数调用并剥离它们。"
				}
			]
		},
		{
			"ID": "20241107165014-ky6e7y9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-ky6e7y9",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165013-v4cds4f"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-a12kged",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-a12kged",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "图 4：TCP 情况下数据包的入口路径，如第 4.2 节中所述（摘自 [10]）。"
				}
			]
		},
		{
			"ID": "20241107165014-zqddj61",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-zqddj61",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.2.1.以太网层"
				}
			]
		},
		{
			"ID": "20241107165014-a4uzknv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-a4uzknv",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在验证并可选择将以太网校验和清零并应用 MAC 地址过滤器后，NIC 通过 DMA 将数据包复制到系统内存。然后，它通过中断通知操作系统并指示数据包数据的位置。这样，操作系统就可以分配一个sk_buff。现在，内核将元数据插入到 sk_buff 中，例如协议字段（以太网）、接收接口和数据包类型（在我们的例子中为 IP）。"
				}
			]
		},
		{
			"ID": "20241107165014-zj3coft",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-zj3coft",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在此阶段，内核知道以太网标头的开头，因此它将 mac_header 字段设置为 sk_buff 的开头。最后，它从 sk_buff 中删除以太网标头，然后再将其进一步传递到网络堆栈。接下来，数据包到达 netif_receive_skb()。该函数克隆 sk_buff 并将其转发到虚拟 TAP 接口。TAP 接口支持同一网络内的虚拟机 (VM) 和主机之间的通信。这里的另一个重要情况是将带有 VLAN 标记的数据包转发到 VLAN 接口。此外，当接口有物理主机时，即。即，它是虚拟接口或网桥的一部分，rx_handler() 窃取数据包。rx_handler() 还设置 sk_buff 的 network_header 字段。最后，它调用 IPv4 协议处理函数 ip_rcv()。"
				}
			]
		},
		{
			"ID": "20241107165014-xg02yu0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-xg02yu0",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.2.2. IP层"
				}
			]
		},
		{
			"ID": "20241107165014-62x54y7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-62x54y7",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以太网层通过函数 ip_rcv() 将数据包传递到 IP 层。同样，ip_rcv() 检查 MAC 地址并丢弃外部地址。然后，验证版本、长度和校验和字段。接下来，该函数设置 sk_buff 的 transport_header 字段。它还应用 netfilter 的 PRE_ROUTING 规则。它通过将数据包转发到 NF_INET_PRE_ROUTING 钩子来实现过滤器。钩子获取指向 ip_rcv_finish() 函数的指针，该函数在完成后调用。如果注册了网络层主设备，它会将 sk_buff 传递给其处理程序。它调用 ip_route_input_noref()，后者从 sk_buff 读取 IP 标头。接下来，内核通过 ip_rcv_options() 处理 IP 选项。之后，它通过 dst_input() 调用之前选择的路由函数。路由数据包有三种选择："
				}
			]
		},
		{
			"ID": "20241107165014-6rafpwh",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20241107165014-6rafpwh",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"ID": "20241107165013-9grfydy",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20241107165013-9grfydy",
						"updated": "20241107165013"
					},
					"Children": [
						{
							"ID": "20241107165014-l20zna7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107165014-l20zna7",
								"updated": "20241107165014"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ip_forward：此功能针对未寻址到当前机器的数据包激活。它继续转发数据包，无需额外处理。"
								}
							]
						}
					]
				},
				{
					"ID": "20241107165013-1h09ph0",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20241107165013-1h09ph0",
						"updated": "20241107165013"
					},
					"Children": [
						{
							"ID": "20241107165014-opv6kxr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107165014-opv6kxr",
								"updated": "20241107165014"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ip_local_deliver()：如果我们是数据包的最终接收者（localhost），内核不会转发数据包，而是将其向上传递到网络堆栈。"
								}
							]
						}
					]
				},
				{
					"ID": "20241107165013-9txce3r",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20241107165013-9txce3r",
						"updated": "20241107165013"
					},
					"Children": [
						{
							"ID": "20241107165014-j3yt765",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20241107165014-j3yt765",
								"updated": "20241107165014"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ip_mr_input()：该函数用于组播数据包，即寻址到多播地址。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20241107165014-a9arpdr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-a9arpdr",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由于我们主要感兴趣的是最终接收者如何处理数据包，考虑到所有层，我们继续使用 ip_local_deliver()。最重要的是，该函数通过调用 ip_defrag() 处理 IP 碎片，对数据包进行排队，直到接收到所有碎片。之后，事件 NF_INET_LOCAL_IN 触发，该事件反过来调用 ip_local_deliver_finish()，从 sk_buff 中剥离 IP 标头。最后，它通过 dst_input() 函数将数据包从 IP 传递到 TCP/UDP 层到 tcp_v4_rcv() 或函数。它通过检查指向 sk_buff 的标头来确定相应的协议处理程序。"
				}
			]
		},
		{
			"ID": "20241107165014-ksmo1wy",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-ksmo1wy",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.2.3.传输层"
				}
			]
		},
		{
			"ID": "20241107165014-6j0ul7f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-6j0ul7f",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在，我们检查出口 TCP 和 UDP 功能的对应部分。"
				}
			]
		},
		{
			"ID": "20241107165014-pg51me4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-pg51me4",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "TCP。首先，该段到达传输层函数 tcp_ipv4_recv()，其中 sk_buff 标头指针移至 TCP 或 UDP 标头的开头。然后，它通过 pskb_may_pull() 验证传输标头，从而验证 TCP 校验和。和以前一样，它从 sk_buff 中删除 TCP 标头。为了进一步传递数据包，它通过 __inet_lookup_skb() 找到相应的 TCP 套接字。它将数据包写入套接字接收队列（参见图 4）并发出新数据可用的信号，例如：例如，通过 SIGIO 或 SIGURG。这种通知机制允许有效地轮询套接字。至于出口，内核在数据包处理期间维护 TCP 状态机。e.例如，它不会处理通过 TCP_CLOSING 终止的 TCP 连接的新数据包。"
				}
			]
		},
		{
			"ID": "20241107165014-8yp2chn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-8yp2chn",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们简要强调处理过程中的两个重要情况：TCP_NEW_SYN_RECV 和 TCP_TIME_WAIT。TCP_NEW_SYN_RECV表示有新连接。在这种情况下，内核通过 tcp_filter() 拒绝 TCP 级别的连接。在 TCP_TIME_WAIT 期间，内核会丢弃任何其他 TCP 段。"
				}
			]
		},
		{
			"ID": "20241107165014-ayezr11",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-ayezr11",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此外，还有一条慢速路径和一条快速路径。慢速路径包含更多错误检查和查找。相比之下，快速路径针对速度进行了优化，不允许自省和流量分析。对于慢速路径，我们等待状态机在 tcp_v4_do_rcv() 中处于 TCP_ESTABLISHED。更新后，tcp_v4_do_rcv() 调用 tcp_rcv_established()，后者处理快速路径和慢速路径中的数据包。它还验证序列号是否在上升。快速路径将数据包直接复制到用户空间。如果可能，内核总是尝试使用快速路径。但是，当建立 TCP 连接时，这是不可能的，因为内核必须跟踪新连接。"
				}
			]
		},
		{
			"ID": "20241107165014-75o6frk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-75o6frk",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在处理 TCP 状态机并选择路径后，内核将数据包放入套接字队列中，以便用户程序可以读取它（参见图 4）。"
				}
			]
		},
		{
			"ID": "20241107165014-fvy217p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-fvy217p",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由于 TCP 非常复杂，因此涉及更多方面超出了本文的范围。然而，[7]、[10]、[11]对其进行了更详细的描述。"
				}
			]
		},
		{
			"ID": "20241107165014-366440o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-366440o",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "UDP。与 TCP 相比，UDP 的实现不太复杂。它从 IP 层中通过 dst_input() 调用的 udp_rcvmsg() 开始。首先，该函数调用 __skb_recv_udp() 从具有先前计算的偏移量的套接字读取数据报文。特别是，它不断尝试从套接字读取 sk_buff，最终在新的 UDP 数据报文到达时停止。然后验证数据报文的校验和。然后，该函数复制目标 IP 和 UDP 端口，以将数据报文映射到正确的套接字。因此，它通过 skb_consume_udp() 消耗 UDP 数据报文。最后，它调整 peek 偏移量，处理引用计数器，并通过 __consume_stateless_skb() 释放 sk_buff。"
				}
			]
		},
		{
			"ID": "20241107165014-egq74ie",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20241107165014-egq74ie",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.2.4.套接字层"
				}
			]
		},
		{
			"ID": "20241107165014-4bgwbfe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-4bgwbfe",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这里，内核通过 read() 函数从套接字收集写入 TCP 或 UDP 套接字的新数据，使数据包从套接字接收队列中出列（参见图 4）。为了匹配出口中 IPv4 的使用，我们使用 AF_INET 接收套接字。函数 sys_recv() 可以实现此功能，首先调用 sys_recvfrom() 来查找套接字。然后，它调用 sock_recvmsg() 从套接字读取消息，并通过 Linux 安全模块传递接收到的消息，类似于出口。对于 IPv4，inet_recvmsg() 调用 tcp_recvmsg() 或 udp_recvmsg()。他们将数据包的内容出队并将其写入用户空间缓冲区，例如。例如，堆上的数组。最后，他们释放了 sk_buff。"
				}
			]
		},
		{
			"ID": "20241107165014-c137jwu",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-c137jwu",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5. 结论"
				}
			]
		},
		{
			"ID": "20241107165014-q5xn0jw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-q5xn0jw",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20241107165014-7f0hm5v"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20241107165014-pc4stm3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-pc4stm3",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "图 5：UDP 出口和入口中最重要功能的概述，如第 4 节所述。"
				}
			]
		},
		{
			"ID": "20241107165014-ffxv6hv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-ffxv6hv",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本文介绍了数据包如何穿越 TCP/IPv4 和 UDP/IPv4 的 Linux 内核。图 5 简要介绍了数据包的出站和入站路径，重点介绍了每层最重要的功能。此外，我们还描述了数据包处理的复杂性，包括 Linux 内核采用的路由、过滤和排队机制。此外，我们还了解了内核中不同层之间的通信方式。通过利用这些知识，网络管理员和开发人员可以在优化网络性能、设计安全措施或排除网络故障时做出明智的决策。"
				}
			]
		},
		{
			"ID": "20241107165014-3revqf6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-3revqf6",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总体而言，观察到的现有文献的变化主要是增强而不是重写，例如。例如，重构或安全性改进。一个典型的例子是 TCP 初始序列号的选择。出于安全考虑，内核作者多次修改了底层哈希算法[23]。保守的改变是有道理的，因为协议大部分保持不变，而错误的影响很大。对多路径 TCP 或 QUIC 执行类似的分析是未来的工作。"
				}
			]
		},
		{
			"ID": "20241107165014-vj6xs69",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20241107165014-vj6xs69",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "References"
				}
			]
		},
		{
			"ID": "20241107165014-pt68ahn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-pt68ahn",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[1] T.-H. Lee, S.-W. Kang, T. Kim, J.-S. Kim, and H.-J. Lee, “Smart Refrigerator Inventory Management Using Convolutional Neural Networks,” in 2021 IEEE 3rd International Conference on Artificial Intelligence Circuits and Systems (AICAS), 2021, pp. 1–4."
				}
			]
		},
		{
			"ID": "20241107165014-xqiieda",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-xqiieda",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[2] W3Techs. (2019) Usage Statistics of Operating Systems for Websites. https://w3techs.com/technologies/overview/operating_ system. [Online; accessed 02-December-2023]."
				}
			]
		},
		{
			"ID": "20241107165014-vdeh763",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-vdeh763",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[3] ——. (2019) Usage Statistics of Unix for Websites. https://w3techs. com/technologies/details/os-unix. [Online; accessed 02-December2023]."
				}
			]
		},
		{
			"ID": "20241107165014-k6trffg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-k6trffg",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[4] J. Corbet. (2011) A JIT for Packet Filters. https://lwn.net/Articles/ 437981/. [Online; accessed 02-December-2023]."
				}
			]
		},
		{
			"ID": "20241107165014-cssddk4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-cssddk4",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[5] C. Paasch and O. Bonaventure, “Multipath TCP,” Commun. ACM, vol. 57, no. 4, p. 51–57, apr 2014. [Online]. Available: https://doi.org/10.1145/2578901"
				}
			]
		},
		{
			"ID": "20241107165014-z0wmdo1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-z0wmdo1",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[6] M. T. Hossain, “A Review on IPv4 and IPv6: A Comprehensive Survey,” 01 2022, International Interconnect Technology Conference (IITC). [Online]. Available: https://doi.org/10.13140/RG.2.2.18673.61284"
				}
			]
		},
		{
			"ID": "20241107165014-bhqdjhr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-bhqdjhr",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[7] J. Crowcroft and I. Phillips, TCP/IP and Linux Protocol Implementation: Systems Code for the Linux Internet. USA: John Wiley \u0026 Sons, Inc., 2001."
				}
			]
		},
		{
			"ID": "20241107165014-y0lyrkc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-y0lyrkc",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[8] A. Chimata, “Path of a Packet in the Linux Kernel Stack,” 01 2005. [Online]. Available: https://www.cs.dartmouth.edu/~sergey/ netreads/path-of-packet/Network_stack.pdf"
				}
			]
		},
		{
			"ID": "20241107165014-d0n4yqs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-d0n4yqs",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[9] C. Guo and Z. Shaoren, “Analysis and Evaluation of the TCP/IP Protocol Stack of Linux,” vol. 1, 02 2000, pp. 444–453 vol.1."
				}
			]
		},
		{
			"ID": "20241107165014-i5axh38",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-i5axh38",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[10] Helali Bhuiyan and Mark E. McGinley and Tao Li and Malathi Veeraraghavan, “TCP Implementation in Linux : A Brief Tutorial,” 2008. [Online]. Available: https://api.semanticscholar. org/CorpusID:14676835"
				}
			]
		},
		{
			"ID": "20241107165014-7pg8rmb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-7pg8rmb",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[11] Antti Jaakkola, “Implementation of Transmission Control Protocol in Linux,” 2012. [Online]. Available: https://wiki.aalto.fi/download/ attachments/70789052/linux-tcp-review.pdf"
				}
			]
		},
		{
			"ID": "20241107165014-21dqn98",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-21dqn98",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[12] F. U. Khattak. (2012) IP Layer Implementation of Linux Kernel Stack. [Online]. Available: https://wiki.aalto.fi/download/ attachments/70789059/linux-kernel-ip.pdf"
				}
			]
		},
		{
			"ID": "20241107165014-15x59i8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-15x59i8",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[13] M. C. Wenji Wu, “The Performance Analysis of Linux Networking - Packet Receiving,” 2006, 15th International Conference on Computing in High Energy and Nuclear Physics (CHEP 2006)."
				}
			]
		},
		{
			"ID": "20241107165014-ipz54jd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-ipz54jd",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[14] Q. Cai, S. Chaudhary, M. Vuppalapati, J. Hwang, and R. Agarwal, “Understanding Host Network Stack Overheads,” in Proceedings of the 2021 ACM SIGCOMM 2021 Conference, ser. SIGCOMM ’21. New York, NY, USA: Association for Computing Machinery, 2021, p. 65–77. [Online]. Available: https://doi.org/10.1145/ 3452296.3472888"
				}
			]
		},
		{
			"ID": "20241107165014-och987f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-och987f",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[15] M. Abranches, O. Michel, and E. Keller, “Getting Back What Was Lost in the Era of High-Speed Software Packet Processing,” in Proceedings of the 21st ACM Workshop on Hot Topics in Networks, ser. HotNets ’22. New York, NY, USA: Association for Computing Machinery, 2022, p. 228–234. [Online]. Available: https://doi.org/10.1145/3563766.3564114"
				}
			]
		},
		{
			"ID": "20241107165014-i1yp6nk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-i1yp6nk",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[16] J. Benc, “The Network Packet’s Diary: A Kernel Journey,” 2018, devcon.cz 2018."
				}
			]
		},
		{
			"ID": "20241107165014-71mbdth",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-71mbdth",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[17] The kernel development community. struct sk_buff. https: //docs.kernel.org/networking/skbuff.html. [Online; accessed 02December-2023]."
				}
			]
		},
		{
			"ID": "20241107165014-21m182c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-21m182c",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[18] G. Foundation. (2023) The GNU C Library Reference Manual. https://sourceware.org/glibc/manual/2.38/html_mono/libc.html# Transferring-Data. [Online; accessed 05-December-2023]."
				}
			]
		},
		{
			"ID": "20241107165014-vchux90",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-vchux90",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[19] M. Kerrisk, The Linux Programming Interface: A Linux and UNIX System Programming Handbook, 1st ed. USA: No Starch Press, 2010."
				}
			]
		},
		{
			"ID": "20241107165014-iotxv1r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-iotxv1r",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[20] “An Ethernet Address Resolution Protocol: Or Converting Network Protocol Addresses to 48.bit Ethernet Address for Transmission on Ethernet Hardware,” RFC 826, Nov. 1982. [Online]. Available: https://www.rfc-editor.org/info/rfc826"
				}
			]
		},
		{
			"ID": "20241107165014-d7bc51y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-d7bc51y",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[21] tc - traffic control utility, Linux Documentation Project, December 2023, https://man7.org/linux/man-pages/man8/tc.8.html."
				}
			]
		},
		{
			"ID": "20241107165014-bxj5x47",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-bxj5x47",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[22] T. Høiland-Jørgensen, J. D. Brouer, D. Borkmann, J. Fastabend, T. Herbert, D. Ahern, and D. Miller, “The eXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel,” in Proceedings of the 14th International Conference on Emerging Networking EXperiments and Technologies, ser. CoNEXT ’18. New York, NY, USA: Association for Computing Machinery, 2018, p. 54–66. [Online]. Available: https://doi.org/10. 1145/3281411.3281443"
				}
			]
		},
		{
			"ID": "20241107165014-6hivue9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20241107165014-6hivue9",
				"updated": "20241107165014"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "[23] F. Gont and S. Bellovin, “Defending Against Sequence Number Attacks,” RFC 6528, Feb. 2012. [Online]. Available: https: //www.rfc-editor.org/info/rfc6528"
				}
			]
		}
	]
}