{
	"ID": "20230903112027-8mubrqd",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230903112027-8mubrqd",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230903112114-2hqxv5o\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230903112736-y8owp94\u0026quot;,\u0026quot;scrollTop\u0026quot;:616,\u0026quot;focusId\u0026quot;:\u0026quot;20230903112509-fekz8yy\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "1.3 在 SHELL 中传递信号",
		"updated": "20230903112736"
	},
	"Children": [
		{
			"ID": "20230903112114-2hqxv5o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112114-2hqxv5o",
				"updated": "20230903112114"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Kubernetes 中，Pod 停止时 kubelet 会先给容器中的主进程发 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "SIGTERM"
				},
				{
					"Type": "NodeText",
					"Data": "​ 信号来通知进程进行 shutdown 以实现优雅停止，如果超时进程还未完全停止则会使用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "SIGKILL"
				},
				{
					"Type": "NodeText",
					"Data": "​ 来强行终止。"
				}
			]
		},
		{
			"ID": "20230903112114-21ygcnq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112114-21ygcnq",
				"updated": "20230903112114"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但有时我们会遇到一种情况: 业务逻辑处理了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "SIGTERM"
				},
				{
					"Type": "NodeText",
					"Data": "​ 信号，但 Pod 停止时好像没收到信号导致优雅停止逻辑不生效。"
				}
			]
		},
		{
			"ID": "20230903112114-8u7c2lh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112114-8u7c2lh",
				"updated": "20230903112114"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通常是因为我们的业务进程是在脚本中启动的，容器的启动入口使用了脚本，所以容器中的主进程并不是我们所希望的业务进程而是 shell 进程，导致业务进程收不到 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "SIGTERM"
				},
				{
					"Type": "NodeText",
					"Data": "​ 信号，更详细的原因在上一节我们已经介绍了，下面将介绍几种解决方案。"
				}
			]
		},
		{
			"ID": "20230903112122-zhpqze7",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230903112122-zhpqze7",
				"updated": "20230903112244"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. 使用exec启动"
				}
			]
		},
		{
			"ID": "20230903112156-kry23qt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112156-kry23qt",
				"updated": "20230903112156"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 shell 中启动二进制的命令前加一个 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://stackoverflow.com/questions/18351198/what-are-the-uses-of-the-exec-command-in-shell-scripts",
					"TextMarkTextContent": "exec"
				},
				{
					"Type": "NodeText",
					"Data": " 即可让该二进制启动的进程代替当前 shell 进程，即让新启动的进程成为主进程:"
				}
			]
		},
		{
			"ID": "20230903112204-byqkcwm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230903112204-byqkcwm",
				"updated": "20230903112206"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#! /bin/bash\n...\n\nexec /bin/yourapp # 脚本中执行二进制\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230903112217-2nno8jz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112217-2nno8jz",
				"updated": "20230903112218"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后业务进程就可以正常接收所有信号了，实现优雅退出也不在话下。"
				}
			]
		},
		{
			"ID": "20230903112247-7x219o1",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230903112247-7x219o1",
				"updated": "20230903112350"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.  多进程场景：使用trap传递信号"
				}
			]
		},
		{
			"ID": "20230903112404-lydl1rj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112404-lydl1rj",
				"updated": "20230903112404"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通常我们一个容器只会有一个进程，也是 Kubernetes 的推荐做法。但有些时候我们不得不启动多个进程，比如从传统部署迁移到 Kubernetes 的过渡期间，使用了富容器，即单个容器中需要启动多个业务进程，这时也只能通过 shell 启动，但无法使用上面的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "exec"
				},
				{
					"Type": "NodeText",
					"Data": "​ 方式来传递信号，因为 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "exec"
				},
				{
					"Type": "NodeText",
					"Data": "​ 只能让一个进程替代当前 shell 成为主进程。"
				}
			]
		},
		{
			"ID": "20230903112404-cfdex6p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112404-cfdex6p",
				"updated": "20230903112404"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个时候我们可以在 shell 中使用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "trap"
				},
				{
					"Type": "NodeText",
					"Data": "​ 来捕获信号，当收到信号后触发回调函数来将信号通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kill"
				},
				{
					"Type": "NodeText",
					"Data": "​ 传递给业务进程，脚本示例:"
				}
			]
		},
		{
			"ID": "20230903112413-03cwn73",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230903112413-03cwn73",
				"updated": "20230903112419"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#! /bin/bash\n\n/bin/app1 \u0026 pid1=\"$!\" # 启动第一个业务进程并记录 pid\necho \"app1 started with pid $pid1\"\n\n/bin/app2 \u0026 pid2=\"$!\" # 启动第二个业务进程并记录 pid\necho \"app2 started with pid $pid2\"\n\nhandle_sigterm() {\n  echo \"[INFO] Received SIGTERM\"\n  kill -SIGTERM $pid1 $pid2 # 传递 SIGTERM 给业务进程\n  wait $pid1 $pid2 # 等待所有业务进程完全终止\n}\ntrap handle_sigterm SIGTERM # 捕获 SIGTERM 信号并回调 handle_sigterm 函数\n\nwait # 等待回调执行完，主进程再退出\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230903112433-2leuce9",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230903112433-2leuce9",
				"updated": "20230903112452"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3. 完美方案"
				}
			]
		},
		{
			"ID": "20230903112509-fekz8yy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112509-fekz8yy",
				"updated": "20230903112519"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前面一种方案实际是用脚本实现了一个极简的 init 系统 (或 supervisor) 来管理所有子进程，只不过它的逻辑很简陋，仅仅简单的透传指定信号给子进程，其实社区有更完善的方案，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/Yelp/dumb-init",
					"TextMarkTextContent": "dumb-init"
				},
				{
					"Type": "NodeText",
					"Data": " 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/krallin/tini",
					"TextMarkTextContent": "tini"
				},
				{
					"Type": "NodeText",
					"Data": " 都可以作为 init 进程，作为主进程 (PID 1) 在容器中启动，然后它再运行 shell 来执行我们指定的脚本 (shell 作为子进程)，shell 中启动的业务进程也成为它的子进程，当它收到信号时会将其传递给所有的子进程，从而也能完美解决 SHELL 无法传递信号问题，并且还有回收僵尸进程的能力。"
				}
			]
		},
		{
			"ID": "20230903112526-hvz3gma",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112526-hvz3gma",
				"updated": "20230903112526"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这是以 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "dumb-init"
				},
				{
					"Type": "NodeText",
					"Data": "​ 为例制作镜像的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Dockerfile"
				},
				{
					"Type": "NodeText",
					"Data": "​ 示例:"
				}
			]
		},
		{
			"ID": "20230903112536-qtjuqyp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230903112536-qtjuqyp",
				"updated": "20230903112541"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "FROM ubuntu:22.04\nRUN apt-get update \u0026\u0026 apt-get install -y dumb-init\nADD start.sh /\nADD app1 /bin/app1\nADD app2 /bin/app2\nENTRYPOINT [\"dumb-init\", \"--\"]\nCMD [\"/start.sh\"]\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230903112601-v5a956j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112601-v5a956j",
				"updated": "20230903112601"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这是以 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "tini"
				},
				{
					"Type": "NodeText",
					"Data": "​ 为例制作镜像的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Dockerfile"
				},
				{
					"Type": "NodeText",
					"Data": "​ 示例:"
				}
			]
		},
		{
			"ID": "20230903112611-hbxf7y7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230903112611-hbxf7y7",
				"updated": "20230903112615"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "FROM ubuntu:22.04\nENV TINI_VERSION v0.19.0\nADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini\nCOPY entrypoint.sh /entrypoint.sh\nRUN chmod +x /tini /entrypoint.sh\nENTRYPOINT [\"/tini\", \"--\"]\nCMD [ \"/start.sh\" ]\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230903112632-8vasz0r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230903112632-8vasz0r",
				"updated": "20230903112632"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "start.sh"
				},
				{
					"Type": "NodeText",
					"Data": "​ 脚本示例:"
				}
			]
		},
		{
			"ID": "20230903112645-7rfgfpk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230903112645-7rfgfpk",
				"updated": "20230903112646"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#! /bin/bash\n/bin/app1 \u0026\n/bin/app2 \u0026\nwait\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230903112656-r0s2lbs",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230903112656-r0s2lbs",
				"updated": "20230903112722"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4. 参考资料"
				}
			]
		},
		{
			"ID": "20230903112736-y8owp94",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230903112736-y8owp94",
				"updated": "20230903112736"
			},
			"Children": [
				{
					"ID": "20230903112736-arrst1x",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230903112736-arrst1x",
						"updated": "20230903112736"
					},
					"Children": [
						{
							"ID": "20230903112736-hlicm1f",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230903112736-hlicm1f",
								"updated": "20230903112736"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86",
									"TextMarkTextContent": "Trapping signals in Docker containers"
								}
							]
						}
					]
				},
				{
					"ID": "20230903112736-7ai8b4e",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230903112736-7ai8b4e",
						"updated": "20230903112736"
					},
					"Children": [
						{
							"ID": "20230903112736-g85dt8e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230903112736-g85dt8e",
								"updated": "20230903112736"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.ctl.io/developers/blog/post/gracefully-stopping-docker-containers/",
									"TextMarkTextContent": "Gracefully Stopping Docker Containers"
								}
							]
						}
					]
				},
				{
					"ID": "20230903112736-ckanlb5",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230903112736-ckanlb5",
						"updated": "20230903112736"
					},
					"Children": [
						{
							"ID": "20230903112736-eq6fcg5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230903112736-eq6fcg5",
								"updated": "20230903112736"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://hynek.me/articles/docker-signals/",
									"TextMarkTextContent": "Why Your Dockerized Application Isn’t Receiving Signals"
								}
							]
						}
					]
				},
				{
					"ID": "20230903112736-nr5t209",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230903112736-nr5t209",
						"updated": "20230903112736"
					},
					"Children": [
						{
							"ID": "20230903112736-22eufq1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230903112736-22eufq1",
								"updated": "20230903112736"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://www.kaggle.com/residentmario/best-practices-for-propagating-signals-on-docker",
									"TextMarkTextContent": "Best practices for propagating signals on Docker"
								}
							]
						}
					]
				},
				{
					"ID": "20230903112736-27psfa6",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230903112736-27psfa6",
						"updated": "20230903112736"
					},
					"Children": [
						{
							"ID": "20230903112736-7bvy041",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230903112736-7bvy041",
								"updated": "20230903112736"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://aws.amazon.com/cn/blogs/containers/graceful-shutdowns-with-ecs/",
									"TextMarkTextContent": "Graceful shutdowns with ECS"
								}
							]
						}
					]
				}
			]
		}
	]
}