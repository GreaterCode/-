{
	"ID": "20230116161005-8lw502n",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230116161005-8lw502n",
		"title": "如何在 Kubernetes 中快速排查 Java JVM 故障问题",
		"updated": "20230116161005"
	},
	"Children": [
		{
			"ID": "20230116161005-rn8bug9",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230116161005-rn8bug9",
				"updated": "20230116161005"
			}
		},
		{
			"ID": "20230116161005-phhdwxj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-phhdwxj"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在我们日常的工作当中，通常应用都会采用Kubernetes进行容器化部署，但是总是会出现一些问题，例如，JVM堆小于Docker容器中设置的内存大小和Kubernetes的内存大小，但是还是会被OOMKilled。在此我们介绍一下K8s的OOMKilled的Exit Code编码。"
				}
			]
		},
		{
			"ID": "20230116161005-pokk1mz",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230116161005-pokk1mz"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Exit Code 137"
				}
			]
		},
		{
			"ID": "20230116161005-3iuyipu",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230116161005-3iuyipu"
			},
			"Children": [
				{
					"ID": "20230116161005-fwrsp3o",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-fwrsp3o"
					},
					"Children": [
						{
							"ID": "20230116161005-p6b9p5x",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-p6b9p5x"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "表明容器收到了 SIGKILL 信号，进程被杀掉，对应kill -9，引发SIGKILL的是docker kill。这可以由用户或由docker守护程序来发起，手动执行：docker kill"
								}
							]
						}
					]
				},
				{
					"ID": "20230116161005-gcujqol",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-gcujqol"
					},
					"Children": [
						{
							"ID": "20230116161005-esfvqqe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-esfvqqe"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "137比较常见，如果 pod 中的limit 资源设置较小，会运行内存不足导致 OOMKilled，此时state 中的 ”OOMKilled” 值为true，你可以在系统的dmesg -T 中看到OOM日志。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-zfb3ejn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230116161005-zfb3ejn"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为什么我设置的大小关系没有错，还会OOMKilled？"
				}
			]
		},
		{
			"ID": "20230116161005-fhyt5bm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-fhyt5bm"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为我的heap大小肯定是小于Docker容器以及Pod的大小的，为啥还是会出现OOMKilled？"
				}
			]
		},
		{
			"ID": "20230116161005-ah7q77j",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230116161005-ah7q77j"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原因分析"
				}
			]
		},
		{
			"ID": "20230116161005-zfbuj47",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-zfbuj47"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这种问题常发生在JDK8u131或者JDK9版本之后所出现在容器中运行JVM的问题：在大多数情况下，JVM将一般默认会采用宿主机Node节点的内存为Native VM空间（其中包含了堆空间、直接内存空间以及栈空间），而并非是是容器的空间为标准。"
				}
			]
		},
		{
			"ID": "20230116161005-28gls8y",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230116161005-28gls8y"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "例如在我的机器"
				}
			]
		},
		{
			"ID": "20230116161005-co0xfla",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-co0xfla"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "docker run -m 100MB openjdk:8u121 java -XshowSettings:vm -version\nVM settings:\n    Max. Heap Size (Estimated): 444.50M\n    Ergonomics Machine Class: server\n    Using VM: OpenJDK 64-Bit Server VM\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-wert8yt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-wert8yt"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以上的信息出现了矛盾，我们在运行的时候将容器内存设置为100MB，而-XshowSettings:vm打印出的JVM将最大堆大小为444M，如果按照这个内存进行分配内存的话很可能会导致节点主机在某个时候杀死我的JVM。"
				}
			]
		},
		{
			"ID": "20230116161005-akzsqw0",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230116161005-akzsqw0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如何解决此问题"
				}
			]
		},
		{
			"ID": "20230116161005-wbwwo75",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230116161005-wbwwo75"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "JVM 感知 cgroup 限制"
				}
			]
		},
		{
			"ID": "20230116161005-8v5dvbx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-8v5dvbx"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一种方法解决 JVM 内存超限的问题，这种方法可以让JVM自动感知 docker 容器的 cgroup 限制，从而动态的调整堆内存大小。JDK8u131在JDK9中有一个很好的特性，即JVM能够检测在Docker容器中运行时有多少内存可用。为了使jvm保留根据容器规范的内存，必须设置标志-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap。"
				}
			]
		},
		{
			"ID": "20230116161005-i917o17",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230116161005-i917o17"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230116161005-fkkjyfw",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230116161005-fkkjyfw"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "注意：如果将这两个标志与Xms和Xmx标志一起设置，那么jvm的行为将是什么？-Xmx标志将覆盖-XX:+ UseCGroupMemoryLimitForHeap标志。"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-47pg66b",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230116161005-47pg66b"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总结一下"
				}
			]
		},
		{
			"ID": "20230116161005-1rw57t5",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230116161005-1rw57t5"
			},
			"Children": [
				{
					"ID": "20230116161005-5k7axnr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-5k7axnr"
					},
					"Children": [
						{
							"ID": "20230116161005-b0zahxa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-b0zahxa"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "标志-XX:+ UseCGroupMemoryLimitForHeap使JVM可以检测容器中的最大堆大小。"
								}
							]
						}
					]
				},
				{
					"ID": "20230116161005-bjot173",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-bjot173"
					},
					"Children": [
						{
							"ID": "20230116161005-9xc9ovb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-9xc9ovb"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "-Xmx标志将最大堆大小设置为固定大小。"
								}
							]
						}
					]
				},
				{
					"ID": "20230116161005-wwjgx3c",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-wwjgx3c"
					},
					"Children": [
						{
							"ID": "20230116161005-l5rvjad",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-l5rvjad"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "除了JVM的堆空间，还会对于非堆和jvm的东西，还会有一些额外的内存使用情况。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-5khdj13",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230116161005-5khdj13"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用JDK9的容器感知机制尝试"
				}
			]
		},
		{
			"ID": "20230116161005-x1h567i",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-x1h567i"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ docker run -m 100MB openjdk:8u131 java \\\n  -XX:+UnlockExperimentalVMOptions \\\n  -XX:+UseCGroupMemoryLimitForHeap \\\n  -XshowSettings:vm -version\nVM settings:\n    Max. Heap Size (Estimated): 44.50M\n    Ergonomics Machine Class: server\n    Using VM: OpenJDK 64-Bit Server VM\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-aaapcip",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-aaapcip"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以看出来通过内存感知之后，JVM能够检测到容器只有100MB，并将最大堆设置为44M。我们调整一下内存大小看看是否可以实现动态化调整和感知内存分配，如下所示。"
				}
			]
		},
		{
			"ID": "20230116161005-gd6ez20",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-gd6ez20"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "docker run -m 1GB openjdk:8u131 java \\\n  -XX:+UnlockExperimentalVMOptions \\\n  -XX:+UseCGroupMemoryLimitForHeap \\\n  -XshowSettings:vm -version\nVM settings:\n    Max. Heap Size (Estimated): 228.00M\n    Ergonomics Machine Class: server\n    Using VM: OpenJDK 64-Bit Server VM\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-r7nnm4c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-r7nnm4c"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们设置了容器有1GB内存分配，而JVM使用228M作为最大堆。因为容器中除了JVM之外没有其他进程在运行，所以我们还可以进一步扩大一下对于Heap堆的分配？"
				}
			]
		},
		{
			"ID": "20230116161005-nuaaznb",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-nuaaznb"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ docker run -m 1GB openjdk:8u131 java \\\n  -XX:+UnlockExperimentalVMOptions \\\n  -XX:+UseCGroupMemoryLimitForHeap \\\n  -XX:MaxRAMFraction=1 -XshowSettings:vm -version\nVM settings:\n    Max. Heap Size (Estimated): 910.50M\n    Ergonomics Machine Class: server\n    Using VM: OpenJDK 64-Bit Server VM\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-zo467tq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-zo467tq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在较低的版本的时候可以使用-XX:MaxRAMFraction参数，它告诉JVM使用可用内存/MaxRAMFract作为最大堆。使用-XX:MaxRAMFraction=1，我们将几乎所有可用内存用作最大堆。从上面的结果可以看出来内存分配已经可以达到了910.50M。"
				}
			]
		},
		{
			"ID": "20230116161005-ixh078q",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230116161005-ixh078q"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "问题分析"
				}
			]
		},
		{
			"ID": "20230116161005-vlh6j4a",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230116161005-vlh6j4a"
			},
			"Children": [
				{
					"ID": "20230116161005-no8d139",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230116161005-no8d139"
					},
					"Children": [
						{
							"ID": "20230116161005-mq13uz2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-mq13uz2"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最大堆占用总内存是否仍然会导致你的进程因为内存的其他部分（如“元空间”）而被杀死？"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-s81x6sm",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230116161005-s81x6sm"
			},
			"Children": [
				{
					"ID": "20230116161005-w8so3iq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-w8so3iq"
					},
					"Children": [
						{
							"ID": "20230116161005-k88a24p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-k88a24p"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "答案：MaxRAMFraction=1仍将为其他非堆内存留出一些空间。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-ri53z43",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230116161005-ri53z43"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230116161005-37ll122",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230116161005-37ll122"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "但如果容器使用堆外内存，这可能会有风险，因为几乎所有的容器内存都分配给了堆。您必须将-XX:MaxRAMFraction=2设置为堆只使用50%的容器内存，或者使用Xmx"
						},
						{
							"Type": "NodeText",
							"Data": " 。"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-uige611",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230116161005-uige611"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "容器内部感知CGroup资源限制"
				}
			]
		},
		{
			"ID": "20230116161005-telkojq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-telkojq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Docker1.7开始将容器cgroup信息挂载到容器中，所以应用可以从 /sys/fs/cgroup/memory/memory.limit_in_bytes 等文件获取内存、 CPU等设置，在容器的应用启动命令中根据Cgroup配置正确的资源设置 -Xmx, -XX:ParallelGCThreads等参数"
				}
			]
		},
		{
			"ID": "20230116161005-07pkbc2",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230116161005-07pkbc2"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在Java10中，改进了容器集成。"
				}
			]
		},
		{
			"ID": "20230116161005-4cltdff",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230116161005-4cltdff"
			},
			"Children": [
				{
					"ID": "20230116161005-k5mf8nm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-k5mf8nm"
					},
					"Children": [
						{
							"ID": "20230116161005-zyzcv4x",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-zyzcv4x"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Java10+废除了-XX:MaxRAM参数，因为JVM将正确检测该值。在Java10中，改进了容器集成。无需添加额外的标志，JVM将使用1/4的容器内存用于堆。"
								}
							]
						}
					]
				},
				{
					"ID": "20230116161005-rkuf683",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-rkuf683"
					},
					"Children": [
						{
							"ID": "20230116161005-2q63pt6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-2q63pt6"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "java10+确实正确地识别了内存的docker限制，但您可以使用新的标志MaxRAMPercentage（例如：-XX:MaxRAMPercentage=75）而不是旧的MaxRAMFraction，以便更精确地调整堆的大小，而不是其余的（堆栈、本机…）"
								}
							]
						}
					]
				},
				{
					"ID": "20230116161005-g69tzl6",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-g69tzl6"
					},
					"Children": [
						{
							"ID": "20230116161005-i8teftj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-i8teftj"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "java10+上的UseContainerSupport选项，而且是默认启用的，不用设置。同时 UseCGroupMemoryLimitForHeap 这个就弃用了，不建议继续使用，同时还可以通过 -XX:InitialRAMPercentage、-XX:MaxRAMPercentage、-XX:MinRAMPercentage 这些参数更加细腻的控制 JVM 使用的内存比率。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-qacx5p9",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230116161005-qacx5p9"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230116161005-bh1643p",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230116161005-bh1643p"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "Java 程序在运行时会调用外部进程、申请 Native Memory 等，所以即使是在容器中运行 Java 程序，也得预留一些内存给系统的。所以 -XX:MaxRAMPercentage 不能配置得太大。当然仍然可以使用-XX:MaxRAMFraction=1选项来压缩容器中的所有内存。"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-rqpqzej",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-rqpqzej"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面我们知道了如何进行设置和控制对应的堆内存和容器内存的之间的关系，所以防止JVM的堆内存超过了容器内存，导致容器出现OOMKilled的情况。但是在整个JVM进程体系而言，不仅仅只包含了Heap堆内存，其实还有其他相关的内存存储空间是需要我们考虑的，一边防止这些内存空间会造成我们的容器内存溢出的场景，正如下图所示。"
				}
			]
		},
		{
			"ID": "20230116161005-m8yx4ul",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-m8yx4ul"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20230116161005-eoeargs"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-d5kp9v4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-d5kp9v4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接下来了我们需要进行分析出heap之外的一部分就是对外内存就是Off Heap Space，也就是Direct buffer memory堆外内存。主要通过的方式就是采用Unsafe方式进行申请内存，大多数场景也会通过Direct ByteBuffer方式进行获取。好废话不多说进入正题。"
				}
			]
		},
		{
			"ID": "20230116161005-7rk3odw",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230116161005-7rk3odw"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "JVM参数MaxDirectMemorySize"
				}
			]
		},
		{
			"ID": "20230116161005-n4yakq8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-n4yakq8"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们先研究一下jvm的-XX:MaxDirectMemorySize，该参数指定了DirectByteBuffer能分配的空间的限额，如果没有显示指定这个参数启动jvm，默认值是xmx对应的值（低版本是减去幸存区的大小）。"
				}
			]
		},
		{
			"ID": "20230116161005-4iasgi1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-4iasgi1"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "DirectByteBuffer对象是一种典型的”冰山对象”，在堆中存在少量的泄露的对象，但其下面连接用堆外内存，这种情况容易造成内存的大量使用而得不到释放"
				}
			]
		},
		{
			"ID": "20230116161005-75hawh5",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-75hawh5"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "-XX:MaxDirectMemorySize\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-2o9vb41",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-2o9vb41"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "-XX:MaxDirectMemorySize=size 用于设置 New I/O (java.nio) direct-buffer allocations 的最大大小，size 的单位可以使用 k/K、m/M、g/G；如果没有设置该参数则默认值为 0，意味着JVM自己自动给NIO direct-buffer allocations选择最大大小。"
				}
			]
		},
		{
			"ID": "20230116161005-d6fwyi5",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230116161005-d6fwyi5"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "-XX:MaxDirectMemorySize的默认值是什么？"
				}
			]
		},
		{
			"ID": "20230116161005-bgegxlf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-bgegxlf"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在sun.misc.VM中，它是Runtime.getRuntime.maxMemory()，这就是使用-Xmx配置的内容。而对应的JVM参数如何传递给JVM底层的呢？主要通过的是hotspot/share/prims/jvm.cpp。我们来看一下jvm.cpp的JVM源码来分一下。"
				}
			]
		},
		{
			"ID": "20230116161005-oleixa9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-oleixa9"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "  // Convert the -XX:MaxDirectMemorySize= command line flag\n  // to the sun.nio.MaxDirectMemorySize property.\n  // Do this after setting user properties to prevent people\n  // from setting the value with a -D option, as requested.\n  // Leave empty if not supplied\n  if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {\n    char as_chars[256];\n    jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);\n    Handle key_str = java_lang_String::create_from_platform_dependent_str(\"sun.nio.MaxDirectMemorySize\", CHECK_NULL);\n    Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);\n    result_h-\u003eobj_at_put(ndx * 2,  key_str());\n    result_h-\u003eobj_at_put(ndx * 2 + 1, value_str());\n    ndx++;\n  }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-np1q9zv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-np1q9zv"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "jvm.cpp 里头有一段代码用于把 - XX:MaxDirectMemorySize 命令参数转换为 key 为 sun.nio.MaxDirectMemorySize的属性。我们可以看出来他转换为了该属性之后，进行设置和初始化直接内存的配置。针对于直接内存的核心类就在"
				}
			]
		},
		{
			"ID": "20230116161005-kphogqp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-kphogqp"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class VM {    // the init level when the VM is fully initialized\n    private static final int JAVA_LANG_SYSTEM_INITED     = 1;\n    private static final int MODULE_SYSTEM_INITED        = 2;\n    private static final int SYSTEM_LOADER_INITIALIZING  = 3;\n    private static final int SYSTEM_BOOTED               = 4;\n    private static final int SYSTEM_SHUTDOWN             = 5;    // 0, 1, 2, ...\n    private static volatile int initLevel;\n    private static final Object lock = new Object();    //......    // A user-settable upper limit on the maximum amount of allocatable direct\n    // buffer memory.  This value may be changed during VM initialization if\n    // \"java\" is launched with \"-XX:MaxDirectMemorySize=\u003csize\u003e\".\n    //\n    // The initial value of this field is arbitrary; during JRE initialization\n    // it will be reset to the value specified on the command line, if any,\n    // otherwise to Runtime.getRuntime().maxMemory().\n    //\n    private static long directMemory = 64 * 1024 * 1024;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-7sa9zf8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-7sa9zf8"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面可以看出来64MB最初是任意设置的。在-XX:MaxDirectMemorySize 是用来配置NIO direct memory上限用的VM参数。可以看一下JVM的这行代码。"
				}
			]
		},
		{
			"ID": "20230116161005-53eeppr",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-53eeppr"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "product(intx, MaxDirectMemorySize, -1,\n        \"Maximum total size of NIO direct-buffer allocations\")\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-s79n0vj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-s79n0vj"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但如果不配置它的话，direct memory默认最多能申请多少内存呢？这个参数默认值是-1，显然不是一个“有效值”。所以真正的默认值肯定是从别的地方来的。"
				}
			]
		},
		{
			"ID": "20230116161005-4il32wp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-4il32wp"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "    // Returns the maximum amount of allocatable direct buffer memory.\n    // The directMemory variable is initialized during system initialization\n    // in the saveAndRemoveProperties method.\n    //\n    public static long maxDirectMemory() {\n        return directMemory;\n    }    //......    // Save a private copy of the system properties and remove\n    // the system properties that are not intended for public access.\n    //\n    // This method can only be invoked during system initialization.\n    public static void saveProperties(Map\u003cString, String\u003e props) {\n        if (initLevel() != 0)\n            throw new IllegalStateException(\"Wrong init level\");        // only main thread is running at this time, so savedProps and\n        // its content will be correctly published to threads started later\n        if (savedProps == null) {\n            savedProps = props;\n        }        // Set the maximum amount of direct memory.  This value is controlled\n        // by the vm option -XX:MaxDirectMemorySize=\u003csize\u003e.\n        // The maximum amount of allocatable direct buffer memory (in bytes)\n        // from the system property sun.nio.MaxDirectMemorySize set by the VM.\n        // If not set or set to -1, the max memory will be used\n        // The system property will be removed.\n        String s = props.get(\"sun.nio.MaxDirectMemorySize\");\n        if (s == null || s.isEmpty() || s.equals(\"-1\")) {\n            // -XX:MaxDirectMemorySize not given, take default\n            directMemory = Runtime.getRuntime().maxMemory();\n        } else {\n            long l = Long.parseLong(s);\n            if (l \u003e -1)\n                directMemory = l;\n        }\n        // Check if direct buffers should be page aligned\n        s = props.get(\"sun.nio.PageAlignDirectMemory\");\n        if (\"true\".equals(s))\n            pageAlignDirectMemory = true;\n    }\n    //......\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-xzoxajz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-xzoxajz"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从上面的源码可以读取 sun.nio.MaxDirectMemorySize 属性，如果为 null 或者是空或者是 - 1，那么则设置为 Runtime.getRuntime ().maxMemory ()；如果有设置 MaxDirectMemorySize 且值大于 - 1，那么使用该值作为 directMemory 的值；而 VM 的 maxDirectMemory 方法则返回的是 directMemory 的值。"
				}
			]
		},
		{
			"ID": "20230116161005-x230j3n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-x230j3n"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为当MaxDirectMemorySize参数没被显式设置时它的值就是-1，在Java类库初始化时maxDirectMemory()被java.lang.System的静态构造器调用，走的路径就是这条："
				}
			]
		},
		{
			"ID": "20230116161005-qpd0x83",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-qpd0x83"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "if (s.equals(\"-1\")) {  \n    // -XX:MaxDirectMemorySize not given, take default  \n    directMemory = Runtime.getRuntime().maxMemory();  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-p62ggre",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-p62ggre"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而Runtime.maxMemory()在HotSpot VM里的实现是："
				}
			]
		},
		{
			"ID": "20230116161005-ok65rzl",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-ok65rzl"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))  \n  JVMWrapper(\"JVM_MaxMemory\");  \n  size_t n = Universe::heap()-\u003emax_capacity();  \n  return convert_size_t_to_jlong(n);  \nJVM_END  \n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-do7jpbg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-do7jpbg"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个max_capacity()实际返回的是 -Xmx减去一个survivor space的预留大小。"
				}
			]
		},
		{
			"ID": "20230116161005-xwoehus",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230116161005-xwoehus"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "结论分析说明"
				}
			]
		},
		{
			"ID": "20230116161005-4slz2x4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-4slz2x4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "MaxDirectMemorySize没显式配置的时候，NIO direct memory可申请的空间的上限就是-Xmx减去一个survivor space的预留大小。例如如果您不配置-XX:MaxDirectMemorySize并配置-Xmx5g，则\"默认\" MaxDirectMemorySize也将是5GB-survivor space区，并且应用程序的总堆+直接内存使用量可能会增长到5 + 5 = 10 Gb 。"
				}
			]
		},
		{
			"ID": "20230116161005-ka8ca20",
			"Type": "NodeHeading",
			"HeadingLevel": 5,
			"Properties": {
				"id": "20230116161005-ka8ca20"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其他获取 maxDirectMemory 的值的API方法"
				}
			]
		},
		{
			"ID": "20230116161005-a3ul3iy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-a3ul3iy"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "BufferPoolMXBean 及 JavaNioAccess.BufferPool (通过SharedSecrets获取) 的 getMemoryUsed 可以获取 direct memory 的大小；其中 java9 模块化之后，SharedSecrets 从原来的 sun.misc.SharedSecrets 变更到 java.base 模块下的 jdk.internal.access.SharedSecrets；要使用 --add-exports java.base/jdk.internal.access=ALL-UNNAMED 将其导出到 UNNAMED，这样才可以运行"
				}
			]
		},
		{
			"ID": "20230116161005-wum3emz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230116161005-wum3emz"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public BufferPoolMXBean getDirectBufferPoolMBean(){\n        return ManagementFactory.getPlatformMXBeans(BufferPoolMXBean.class)\n                .stream()\n                .filter(e -\u003e e.getName().equals(\"direct\"))\n                .findFirst()\n                .orElseThrow();\n}\npublic JavaNioAccess.BufferPool getNioBufferPool(){\n     return SharedSecrets.getJavaNioAccess().getDirectBufferPool();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230116161005-c4ih8rg",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230116161005-c4ih8rg"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "内存分析问题"
				}
			]
		},
		{
			"ID": "20230116161005-2qrwxr1",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230116161005-2qrwxr1"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "-XX:+DisableExplicitGC 与 NIO的direct memory"
				}
			]
		},
		{
			"ID": "20230116161005-dm3mwmk",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230116161005-dm3mwmk"
			},
			"Children": [
				{
					"ID": "20230116161005-isddgik",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-isddgik"
					},
					"Children": [
						{
							"ID": "20230116161005-dklsj3o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-dklsj3o"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "用了-XX:+DisableExplicitGC参数后，System.gc()的调用就会变成一个空调用，完全不会触发任何GC（但是“函数调用”本身的开销还是存在的哦～）。"
								}
							]
						}
					]
				},
				{
					"ID": "20230116161005-ecuzaho",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230116161005-ecuzaho"
					},
					"Children": [
						{
							"ID": "20230116161005-v2rijtv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230116161005-v2rijtv"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "做ygc的时候会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收了，但是无法对old里的DirectByteBuffer对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题，如果有大量的DirectByteBuffer对象移到了old，但是又一直没有做cms gc或者full gc，而只进行ygc，那么我们的物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多(前提是我们禁用了System.gc)。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-3t50sug",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230116161005-3t50sug"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230116161005-2gj9qri",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230116161005-2gj9qri"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "本文转载自：「掘金」，原文：https://url.hi-linux.com/fNVF2，版权归原作者所有。欢迎投稿，投稿邮箱: editor@hi-linux.com。"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-co7kd0f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-co7kd0f"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20230116161005-w39rbe9"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-5p87xvl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-5p87xvl"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最近，我们建立了一个 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "技术交流微信群"
				},
				{
					"Type": "NodeText",
					"Data": " 。目前群里已加入了不少行业内的大神，有兴趣的同学可以加入和我们一起交流技术，在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "「奇妙的 Linux 世界」"
				},
				{
					"Type": "NodeText",
					"Data": " 公众号直接回复 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "「加群」"
				},
				{
					"Type": "NodeText",
					"Data": " 邀请你入群。"
				}
			]
		},
		{
			"ID": "20230116161005-amakg7y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-amakg7y"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20230116161005-ai15uzo"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-37afevs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-37afevs"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "你可能还喜欢"
				}
			]
		},
		{
			"ID": "20230116161005-mfe5wg0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-mfe5wg0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "点击下方图片即可阅读"
				}
			]
		},
		{
			"ID": "20230116161005-047i99r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-047i99r"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20230116161005-ddhj4lt"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "http://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==\u0026mid=2247519544\u0026idx=1\u0026sn=a318a6c4ccd95abb2d8d165d9cf0eb49\u0026chksm=eac6ac11ddb12507ad0af7d86fcf853c8338b9376bb43d03a920a0ef16fb17507c98c62e59b7\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "http://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==\u0026amp;mid=2247519544\u0026amp;idx=1\u0026amp;sn=a318a6c4ccd95abb2d8d165d9cf0eb49\u0026amp;chksm=eac6ac11ddb12507ad0af7d86fcf853c8338b9376bb43d03a920a0ef16fb17507c98c62e59b7\u0026amp;scene=21#wechat_redirect"
				}
			]
		},
		{
			"ID": "20230116161005-lojmvrs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-lojmvrs"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "25+ Kafka 常用管理命令和脚本"
				}
			]
		},
		{
			"ID": "20230116161005-uv77xsq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-uv77xsq"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20230116161005-9dlwx7r"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "http://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==\u0026mid=2247497936\u0026idx=1\u0026sn=ec9442c73de91c5ab35dbd21dfbedcbd\u0026chksm=eac6d9f9ddb150ef9fc91129ab2b34d35ffef884a726fd90bc1fe9d4014456d910b3baa73afc\u0026scene=21#wechat_redirect",
					"TextMarkTextContent": "http://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==\u0026amp;mid=2247497936\u0026amp;idx=1\u0026amp;sn=ec9442c73de91c5ab35dbd21dfbedcbd\u0026amp;chksm=eac6d9f9ddb150ef9fc91129ab2b34d35ffef884a726fd90bc1fe9d4014456d910b3baa73afc\u0026amp;scene=21#wechat_redirect"
				},
				{
					"Type": "NodeText",
					"Data": "\n点击上方图片，『美团|饿了么』外卖红包天天免费领"
				}
			]
		},
		{
			"ID": "20230116161005-xv63ajw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-xv63ajw"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "图片"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/640-20230116161005-8qf75gl"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20230116161005-57jnhxe",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230116161005-57jnhxe"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "更多有趣的互联网新鲜事，关注「奇妙的互联网」视频号全了解！"
				}
			]
		}
	]
}