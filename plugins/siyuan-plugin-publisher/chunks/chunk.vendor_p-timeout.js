class b extends Error{constructor(r){super(r),this.name="TimeoutError"}}class T extends Error{constructor(r){super(),this.name="AbortError",this.message=r}}const f=e=>globalThis.DOMException===void 0?new T(e):new DOMException(e),E=e=>{const r=e.reason===void 0?f("This operation was aborted."):e.reason;return r instanceof Error?r:f(r)};function h(e,r){const{milliseconds:o,fallback:l,message:i,customTimers:u={setTimeout,clearTimeout}}=r;let a;const c=new Promise((s,n)=>{if(typeof o!="number"||Math.sign(o)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${o}\``);if(r.signal){const{signal:t}=r;t.aborted&&n(E(t));const m=()=>{n(E(t))};t.addEventListener("abort",m,{once:!0}),e.finally(()=>{t.removeEventListener("abort",m)})}if(o===Number.POSITIVE_INFINITY){e.then(s,n);return}const d=new b;a=u.setTimeout.call(void 0,()=>{if(l){try{s(l())}catch(t){n(t)}return}typeof e.cancel=="function"&&e.cancel(),i===!1?s():i instanceof Error?n(i):(d.message=i??`Promise timed out after ${o} milliseconds`,n(d))},o),(async()=>{try{s(await e)}catch(t){n(t)}})()}).finally(()=>{c.clear()});return c.clear=()=>{u.clearTimeout.call(void 0,a),a=void 0},c}export{h as p};
