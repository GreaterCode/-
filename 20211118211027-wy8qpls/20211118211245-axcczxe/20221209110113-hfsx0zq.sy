{
	"ID": "20221209110113-hfsx0zq",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20221209110113-hfsx0zq",
		"title": "strings包",
		"updated": "20221209153110"
	},
	"Children": [
		{
			"ID": "20221209110113-qvz0yl2",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209110113-qvz0yl2",
				"updated": "20221209110211"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. 子串"
				}
			]
		},
		{
			"ID": "20221209110218-311j0d9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209110218-311j0d9",
				"updated": "20221209110333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "是否存在某个字符或子串\n // 子串substr在s中，返回true\n func Contains(s, substr string) bool\n\n // chars中任何一个Unicode代码点在s中，返回true\n func ContainsAny(s, chars string) bool\n\n // Unicode代码点r在s中，返回true\n func ContainsRune(s string, r rune) bool\n\n示例代码：ContainsAny 函数说明\n\nfmt.Println(strings.ContainsAny(\"team\", \"i\"))              //false\nfmt.Println(strings.ContainsAny(\"failure\", \"u \u0026 i\"))       //true\nfmt.Println(strings.ContainsAny(\"in failure\", \"s g\"))      //true\nfmt.Println(strings.ContainsAny(\"foo\", \"\"))                //false\nfmt.Println(strings.ContainsAny(\"\", \"\"))                   //false\n第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回true。\n\n上述三个函数的源码都是调用函数Index(子串出现的位置函数)，然后和0比较返回true或false。如，contains函数：\n\nfunc Contains(s, substr string) bool {\n     return Index(s, substr) \u003e= 0\n }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209110257-w7ylf3r",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209110257-w7ylf3r",
				"updated": "20221209110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2. 字符或子串在字符串中出现的位置"
				}
			]
		},
		{
			"ID": "20221209110947-pr8aeal",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209110947-pr8aeal",
				"updated": "20221209111325"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " //子串sep在字符串s中第一次出现的索引值，不在的话返回-1.\n func Index(s, sep string) int\n\n //chars中任何一个Unicode代码点在s中首次出现的位置，不存在返回-1\n func IndexAny(s, chars string) int\n\n //查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true\n func IndexFunc(s string, f func(rune) bool) int   //rune类型是int32别名，UTF-8字符格式编码。\n\n //返回字符c在s中第一次出现的位置\n func IndexByte(s string, c byte) int   //byte是字节类型\n\n // Unicode 代码点 r 在 s 中第一次出现的位置\n func IndexRune(s string, r rune) int\n\n //查找最后一次出现的位置\n func LastIndex(s, sep string) int\n func LastIndexByte(s string, c byte) int\n func LastIndexAny(s, chars string) int\n func LastIndexFunc(s string, f func(rune) bool) int\n\n 示例：IndexFunc 的例子。\nfmt.Printf(\"%d\\n\", strings.IndexFunc(\"studygolang\", func(c rune) bool {\n     if c \u003e 'u' {\n         return true\n     }\n     return false\n }))      //输出：4    匿名函数传递  因为 y 的 Unicode 代码点大于 u 的代码点。带入匿名函数进行比较\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209111330-9pme4zz",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209111330-9pme4zz",
				"updated": "20221209111331"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.子串出现次数"
				}
			]
		},
		{
			"ID": "20221209111337-q85rjfm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209111337-q85rjfm",
				"updated": "20221209111354"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " func Count(s, sep string) int   //子串在s字符串中出现的次数\n(1) 特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1\n(2) Count 是计算子串在字符串中出现的无重叠的次数\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209111439-2spy8cy",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209111439-2spy8cy",
				"updated": "20221209111448"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4. 字符串是否有某个前缀或后缀"
				}
			]
		},
		{
			"ID": "20221209111459-z8l3etp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209111459-z8l3etp",
				"updated": "20221209111612"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// s 中是否以 prefix 开始\n func HasPrefix(s, prefix string) bool {\n     return len(s) \u003e= len(prefix) \u0026\u0026 s[0:len(prefix)]== prefix\n }\n // s 中是否以 suffix 结尾\n func HasSuffix(s, suffix string) bool {\n     return len(s) \u003e= len(suffix) \u0026\u0026 s[len(s)-len(suffix):] == suffix\n }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209111628-h9wwwch",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209111628-h9wwwch",
				"updated": "20221209112008"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5. 子符串转换"
				}
			]
		},
		{
			"ID": "20221209112009-f2mwgh0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209112009-f2mwgh0",
				"updated": "20221209112032"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "func ToUpper(s string) string\nfunc ToLower(s string) string\nfunc ToTitle(s string) string\n\nfunc ToUpperSpecial(_case unicode.SpecialCase, s string) string\nfunc ToLowerSpecial(_case unicode.SpecialCase, s string) string\nfunc ToTitleSpecial(_case unicode.SpecialCase, s string) string\n\nfunc Title(s string) string\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209112051-c9rw934",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209112051-c9rw934",
				"updated": "20221209112100"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6. 比较"
				}
			]
		},
		{
			"ID": "20221209112111-36vcuzh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209112111-36vcuzh",
				"updated": "20221209112114"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "func Compare(a, b string) int  //返回不相等-1或者  相等0\n\nfunc EqualFold(s, t string) bool\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209112116-u61el4l",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209112116-u61el4l",
				"updated": "20221209112126"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7. 清理"
				}
			]
		},
		{
			"ID": "20221209112137-88gc70s",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209112137-88gc70s",
				"updated": "20221209112151"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "func Trim(s string, cutset string) string                 //去除字符串的头尾子字符串\nfunc TrimLeft(s string, cutset string) string\nfunc TrimRight(s string, cutset string) string\n\nfunc TrimFunc(s string, f func(rune) bool) string         //函数\nfunc TrimLeftFunc(s string, f func(rune) bool) string\nfunc TrimRightFunc(s string, f func(rune) bool) string\n\nfunc TrimSpace(s string) string //字符串前后空格  fmt.Println(strings.TrimSpace(\" \\t\\n a lone gopher \\n\\t\\r\\n\"))  输出：a lone gopher\n\nfunc TrimPrefix(s, prefix string) string\n func TrimSuffix(s, suffix string) string\n 代码示例：\n\nfunc main(){\n     var s = \"aaasddfgaaaa\"\n\n    fun := func (c rune) bool {\n         if c != 'a'{\n             return false\n         }\n         return true\n     }\n     fmt.Println(strings.TrimFunc(s, fun))   //输出   sddfg\n }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209112253-zag5hg5",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209112253-zag5hg5",
				"updated": "20221209112307"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "8. 折合函数"
				}
			]
		},
		{
			"ID": "20221209112307-g8cmc79",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209112307-g8cmc79",
				"updated": "20221209112544"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " func Fields(s string) []string\n func FieldsFunc(s string, f func(rune) bool) []string\n Fields 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）。如果字符串 s 只包含空格，则返回空列表([]string的长度为0）。其中，空格的定义是 unicode.IsSpace，之前已经介绍过。\n\n由于是用空格分隔，因此结果中不会含有空格或空子字符串。\n\nFieldsFunc 用这样的Unicode代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回[]string。如果字符串 s 中所有的代码点(unicode code points)都满足f(c)或者 s 是空，则 FieldsFunc 返回空slice。也就是说，我们可以通过实现一个回调函数来指定分隔字符串 s 的字符。\n\n示例：\nfmt.Printf(\"Fields are: %q\", strings.Fields(\"  foo bar  baz   \"))\nfmt.Println(strings.FieldsFunc(\"  foo bar  baz   \", unicode.IsSpace))\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209112412-ca3bewz",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209112412-ca3bewz",
				"updated": "20221209152306"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "9. 字符串重复次数"
				}
			]
		},
		{
			"ID": "20221209152306-g9jcq99",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209152306-g9jcq99",
				"updated": "20221209152315"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " func Repeat(s string, count int) string\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209152320-bh8wo2w",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209152320-bh8wo2w",
				"updated": "20221209152326"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "10. 替换"
				}
			]
		},
		{
			"ID": "20221209152326-jffi8nr",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209152326-jffi8nr",
				"updated": "20221209152340"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": " 用 new 替换 s 中的 old，一共替换 n 个。\n // 如果 n \u003c 0，则不限制替换次数，即全部替换\n func Replace(s, old, new string, n int) string\n func Map(mapping func(rune) rune, s string) string   //满足函数实现的进行替换\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209152432-cyoj7xa",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209152432-cyoj7xa",
				"updated": "20221209152443"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "11. split"
				}
			]
		},
		{
			"ID": "20221209152455-wpr40jb",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209152455-wpr40jb",
				"updated": "20221209152552"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }\nfunc SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }\nfunc SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }\nfunc SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) }\n\n它们都调用了 genSplit 函数。\n这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(\"abc\",\"\")，得到的是[a b c]。\n\nSplit(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。\n\n那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了：\n\nfmt.Printf(\"%q\\n\", strings.Split(\"foo,bar,baz\", \",\"))         //  [\"foo\" \"bar\" \"baz\"]\n fmt.Printf(\"%q\\n\", strings.SplitAfter(\"foo,bar,baz\", \",\"))    //  [\"foo,\" \"bar,\" \"baz\"]\n 也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。\n\n带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n \u003c 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n \u003e 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如：\n\nfmt.Printf(\"%q\\n\", strings.SplitN(\"foo,bar,baz\", \",\", 2))     // [\"foo\" \"bar,baz\"]\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221209152852-x1kon8d",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221209152852-x1kon8d",
				"updated": "20221209152959"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "12. Reader"
				}
			]
		},
		{
			"ID": "20221209153000-13txia6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221209153000-13txia6",
				"updated": "20221209153110"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "XA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "func NewReader(s string) *Reader\n 该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。在后面学习了 bytes 包之后，可以知道 bytes.NewBufferString 有类似的功能，不过，如果只是为了读取，NewReader 会更高效。\n\nfunc (r *Reader) Read(b []byte) (n int, err error)\nfunc (r *Reader) ReadAt(b []byte, off int64) (n int, err error)\nfunc (r *Reader) WriteTo(w io.Writer) (n int64, err error)\nfunc (r *Reader) Seek(offset int64, whence int) (int64, error)\n\nfunc (r *Reader) ReadByte() (byte, error)\nfunc (r *Reader) UnreadByte() error\n\nfunc (r *Reader) ReadRune() (ch rune, size int, err error)\nfunc (r *Reader) UnreadRune() error\n\nfunc (r *Reader) Len() int\nfunc (r *Reader) Size() int64\nfunc (r *Reader) Reset(s string)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}