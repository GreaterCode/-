{
	"ID": "20230109164251-9qeneb7",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230109164251-9qeneb7",
		"title": "Go高阶16，go逃逸场景有哪些",
		"updated": "20230110084422"
	},
	"Children": [
		{
			"ID": "20230109164251-vok9szd",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230109164251-vok9szd"
			}
		},
		{
			"ID": "20230109164251-r240b0m",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230109164251-r240b0m"
			},
			"Children": [
				{
					"ID": "20230109164251-o44ba3r",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230109164251-o44ba3r"
					},
					"Children": [
						{
							"ID": "20230109164251-ppinrem",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-ppinrem"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://cloud.tencent.com/developer/article/1877008",
									"TextMarkTextContent": "https://cloud.tencent.com/developer/article/1877008"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-wvzp42y",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230109164251-wvzp42y"
			}
		},
		{
			"ID": "20230109164251-1fq8pic",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-1fq8pic"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "「逃逸分析」"
				},
				{
					"Type": "NodeText",
					"Data": " 就是程序运行时内存的分配位置(栈或堆)，是由编辑器来确定的，而非开发者。"
				}
			]
		},
		{
			"ID": "20230109164251-lb9svca",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-lb9svca"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "什么是栈"
				}
			]
		},
		{
			"ID": "20230109164251-qs442u4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-qs442u4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "栈只允许从线性表的同一端放入和取出数据，按照后进先出（LIFO，Last InFirst Out）的顺序，如下图："
				}
			]
		},
		{
			"ID": "20230109164251-gvax1c1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-gvax1c1"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/936ce3d86ff4079a5d8c73cd0e5f479f-20230109164251-yv21cjd.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-ihdqtc8",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-ihdqtc8"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "什么是堆"
				}
			]
		},
		{
			"ID": "20230109164251-xtktsqi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-xtktsqi"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于堆在内存中的分配，我们可以类比成一个房间，分配内存时，需要找一块足够装下家具的空间来摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化，如下图："
				}
			]
		},
		{
			"ID": "20230109164251-m1leq5o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-m1leq5o"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/84b2c139c4943f01213f1e6ab627161f-20230109164251-68w0loy.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-mzbdkon",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230109164251-mzbdkon"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230109164251-t7qjoq6",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230109164251-t7qjoq6"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "❝对比栈和堆可知，在编译时，一切无法确定大小或大小可以改变的数据，最好放到堆上，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。\n❞"
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-uzn1lgs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-uzn1lgs"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "函数中申请一个新的对象："
				}
			]
		},
		{
			"ID": "20230109164251-vv2f9fv",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230109164251-vv2f9fv"
			},
			"Children": [
				{
					"ID": "20230109164251-112o5yf",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230109164251-112o5yf"
					},
					"Children": [
						{
							"ID": "20230109164251-29bgrvu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-29bgrvu"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果分配在栈中，则函数执行结束可自动将内存回收；"
								}
							]
						}
					]
				},
				{
					"ID": "20230109164251-k4yqkyo",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230109164251-k4yqkyo"
					},
					"Children": [
						{
							"ID": "20230109164251-ods2e7x",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-ods2e7x"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-sx61q13",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-sx61q13"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "逃逸分析的好处应该是减少了 gc 的压力，栈的分配比堆快，性能好，如果变量都分配到栈上，可以避免 Go 频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销。"
				}
			]
		},
		{
			"ID": "20230109164251-xag0fwx",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-xag0fwx"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "逃逸分析基本原则"
				}
			]
		},
		{
			"ID": "20230109164251-g4clk2m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-g4clk2m"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "编译器会根据变量是否被外部引用来决定是否逃逸："
				}
			]
		},
		{
			"ID": "20230109164251-0x6fe4y",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230109164251-0x6fe4y"
			},
			"Children": [
				{
					"ID": "20230109164251-hu88m5c",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230109164251-hu88m5c"
					},
					"Children": [
						{
							"ID": "20230109164251-pqiws8e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-pqiws8e"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果函数外部没有引用，则优先放到栈中；"
								}
							]
						}
					]
				},
				{
					"ID": "20230109164251-wxw8b84",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230109164251-wxw8b84"
					},
					"Children": [
						{
							"ID": "20230109164251-k3c9qsi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-k3c9qsi"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果函数外部存在引用，则必定放到堆中;"
								}
							]
						}
					]
				},
				{
					"ID": "20230109164251-uyzlt2w",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230109164251-uyzlt2w"
					},
					"Children": [
						{
							"ID": "20230109164251-4uxx7wr",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-4uxx7wr"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果栈上放不开，则必定放到堆上;"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-1d5884w",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-1d5884w"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "逃逸场景"
				}
			]
		},
		{
			"ID": "20230109164251-d46umhe",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-d46umhe"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "指针逃逸"
				}
			]
		},
		{
			"ID": "20230109164251-9m8irj0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-9m8irj0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们知道Go可以返回局部变量指针，这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。"
				}
			]
		},
		{
			"ID": "20230109164251-ahgwde7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-ahgwde7"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\n\ntype Person struct {\n Name string\n Age  int\n}\n\nfunc PersonRegister(name string, age int) *Person {\n p := new(Person) //局部变量s逃逸到堆\n\n p.Name = name\n p.Age = age\n\n return p\n}\n\nfunc main() {\n PersonRegister(\"微客鸟窝\", 18)\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-o9fdarf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-o9fdarf"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "函数 PersonRegister() 内部 p 为局部变量，其值通过函数返回值返回， p 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。"
				}
			]
		},
		{
			"ID": "20230109164251-nsxl2pm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-nsxl2pm"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过编译参数"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "-gcflag=-m"
				},
				{
					"Type": "NodeText",
					"Data": "可以查看编译过程中的逃逸分析："
				}
			]
		},
		{
			"ID": "20230109164251-xudpl3p",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-xudpl3p"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ go build -gcflags=-m\n# ceshi\n.\\main.go:8:6: can inline PersonRegister\n.\\main.go:17:6: can inline main\n.\\main.go:18:16: inlining call to PersonRegister\n.\\main.go:8:21: leaking param: name\n.\\main.go:9:10: new(Person) escapes to heap\n.\\main.go:18:16: new(Person) does not escape\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-o3wxxe2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-o3wxxe2"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "代码第9行显示”escapes to heap”，表示该行内存分配发生了逃逸现象。"
				}
			]
		},
		{
			"ID": "20230109164251-qg8pthd",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-qg8pthd"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "栈空间不足逃逸"
				}
			]
		},
		{
			"ID": "20230109164251-jt5bq7l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-jt5bq7l"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\n\nfunc Slice() {\n s := make([]int, 1000, 1000)\n\n for index, _ := range s {\n  s[index] = index\n }\n}\n\nfunc main() {\n Slice()\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-otmt2ig",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-otmt2ig"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面代码 Slice() 函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。直接查看编译提示，如下："
				}
			]
		},
		{
			"ID": "20230109164251-gg07u5y",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-gg07u5y"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ go build -gcflags=-m\n# ceshi\n.\\main.go:11:6: can inline main\n.\\main.go:4:11: make([]int, 1000, 1000) does not escape\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-hgmz7ax",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-hgmz7ax"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "发现并没有发生逃逸。我们把切片长度扩大10倍再试试：\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "s := make([]int, 10000, 10000)"
				}
			]
		},
		{
			"ID": "20230109164251-sw3aibp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-sw3aibp"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ go build -gcflags=-m\n# ceshi\n.\\main.go:11:6: can inline main\n.\\main.go:4:11: make([]int, 10000, 10000) escapes to heap\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-aenchf7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-aenchf7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "发现当切片长度扩大到10000时就会逃逸。当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。"
				}
			]
		},
		{
			"ID": "20230109164251-xtj6ql1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-xtj6ql1"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "动态类型逃逸"
				}
			]
		},
		{
			"ID": "20230109164251-newqgct",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-newqgct"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Go 中，空接口 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。"
				}
			]
		},
		{
			"ID": "20230109164251-ka7wf7t",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-ka7wf7t"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\nimport \"fmt\"\n\nfunc main() {\n s := \"wekenw\"\n fmt.Println(s)\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-ugd2ovz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-ugd2ovz"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为 fmt.Println() 的参数类型定义为 interface{}，因此也发生了逃逸。"
				}
			]
		},
		{
			"ID": "20230109164251-5787bp3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-5787bp3"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ go build -gcflags=-m\n# ceshi\n.\\main.go:6:13: inlining call to fmt.Println\n.\\main.go:6:13: s escapes to heap\n.\\main.go:6:13: []interface {}{...} does not escape\n\u003cautogenerated\u003e:1: .this does not escape\n\u003cautogenerated\u003e:1: .this does not escape\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-dvu8f0p",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-dvu8f0p"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "闭包引用对象逃逸"
				}
			]
		},
		{
			"ID": "20230109164251-lopya8i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-lopya8i"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "回Fibonacci数列的函数："
				}
			]
		},
		{
			"ID": "20230109164251-6wthw88",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-6wthw88"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "package main\n\nfunc main() {\n f := fibonacci()\n for i := 0; i \u003c 10; i++ {\n  f()\n }\n}\nfunc fibonacci() func() int {\n a, b := 0, 1\n return func() int {\n  a, b = b, a+b\n  return a\n }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-xu4f90t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-xu4f90t"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸："
				}
			]
		},
		{
			"ID": "20230109164251-99kfiro",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230109164251-99kfiro"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YXNjcmlwdA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ go build -gcflags=-m\n# ceshi\n.\\main.go:11:9: can inline fibonacci.func1\n.\\main.go:10:2: moved to heap: a\n.\\main.go:10:5: moved to heap: b\n.\\main.go:11:9: func literal escapes to heap\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230109164251-psmnze5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-psmnze5"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "总结"
				}
			]
		},
		{
			"ID": "20230109164251-x4vo6kh",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230109164251-x4vo6kh"
			},
			"Children": [
				{
					"ID": "20230109164251-c4ry2v8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230109164251-c4ry2v8"
					},
					"Children": [
						{
							"ID": "20230109164251-cnn3vwq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-cnn3vwq"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "栈上分配内存比在堆中分配内存效率更高"
								}
							]
						}
					]
				},
				{
					"ID": "20230109164251-l2xs91p",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230109164251-l2xs91p"
					},
					"Children": [
						{
							"ID": "20230109164251-19eaza7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-19eaza7"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "栈上分配的内存不需要 GC 处理，而堆需要"
								}
							]
						}
					]
				},
				{
					"ID": "20230109164251-3azgc0b",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230109164251-3azgc0b"
					},
					"Children": [
						{
							"ID": "20230109164251-jvppwu8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-jvppwu8"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "逃逸分析目的是决定内分配地址是栈还是堆"
								}
							]
						}
					]
				},
				{
					"ID": "20230109164251-zfr4x1r",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230109164251-zfr4x1r"
					},
					"Children": [
						{
							"ID": "20230109164251-ntvtdaj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230109164251-ntvtdaj"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "逃逸分析在编译阶段完成"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-071x7x3",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230109164251-071x7x3"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "传值 VS 传指针"
				}
			]
		},
		{
			"ID": "20230109164251-avohx3a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-avohx3a"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "「函数传递指针真的比传值效率高吗？如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，增加垃圾回收(GC)的负担，所以传递指针不一定 是高效的。」"
				}
			]
		},
		{
			"ID": "20230109164251-ofz3un8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-ofz3un8"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "图片及部分相关技术知识点来源于网络搜索，侵权删！"
				}
			]
		},
		{
			"ID": "20230109164251-ziov5um",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-ziov5um"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "参考文档："
				}
			]
		},
		{
			"ID": "20230109164251-16glx4v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-16glx4v"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "http://c.biancheng.net/view/22.html"
				}
			]
		},
		{
			"ID": "20230109164251-b1bmjlu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-b1bmjlu"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "https://www.cnblogs.com/iQXQZX/p/14032884.html"
				}
			]
		},
		{
			"ID": "20230109164251-si2jox1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-si2jox1"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "https://geektutu.com/post/hpg-escape-analysis.html"
				}
			]
		},
		{
			"ID": "20230109164251-5pp7u8o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-5pp7u8o"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "《GO专家编程》"
				}
			]
		},
		{
			"ID": "20230109164251-xn3982x",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20230109164251-xn3982x"
			}
		},
		{
			"ID": "20230109164251-npod1ra",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-npod1ra"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 有什么问题，可以公众号内回复或加我微信交流。"
				}
			]
		},
		{
			"ID": "20230109164251-t8yxxca",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-t8yxxca"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "文章分享自微信公众号："
				}
			]
		},
		{
			"ID": "20230109164251-aikjms6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-aikjms6"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://open.weixin.qq.com/qr/code?username=gh_9d0e3cf3d52d"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20230109164251-3ckr31h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-3ckr31h"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本文参与 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://cloud.tencent.com/developer/support-plan",
					"TextMarkTextContent": "腾讯云自媒体分享计划"
				},
				{
					"Type": "NodeText",
					"Data": " ，欢迎热爱写作的你一起参与！"
				}
			]
		},
		{
			"ID": "20230109164251-npilx84",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-npilx84"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如有侵权，请联系"
				}
			]
		},
		{
			"ID": "20230109164251-hfhrk98",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-hfhrk98"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "cloudcommunity@tencent.com"
				}
			]
		},
		{
			"ID": "20230109164251-cxou1mu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230109164251-cxou1mu"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 删除。"
				}
			]
		}
	]
}