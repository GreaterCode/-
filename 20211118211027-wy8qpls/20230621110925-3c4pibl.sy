{
	"ID": "20230621110925-3c4pibl",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230621110925-3c4pibl",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230621110925-goes3qh\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230621110925-oqdqakn\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230621110925-60tel2l\u0026quot;,\u0026quot;focusStart\u0026quot;:37,\u0026quot;focusEnd\u0026quot;:37}",
		"title": "40 个简单又有效的 Linux Shell 脚本示例！",
		"updated": "20230621110951"
	},
	"Children": [
		{
			"ID": "20230621110925-goes3qh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-goes3qh",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "历史上，shell 一直是类 Unix 系统的本地命令行解释器。它已被证明是 Unix 的主要功能之一，并发展成为一个全新的主题。Linux 提供了各种功能强大的 shell，包括 Bash、Zsh、Tcsh 和 Ksh。这些外壳最令人惊讶的特性之一是其可编程性。创建简单而有效的 Linux shell 脚本来处理日常工作非常容易。"
				}
			]
		},
		{
			"ID": "20230621110925-70srjdl",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-70srjdl",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.Hello World"
				}
			]
		},
		{
			"ID": "20230621110925-60tel2l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-60tel2l",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "程序员经常通过学习 hello world 程序来学习新语言。这是一个简单的程序，将字符串 “HelloWorld” 打印到标准输出中。然后，使用 vim 或 nano 等编辑器创建 hello-world.sh 文件，并将以下行复制到其中。"
				}
			]
		},
		{
			"ID": "20230621110925-vdpb4mu",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-vdpb4mu",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho \"Hello World\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-uqr2mx0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-uqr2mx0",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "保存并退出文件。接下来，您需要使用以下命令使该文件可执行。"
				}
			]
		},
		{
			"ID": "20230621110925-1mal4x4",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-1mal4x4",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ chmod a+x hello-world.sh\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-my2l00v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-my2l00v",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以使用以下两个命令中的任何一个来运行此命令。"
				}
			]
		},
		{
			"ID": "20230621110925-8ewu3t8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-8ewu3t8",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ bash hello-world.sh\n$ ./hello-world.sh\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-o87deyh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-o87deyh",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "它将打印出传递给脚本内部回显的字符串。"
				}
			]
		},
		{
			"ID": "20230621110925-mj25j8s",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-mj25j8s",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.使用 echo 打印"
				}
			]
		},
		{
			"ID": "20230621110925-62u6w2e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-62u6w2e",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "echo 命令用于在 bash 中打印信息。它类似于 C 函数 “printf”，并提供了许多常见选项，包括转义序列和重定向。将以下行复制到名为 echo.sh 的文件中，并使其可执行，如上所述。"
				}
			]
		},
		{
			"ID": "20230621110925-du3c54l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-du3c54l",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho \"Printing text\"\necho -n \"Printing text without newline\"\necho -e \"\\nRemoving \\t special \\t characters\\n\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-arohsop",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-arohsop",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "运行脚本以查看其功能。-e 选项用于告诉 echo 传递给它的字符串包含特殊字符，需要扩展功能。"
				}
			]
		},
		{
			"ID": "20230621110925-56k2ncf",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-56k2ncf",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3.使用注释"
				}
			]
		},
		{
			"ID": "20230621110925-lfvb8zs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-lfvb8zs",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注释对文档很有用，是高质量代码库的要求。将注释放在处理关键逻辑的代码中是一种常见的做法。要注释掉一行，只需在其前面使用 #（hash）字符。例如，请查看下面的 bash 脚本示例。"
				}
			]
		},
		{
			"ID": "20230621110925-rpjhop7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-rpjhop7",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\n# Adding two values\n((sum=25+35))#Print the result\necho $sum\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-kgffo1o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-kgffo1o",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此脚本将输出数字 60。首先，在某些行之前使用 #检查注释的使用方式。不过，第一行是一个例外。它被称为 shebang，让系统知道在运行这个脚本时要使用哪个解释器。"
				}
			]
		},
		{
			"ID": "20230621110925-r9umcud",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-r9umcud",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4.多行注释"
				}
			]
		},
		{
			"ID": "20230621110925-7qa99po",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-7qa99po",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "许多人使用多行注释来记录他们的 shell 脚本。在下一个名为 comment.sh 的脚本中检查这是如何完成的。"
				}
			]
		},
		{
			"ID": "20230621110925-jp6sumu",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-jp6sumu",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n: '\nThis script calculates\nthe square of 5.\n'\n((area=5*5))\necho $area\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-ipkgzwx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-ipkgzwx",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意多行注释是如何放置在内部的：“和” 字符。"
				}
			]
		},
		{
			"ID": "20230621110925-bowcwo2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-bowcwo2",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5.While 循环"
				}
			]
		},
		{
			"ID": "20230621110925-17lbmct",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-17lbmct",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "while 循环构造用于多次运行某些指令。查看以下名为 while.sh 的脚本，以更好地理解此概念。"
				}
			]
		},
		{
			"ID": "20230621110925-ftfr1zm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-ftfr1zm",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\ni=0while [ $i -le 2 ]\ndo\necho Number: $i\n((i++))\ndone因此，while 循环采用以下形式。while [ condition ]\ndo\ncommands 1\ncommands n\ndone\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-ws9exln",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-ws9exln",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "方括号周围的空格是必填的。"
				}
			]
		},
		{
			"ID": "20230621110925-d76nqra",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-d76nqra",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6.For 循环"
				}
			]
		},
		{
			"ID": "20230621110925-duh1mh0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-duh1mh0",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "for 循环是另一种广泛使用的 bashshell 构造，它允许用户高效地迭代代码。下面演示了一个简单的示例。"
				}
			]
		},
		{
			"ID": "20230621110925-0utc3gi",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-0utc3gi",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\nfor (( counter=1; counter\u003c=10; counter++ ))\ndo\necho -n \"$counter \"\ndoneprintf \"\\n\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-kw5hcil",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-kw5hcil",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7.接收用户输入"
				}
			]
		},
		{
			"ID": "20230621110925-2vyrw00",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-2vyrw00",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\necho -n \"Enter Something:\"\nread somethingecho \"You Entered: $something\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-21glsly",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-21glsly",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "8.If 语句"
				}
			]
		},
		{
			"ID": "20230621110925-ol48axv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-ol48axv",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "if CONDITION \nthen\nSTATEMENTS\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-6mwbups",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-6mwbups",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "只有当条件为真时，才会执行这些语句。fi 关键字用于标记 if 语句的结尾。下面显示了一个快速示例。"
				}
			]
		},
		{
			"ID": "20230621110925-83s0qi2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-83s0qi2",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003e #!/bin/bash\n\u003e echo -n \"Enter a number:\"\n\u003e read num\n\u003e if [[$num -gt 10]]\n\u003e then\n\u003e echo \"Number is greater than 10.\"\n\u003e fi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-0fghbv3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-0fghbv3",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果通过输入提供的数字大于 10，上述程序将仅显示输出。-gt 表示大于；类似地 - lt 表示小于 - le 表示小于等于；且 - ge 表示大于等于。此外，还需要 [[]]。"
				}
			]
		},
		{
			"ID": "20230621110925-7d6bk7g",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-7d6bk7g",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "9.使用 If Else 进行更多控制"
				}
			]
		},
		{
			"ID": "20230621110925-8ssrr3d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-8ssrr3d",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将 else 构造与 if 结合起来，可以更好地控制脚本的逻辑。下面显示了一个简单的示例。"
				}
			]
		},
		{
			"ID": "20230621110925-fgtdw1z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-fgtdw1z",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\nread n\nif [ $n -lt 10 ];\nthen\necho \"It is a one digit number\"\nelse\necho \"It is a two digit number\"\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-obi6xfh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-obi6xfh",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其他部分需要放在 if 的动作部分之后和 fi 之前。"
				}
			]
		},
		{
			"ID": "20230621110925-ggqoe2u",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-ggqoe2u",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "10.使用 AND 运算符"
				}
			]
		},
		{
			"ID": "20230621110925-xkvv5xm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-xkvv5xm",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "AND 运算符允许我们的程序检查是否同时满足多个条件。由 AND 运算符分隔的所有部分必须为 true。否则，包含 AND 的语句将返回 false。查看下面的 bash 脚本示例，以更好地了解 AND 的工作原理。"
				}
			]
		},
		{
			"ID": "20230621110925-w19u7zh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-w19u7zh",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\necho -n \"Enter Number:\"\nread numif [[ ( $num -lt 10 ) \u0026\u0026 ( $num%2 -eq 0 ) ]]; then\necho \"Even Number\"\nelse\necho \"Odd Number\"\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-nkccktv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-nkccktv",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "AND 运算符由 \u0026\u0026 符号表示。"
				}
			]
		},
		{
			"ID": "20230621110925-zicvth8",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-zicvth8",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "11.使用 OR 运算符"
				}
			]
		},
		{
			"ID": "20230621110925-qdqan6g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-qdqan6g",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "OR 运算符是另一个关键的构造，它允许我们在脚本中实现复杂、健壮的编程逻辑。与 AND 相反，当 OR 运算符的任一操作数为真时，由 OR 运算符组成的语句返回真。仅当由 OR 分隔的每个操作数为假时，它才返回假。"
				}
			]
		},
		{
			"ID": "20230621110925-7pvsl1r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-7pvsl1r",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\necho -n \"Enter any number:\"\nread nif [[ ( $n -eq 15 || $n -eq 45 ) ]]\nthen\necho \"You won\"\nelse\necho \"You lost!\"\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-cup76t7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-cup76t7",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个简单的示例演示了 OR 运算符如何在 Linuxshell 脚本中工作。只有当用户输入数字 15 或 45 时，它才会宣布用户为获胜者。|| 符号表示 OR 运算符。"
				}
			]
		},
		{
			"ID": "20230621110925-iu4j2gc",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-iu4j2gc",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "12.使用 El if"
				}
			]
		},
		{
			"ID": "20230621110925-uotl09o",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-uotl09o",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "elif 语句代表 else if，并为实现链逻辑提供了一种方便的方法。通过评估以下示例，了解 elif 的工作原理。"
				}
			]
		},
		{
			"ID": "20230621110925-2nx38kv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-2nx38kv",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\necho -n \"Enter a number: \"\nread numif [[ $num -gt 10 ]]\nthen\necho \"Number is greater than 10.\"\nelif [[ $num -eq 10 ]]\nthen\necho \"Number is equal to 10.\"\nelse\necho \"Number is less than 10.\"\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-xrdkswy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-xrdkswy",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面的程序是不言自明的，所以我们不会逐行剖析它。相反，更改脚本中的变量名称和值等部分，以检查它们如何一起工作。"
				}
			]
		},
		{
			"ID": "20230621110925-eamf9ox",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-eamf9ox",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "13.case 条件"
				}
			]
		},
		{
			"ID": "20230621110925-ur42lnu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-ur42lnu",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": ". switch 构造是 Linux bash 脚本提供的另一个强大功能。它可以用于需要嵌套条件的地方，但不希望使用复杂的 if-else elif 链。看看下一个例子。"
				}
			]
		},
		{
			"ID": "20230621110925-mo0ozeu",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-mo0ozeu",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\necho -n \"Enter a number: \"\nread numcase $num in\n100)\necho \"Hundred!!\" ;;\n200)\necho \"Double Hundred!!\" ;;\n*)\necho \"Neither 100 nor 200\" ;;\nesac\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-o9omsqs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-o9omsqs",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "条件写在 case 和 esac 关键字之间。*）用于匹配除 100 和 200 以外的所有输入。"
				}
			]
		},
		{
			"ID": "20230621110925-xwnzhmj",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-xwnzhmj",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "14.命令行参数"
				}
			]
		},
		{
			"ID": "20230621110925-jaa9vo8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-jaa9vo8",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在许多情况下，直接从命令 shell 获取参数是有益的。下面的示例演示了如何在 bash 中执行此操作。"
				}
			]
		},
		{
			"ID": "20230621110925-anwwbc9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-anwwbc9",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho \"Total arguments : $#\"\necho \"First Argument = $1\"\necho \"Second Argument = $2\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-5iu2cw8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-5iu2cw8",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "运行此脚本时，在其名称后添加两个附加参数。我将其命名为 test.sh，调用过程概述如下。"
				}
			]
		},
		{
			"ID": "20230621110925-kiy9s69",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-kiy9s69",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ ./test.sh Hey Howdy\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-dd723qp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-dd723qp",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此，1、用于访问第一个参数；2、用于访问第二个参数，依此类推。最后，3、用于获取参数总数。"
				}
			]
		},
		{
			"ID": "20230621110925-od8ctu0",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-od8ctu0",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "15.使用名称获取参数"
				}
			]
		},
		{
			"ID": "20230621110925-56meow4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-56meow4",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的示例显示了如何获取带有名称的命令行参数。"
				}
			]
		},
		{
			"ID": "20230621110925-z7ak594",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-z7ak594",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\nfor arg in \"$@\"\ndo\nindex=$(echo $arg | cut -f1 -d=)\nval=$(echo $arg | cut -f2 -d=)\ncase $index in\nX) x=$val;;\nY) y=$val;;\n*)\nesac\ndone\n((result=x+y))\necho \"X+Y=$result\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-sla6iln",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-sla6iln",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将此脚本命名为 test.sh，并按如下所示调用它。"
				}
			]
		},
		{
			"ID": "20230621110925-g7kttpu",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-g7kttpu",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ ./test.sh X=44 Y=100\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-ynvg0m6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-ynvg0m6",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "它应该返回 X+Y=144。这里的参数存储在 “$@” 中，脚本使用 Linuxcut 命令获取它们。"
				}
			]
		},
		{
			"ID": "20230621110925-j2oqa01",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-j2oqa01",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "16.连接字符串"
				}
			]
		},
		{
			"ID": "20230621110925-yp8hxjz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-yp8hxjz",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "字符串处理对于广泛的现代 bash 脚本来说非常重要。值得庆幸的是，它在 bash 中更加舒适，并允许以更精确、简洁的方式实现这一点。请参见下面的示例，了解 bash 字符串连接。"
				}
			]
		},
		{
			"ID": "20230621110925-3crsjx3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-3crsjx3",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\nstring1=\"Ubuntu\"\nstring2=\"Pit\"\nstring=$string1$string2\necho \"$string is a great resource for Linux beginners.\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-wwtklx2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-wwtklx2",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "17.字符串截取"
				}
			]
		},
		{
			"ID": "20230621110925-y1ody58",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-y1ody58",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "与许多编程语言不同，bash 不提供任何用于剪切字符串部分的内置函数。然而，下面的示例演示了如何使用参数展开来实现这一点。"
				}
			]
		},
		{
			"ID": "20230621110925-1gqulws",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-1gqulws",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nStr=\"Learn Bash Commands from UbuntuPit\"\nsubStr=${Str:0:20}\necho $subStr\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-sk6wpp9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-sk6wpp9",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "该脚本应打印出 “学习 Bash 命令” 作为其输出。参数展开形式为 ${VAR_NAME:S:L}。这里，S 表示起始位置，L 表示长度。"
				}
			]
		},
		{
			"ID": "20230621110925-ro327b9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-ro327b9",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "18.使用 cut 做截取"
				}
			]
		},
		{
			"ID": "20230621110925-15exox0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-15exox0",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以在脚本中使用 Linux cut 命令来截取字符串的一部分，也就是子字符串。下一个示例显示了如何做到这一点。"
				}
			]
		},
		{
			"ID": "20230621110925-uy3g5ba",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-uy3g5ba",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nStr=\"Learn Bash Commands from UbuntuPit\"\n#subStr=${Str:0:20}subStr=$(echo $Str| cut -d ' ' -f 1-3)\necho $subStr\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-20o0fms",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-20o0fms",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "19.添加两个值"
				}
			]
		},
		{
			"ID": "20230621110925-x5rjmmi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-x5rjmmi",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Linux shell 脚本中执行算术运算非常容易。下面的示例演示了如何从用户接收两个数字作为输入并将它们相加。"
				}
			]
		},
		{
			"ID": "20230621110925-b0o3isv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-b0o3isv",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho -n \"Enter first number:\"\nread x\necho -n \"Enter second number:\"\nread y\n(( sum=x+y ))\necho \"The result of addition=$sum\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-rcvr60b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-rcvr60b",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如您所见，在 bash 中添加数字相当简单。"
				}
			]
		},
		{
			"ID": "20230621110925-wf1m9gl",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-wf1m9gl",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "20.添加多个值"
				}
			]
		},
		{
			"ID": "20230621110925-oqdqakn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-oqdqakn",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "您可以使用循环获取多个用户输入并将其添加到脚本中。以下示例显示了这一点。"
				}
			]
		},
		{
			"ID": "20230621110925-g5aq6ww",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-g5aq6ww",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nsum=0\nfor (( counter=1; counter\u003c5; counter++ ))\ndo\necho -n \"Enter Your Number:\"\nread n\n(( sum+=n ))\n#echo -n \"$counter \"\ndone\nprintf \"\\n\"\necho \"Result is: $sum\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-lhfn704",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-lhfn704",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是，省略 (()) 将导致字符串串联而不是相加。所以，在你的程序中检查类似的情况。"
				}
			]
		},
		{
			"ID": "20230621110925-1wjyccz",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-1wjyccz",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "21.Bash 中的函数"
				}
			]
		},
		{
			"ID": "20230621110925-t62zc27",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-t62zc27",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "与任何编程方言一样，函数在 Linux shell 脚本中扮演着重要角色。它们允许管理员创建自定义代码块以供频繁使用。下面的演示将概述函数如何在 Linux bash 脚本中工作。"
				}
			]
		},
		{
			"ID": "20230621110925-fn22o7e",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-fn22o7e",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nfunction Add()\n{\necho -n \"Enter a Number: \"\nread x\necho -n \"Enter another Number: \"\nread y\necho \"Adiition is: $(( x+y ))\"\n}Add\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-k4n60h2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-k4n60h2",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里我们像以前一样添加了两个数字。但在这里，我们使用了一个名为 Add 的函数来完成这项工作。因此，每当您需要再次添加时，只需调用此函数，而不必再次编写该部分。"
				}
			]
		},
		{
			"ID": "20230621110925-gcpc4h2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-gcpc4h2",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "22.具有返回值的函数"
				}
			]
		},
		{
			"ID": "20230621110925-usx799d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-usx799d",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最神奇的功能之一是允许数据从一个函数传递到另一个函数。它在各种场景中都很有用。查看下一个示例。"
				}
			]
		},
		{
			"ID": "20230621110925-skg5rfm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-skg5rfm",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\nfunction Greet() {str=\"Hello $name, what brings you to UbuntuPit.com?\"\necho $str\n}echo \"-\u003e what's your name?\"\nread nameval=$(Greet)\necho -e \"-\u003e $val\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-ngvr96i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-ngvr96i",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里，输出包含从 Greet（）函数接收的数据。"
				}
			]
		},
		{
			"ID": "20230621110925-w0fde5d",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-w0fde5d",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "23.从 Bash 脚本创建目录"
				}
			]
		},
		{
			"ID": "20230621110925-jhwyf1h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-jhwyf1h",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用 shell 脚本运行系统命令的能力使开发人员的工作效率大大提高。下面的简单示例将向您展示如何在 shell 脚本中创建目录。"
				}
			]
		},
		{
			"ID": "20230621110925-xduyj0i",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-xduyj0i",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho -n \"Enter directory name -\u003e\"\nread newdir\ncmd=\"mkdir $newdir\"\neval $cmd\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-2i6uuo2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-2i6uuo2",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "该脚本只需调用标准 shell 命令 mkdir，并在仔细查看时将目录名传递给它。这个程序应该在文件系统中创建一个目录。您还可以传递命令以在 backticks（“）内部执行，如下所示。"
				}
			]
		},
		{
			"ID": "20230621110925-5vxuhgt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-5vxuhgt",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "`mkdir $newdir`\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-d1tjjm7",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-d1tjjm7",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "24.确认存在后创建目录"
				}
			]
		},
		{
			"ID": "20230621110925-s0qgjll",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-s0qgjll",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果当前工作目录中已包含同名文件夹，则上述程序将无法运行。例如，下面的程序将检查是否存在名为 $dir 的文件夹，如果找不到，则只创建一个。"
				}
			]
		},
		{
			"ID": "20230621110925-e5lfz5l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-e5lfz5l",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho -n \"Enter directory name -\u003e\"\nread dir\nif [ -d \"$dir\" ]\nthen\necho \"Directory exists\"\nelse\n`mkdir $dir`\necho \"Directory created\"\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-6713nu0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-6713nu0",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用 eval 编写此程序以提高 bash 脚本编写技能。"
				}
			]
		},
		{
			"ID": "20230621110925-8eogjka",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-8eogjka",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "25.读取文件"
				}
			]
		},
		{
			"ID": "20230621110925-e75exjm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-e75exjm",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Bash 脚本允许用户非常有效地读取文件。下面的示例将展示如何使用 shell 脚本读取文件。首先，创建一个名为 editors.txt 的文件，其中包含以下内容。"
				}
			]
		},
		{
			"ID": "20230621110925-gz2td3b",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-gz2td3b",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "1. Vim \n2. Emacs \n3. ed \n4. nano \n5. Code\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-f3bbvb2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-f3bbvb2",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此脚本将输出上述 5 行中的每一行。"
				}
			]
		},
		{
			"ID": "20230621110925-glp3vow",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-glp3vow",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nfile='editors.txt'\nwhile read line; do\necho $line\ndone \u003c $file\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-8byjl1d",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-8byjl1d",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "26.删除文件"
				}
			]
		},
		{
			"ID": "20230621110925-qeunr41",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-qeunr41",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以下程序将演示如何在 Linux shell 脚本中删除文件。程序将首先要求用户提供文件名作为输入，如果文件名存在，则将其删除。Linux rm 命令在此处执行删除操作。"
				}
			]
		},
		{
			"ID": "20230621110925-8e52l3m",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-8e52l3m",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho -n \"Enter filename -\u003e\"\nread name\nrm -i $name\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-jif2a7r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-jif2a7r",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "让我们输入 editors.txt 作为文件名，并在要求确认时按 y。它应该删除该文件。"
				}
			]
		},
		{
			"ID": "20230621110925-10t6zfq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-10t6zfq",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "27.附加到文件"
				}
			]
		},
		{
			"ID": "20230621110925-4e2e59u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-4e2e59u",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的 shell 脚本示例将向您展示如何使用 bash 脚本将数据附加到文件系统上的文件。它向早期的 editors.txt 文件添加了一行。"
				}
			]
		},
		{
			"ID": "20230621110925-fgw9e2a",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-fgw9e2a",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho \"Before appending the file\"\ncat editors.txt\necho \"6. NotePad++\" \u003e\u003e editors.txt\necho \"After appending the file\"\ncat editors.txt\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-088jx82",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-088jx82",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在您应该注意到，我们直接从 Linux bash 脚本使用日常终端命令。"
				}
			]
		},
		{
			"ID": "20230621110925-5m5ohjc",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-5m5ohjc",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "28.测试文件存在"
				}
			]
		},
		{
			"ID": "20230621110925-qha66fk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-qha66fk",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下一个 shell 脚本示例显示如何检查 bash 程序中文件的存在。"
				}
			]
		},
		{
			"ID": "20230621110925-4hqaq09",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-4hqaq09",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nfilename=$1\nif [ -f \"$filename\" ]; then\necho \"File exists\"\nelse\necho \"File does not exist\"\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-6ypq4p8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-6ypq4p8",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们直接从命令行传递文件名作为参数。"
				}
			]
		},
		{
			"ID": "20230621110925-dev64fl",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-dev64fl",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "29.从 Shell 脚本发送邮件"
				}
			]
		},
		{
			"ID": "20230621110925-vlya1m6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-vlya1m6",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从 bash 脚本发送电子邮件非常简单。下面的简单示例将演示一种从 bash 应用程序执行此操作的方法。"
				}
			]
		},
		{
			"ID": "20230621110925-udvcjyr",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-udvcjyr",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nrecipient=”admin@example.com”\nsubject=”Greetings”\nmessage=”Welcome to UbuntuPit”\n`mail -s $subject $recipient \u003c\u003c\u003c $message`\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-dnkncuu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-dnkncuu",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "它将向收件人发送包含给定主题和消息的电子邮件。"
				}
			]
		},
		{
			"ID": "20230621110925-kzwxrlr",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-kzwxrlr",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "30.解析日期和时间"
				}
			]
		},
		{
			"ID": "20230621110925-l0l5hrg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-l0l5hrg",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下一个 bash 脚本示例将向您展示如何使用脚本处理日期和时间。同样，Linuxdate 命令用于获取必要的信息，我们的程序执行解析。"
				}
			]
		},
		{
			"ID": "20230621110925-22q5k9e",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-22q5k9e",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nyear=`date +%Y`\nmonth=`date +%m`\nday=`date +%d`\nhour=`date +%H`\nminute=`date +%M`\nsecond=`date +%S`\necho `date`\necho \"Current Date is: $day-$month-$year\"\necho \"Current Time is: $hour:$minute:$second\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-bi7u9a5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-bi7u9a5",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "运行此程序以了解其工作原理。此外，尝试从终端运行 date 命令。"
				}
			]
		},
		{
			"ID": "20230621110925-65iatja",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-65iatja",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "31.sleep 命令"
				}
			]
		},
		{
			"ID": "20230621110925-wwnirvc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-wwnirvc",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "sleep 命令允许 shell 脚本在指令之间暂停。它在许多场景中都很有用，例如执行系统级作业。下一个示例显示了 shell 脚本中的 sleep 命令。"
				}
			]
		},
		{
			"ID": "20230621110925-cu7ruel",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-cu7ruel",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho \"How long to wait?\"\nread time\nsleep $time\necho \"Waited for $time seconds!\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-vlzdqb6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-vlzdqb6",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "该程序暂停最后一条指令的执行，直到 $time 秒，在本例中，用户提供了这一点。"
				}
			]
		},
		{
			"ID": "20230621110925-3g8ngjd",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-3g8ngjd",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "32.wait 命令"
				}
			]
		},
		{
			"ID": "20230621110925-hy6kv7y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-hy6kv7y",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "wait 命令用于暂停 Linux bash 脚本中的系统进程。查看下面的示例，详细了解这在 bash 中的工作方式。"
				}
			]
		},
		{
			"ID": "20230621110925-eetytpi",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-eetytpi",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\necho \"Testing wait command\"\nsleep 5 \u0026\npid=$!\nkill $pid\nwait $pid\necho $pid was terminated.\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-s33k21d",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-s33k21d",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "33.显示上次更新的文件"
				}
			]
		},
		{
			"ID": "20230621110925-2td9ogf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-2td9ogf",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有时，您可能需要为某些操作查找最后更新的文件。下面的简单程序向我们展示了如何在 bash 中使用 awk 命令执行此操作。它将列出当前工作目录中最近更新或创建的文件。 #!/bin/bash"
				}
			]
		},
		{
			"ID": "20230621110925-94v5i3r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-94v5i3r",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "ls -lrt | grep ^- | awk 'END{print $NF}'\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-xbs58rn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-xbs58rn",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了简单起见，我们将避免在本示例中描述 awk 的功能。相反，您可以简单地复制此代码来完成任务。"
				}
			]
		},
		{
			"ID": "20230621110925-kl5b6m3",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-kl5b6m3",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "34.添加批处理扩展"
				}
			]
		},
		{
			"ID": "20230621110925-9ed8zy0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-9ed8zy0",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的示例将对目录中的所有文件应用自定义扩展名。创建一个新目录，并将一些文件放在其中以供演示。我的文件夹共有五个文件，每个文件名为 test，后跟（0-4）。我已将此脚本编程为在文件末尾添加（.UP）。您可以添加所需的任何扩展名。"
				}
			]
		},
		{
			"ID": "20230621110925-x16o7of",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-x16o7of",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\ndir=$1\nfor file in `ls $1/*`\ndo\nmv $file $file.UP\ndone\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-nqnx27d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-nqnx27d",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，不要从任何常规目录尝试此脚本；相反，请从测试目录运行此命令。此外，您需要提供文件的目录名作为命令行参数。对当前工作目录使用句点（.）。"
				}
			]
		},
		{
			"ID": "20230621110925-rcsqmtn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-rcsqmtn",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "35.打印文件或目录的数量"
				}
			]
		},
		{
			"ID": "20230621110925-xzo8cko",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-xzo8cko",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的 Linuxbash 脚本查找给定目录中存在的文件或文件夹的数量。它使用 Linux find 命令来执行此操作。首先，需要传递目录名以从命令行搜索文件。"
				}
			]
		},
		{
			"ID": "20230621110925-1pdduna",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-1pdduna",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\nif [ -d \"$@\" ]; then\necho \"Files found: $(find \"$@\" -type f | wc -l)\"\necho \"Folders found: $(find \"$@\" -type d | wc -l)\"\nelse\necho \"[ERROR] Please retry with another folder.\"\nexit 1\nfi\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-gd8puyl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-gd8puyl",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果指定的目录不可用或存在权限问题，程序将要求用户重试。"
				}
			]
		},
		{
			"ID": "20230621110925-dbgv04w",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-dbgv04w",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "36.清理日志文件"
				}
			]
		},
		{
			"ID": "20230621110925-ono46ik",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-ono46ik",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下一个简单的示例演示了在现实生活中使用 shell 脚本的简便方法。该程序只需删除 / var/log 目录中的所有日志文件。您可以更改保存此目录的变量以清理其他日志。"
				}
			]
		},
		{
			"ID": "20230621110925-6hpnryy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-6hpnryy",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nLOG_DIR=/var/log\ncd $LOG_DIRcat /dev/null \u003e messages\ncat /dev/null \u003e wtmp\necho \"Logs cleaned up.\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-b2a55xo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-b2a55xo",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "请记住以 root 身份运行此 Linuxshell 脚本。"
				}
			]
		},
		{
			"ID": "20230621110925-ir5m9yh",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-ir5m9yh",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "37.使用 Bash 备份脚本"
				}
			]
		},
		{
			"ID": "20230621110925-lrb6igr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-lrb6igr",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Shell 脚本提供了一种强大的方法来备份文件和目录。以下示例将备份过去 24 小时内修改的每个文件或目录。该程序使用 find 命令执行此操作。"
				}
			]
		},
		{
			"ID": "20230621110925-5fgpy63",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-5fgpy63",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\nBACKUPFILE=backup-$(date +%m-%d-%Y)\narchive=${1:-$BACKUPFILE}find . -mtime -1 -type f -print0 | xargs -0 tar rvf \"$archive.tar\"\necho \"Directory $PWD backed up in archive file \\\"$archive.tar.gz\\\".\"\nexit 0\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-mufc9xv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-mufc9xv",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "备份过程成功后，它将打印文件和目录的名称。"
				}
			]
		},
		{
			"ID": "20230621110925-k2mf887",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-k2mf887",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "38.检查你是否是 root 用户"
				}
			]
		},
		{
			"ID": "20230621110925-54ygb83",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-54ygb83",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的示例演示了通过 Linux bash 脚本快速确定用户是否为 root 用户的方法。"
				}
			]
		},
		{
			"ID": "20230621110925-2zzd02b",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-2zzd02b",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\nROOT_UID=0if [ \"$UID\" -eq \"$ROOT_UID\" ]\nthen\necho \"You are root.\"\nelse\necho \"You are not root\"\nfi\nexit 0\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-ppgextg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-ppgextg",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此脚本的输出取决于运行它的用户。它将根据 $UID 匹配根用户。"
				}
			]
		},
		{
			"ID": "20230621110925-rxjh36r",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-rxjh36r",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "39.从文件中删除重复行"
				}
			]
		},
		{
			"ID": "20230621110925-r6awkkx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-r6awkkx",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "文件处理需要相当长的时间，并在许多方面阻碍了管理员的工作效率。例如，在文件中搜索重复项可能会成为一项艰巨的任务。幸运的是，您可以使用一个简短的 shell 脚本来完成此操作。"
				}
			]
		},
		{
			"ID": "20230621110925-6gq8iv5",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-6gq8iv5",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#! /bin/sh\n\necho -n \"Enter Filename-\u003e \"\nread filename\nif [ -f \"$filename\" ]; then\nsort $filename | uniq | tee sorted.txt\nelse\necho \"No $filename in $pwd...try again\"\nfi\nexit 0\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-nfioslp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-nfioslp",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上面的脚本逐行遍历文件并删除所有重复的行。然后，它将新内容放入新文件，并保持原始文件的完整性。"
				}
			]
		},
		{
			"ID": "20230621110925-p2r0x5g",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230621110925-p2r0x5g",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "40.系统维护"
				}
			]
		},
		{
			"ID": "20230621110925-v6hnyz6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-v6hnyz6",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我经常使用一个小的 Linuxshell 脚本来升级我的系统，而不是手动升级。下面的简单 shell 脚本将向您展示如何做到这一点。"
				}
			]
		},
		{
			"ID": "20230621110925-g8wh2xp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230621110925-g8wh2xp",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#!/bin/bash\n\necho -e \"\\n$(date \"+%d-%m-%Y --- %T\") --- Starting work\\n\"apt-get update\napt-get -y upgradeapt-get -y autoremove\napt-get autocleanecho -e \"\\n$(date \"+%T\") \\t Script Terminated\"\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230621110925-trz7xbv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-trz7xbv",
				"updated": "20230621110925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "该脚本还处理不再需要的旧包。您需要使用 sudo 运行此脚本，否则它将无法正常工作。"
				}
			]
		},
		{
			"ID": "20230621110925-4m7xlsi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230621110925-4m7xlsi",
				"updated": "20230621110951"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​​"
				}
			]
		}
	]
}