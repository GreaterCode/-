{
	"ID": "20221220172504-ucozimh",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20221220172504-ucozimh",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20221220172504-kwxzlj4\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20221220172504-5vb4evz\u0026quot;,\u0026quot;scrollTop\u0026quot;:100,\u0026quot;focusId\u0026quot;:\u0026quot;20221220172504-kwxzlj4\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "kubectl 创建 Pod 背后到底发生了什么？",
		"updated": "20221220172714"
	},
	"Children": [
		{
			"ID": "20221220172504-kwxzlj4",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-kwxzlj4",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-tn9fuwy",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-tn9fuwy",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-hcvzjgh",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-hcvzjgh",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-zsv3iep",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-zsv3iep",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://icloudnative.io/posts/what-happens-when-k8s/#span-idinline-toc7span-%E6%80%BB%E7%BB%93",
									"TextMarkTextContent": "https://icloudnative.io/posts/what-happens-when-k8s/#span-idinline-toc7span-%E6%80%BB%E7%BB%93 - 云原生实验室 - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|云原生"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-nibjkw0",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-nibjkw0",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-uiczxy4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-uiczxy4",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "想象一下，如果我想将 nginx 部署到 Kubernetes 集群，我可能会在终端中输入类似这样的命令："
				}
			]
		},
		{
			"ID": "20221220172504-qvg5jux",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221220172504-qvg5jux",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "c2hlbGw="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ kubectl run --image=nginx --replicas=3\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221220172504-malxn79",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-malxn79",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后回车。几秒钟后，你就会看到三个 nginx pod 分布在所有的工作节点上。这一切就像变魔术一样，但你并不知道这一切的背后究竟发生了什么事情。"
				}
			]
		},
		{
			"ID": "20221220172504-p72no6h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-p72no6h",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Kubernetes 的神奇之处在于：它可以通过用户友好的 API 来处理跨基础架构的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "deployments"
				},
				{
					"Type": "NodeText",
					"Data": "，而背后的复杂性被隐藏在简单的抽象中。但为了充分理解它为我们提供的价值，我们需要理解它的内部原理。"
				}
			]
		},
		{
			"ID": "20221220172504-x3cq2bo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-x3cq2bo",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本指南将引导您理解从 client 到 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Kubelet"
				},
				{
					"Type": "NodeText",
					"Data": " 的请求的完整生命周期，必要时会通过源代码来说明背后发生了什么。"
				}
			]
		},
		{
			"ID": "20221220172504-atx98nc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-atx98nc",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这是一份可以在线修改的文档，如果你发现有什么可以改进或重写的，欢迎提供帮助！"
				}
			]
		},
		{
			"ID": "20221220172504-qtx7zwh",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-qtx7zwh",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. kubectl"
				}
			]
		},
		{
			"ID": "20221220172504-iej11ir",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-iej11ir",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-kh5ew2o",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-kh5ew2o",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "验证和生成器"
				}
			]
		},
		{
			"ID": "20221220172504-tdy1nwp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-tdy1nwp",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当敲下回车键以后，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kubectl"
				},
				{
					"Type": "NodeText",
					"Data": " 首先会执行一些客户端验证操作，以确保不合法的请求（例如，创建不支持的资源或使用格式错误的镜像名称）将会快速失败，也不会发送给 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kube-apiserver"
				},
				{
					"Type": "NodeText",
					"Data": "。通过减少不必要的负载来提高系统性能。"
				}
			]
		},
		{
			"ID": "20221220172504-ue6m64d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-ue6m64d",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "验证通过之后， kubectl 开始将发送给 kube-apiserver 的 HTTP 请求进行封装。"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kube-apiserver"
				},
				{
					"Type": "NodeText",
					"Data": " 与 etcd 进行通信，所有尝试访问或更改 Kubernetes 系统状态的请求都会通过 kube-apiserver 进行，kubectl 也不例外。kubectl 使用生成器（"
				}
			]
		},
		{
			"ID": "20221220172504-b0udcdw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-b0udcdw",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://kubernetes.io/docs/user-guide/kubectl-conventions/#generators",
					"TextMarkTextContent": "generators"
				},
				{
					"Type": "NodeText",
					"Data": "）来构造 HTTP 请求。生成器是一个用来处理序列化的抽象概念。"
				}
			]
		},
		{
			"ID": "20221220172504-stxdcuq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-stxdcuq",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kubectl run"
				},
				{
					"Type": "NodeText",
					"Data": " 不仅可以运行 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "deployment"
				},
				{
					"Type": "NodeText",
					"Data": "，还可以通过指定参数 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--generator"
				},
				{
					"Type": "NodeText",
					"Data": " 来部署其他多种资源类型。如果没有指定 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--generator"
				},
				{
					"Type": "NodeText",
					"Data": " 参数的值，kubectl 将会自动判断资源的类型。"
				}
			]
		},
		{
			"ID": "20221220172504-wxhdstd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-wxhdstd",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "例如，带有参数 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--restart-policy=Always"
				},
				{
					"Type": "NodeText",
					"Data": " 的资源将被部署为 Deployment，而带有参数 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--restart-policy=Never"
				},
				{
					"Type": "NodeText",
					"Data": " 的资源将被部署为 Pod。同时 kubectl 也会检查是否需要触发其他操作，例如记录命令（用来进行回滚或审计）。"
				}
			]
		},
		{
			"ID": "20221220172504-ykqg2lm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-ykqg2lm",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 kubectl 判断出要创建一个 Deployment 后，它将使用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "DeploymentV1Beta1"
				},
				{
					"Type": "NodeText",
					"Data": " 生成器从我们提供的参数中生成一个"
				}
			]
		},
		{
			"ID": "20221220172504-zvb74kw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-zvb74kw",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/run.go#L59",
					"TextMarkTextContent": "运行时对象"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221220172504-wesv76g",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-wesv76g",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "API 版本协商与 API 组"
				}
			]
		},
		{
			"ID": "20221220172504-1a51lky",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-1a51lky",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了更容易地消除字段或者重新组织资源结构，Kubernetes 支持多个 API 版本，每个版本都在不同的 API 路径下，例如 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "/api/v1"
				},
				{
					"Type": "NodeText",
					"Data": " 或者 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "/apis/extensions/v1beta1"
				},
				{
					"Type": "NodeText",
					"Data": "。不同的 API 版本表明不同的稳定性和支持级别，更详细的描述可以参考"
				}
			]
		},
		{
			"ID": "20221220172504-r9ajnxi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-r9ajnxi",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://k8smeetup.github.io/docs/reference/api-overview/",
					"TextMarkTextContent": "Kubernetes API 概述"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221220172504-7jcbim8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-7jcbim8",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "API 组旨在对类似资源进行分类，以便使得 Kubernetes API 更容易扩展。API 的组名在 REST 路径或者序列化对象的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "apiVersion"
				},
				{
					"Type": "NodeText",
					"Data": " 字段中指定。例如，Deployment 的 API 组名是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "apps"
				},
				{
					"Type": "NodeText",
					"Data": "，最新的 API 版本是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "v1beta2"
				},
				{
					"Type": "NodeText",
					"Data": "，这就是为什么你要在 Deployment manifests 顶部输入 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "apiVersion: apps/v1beta2"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221220172504-f9r83mn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-f9r83mn",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "kubectl 在生成运行时对象后，开始为它"
				}
			]
		},
		{
			"ID": "20221220172504-h874nk4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-h874nk4",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/cmd/run.go#L580-L597",
					"TextMarkTextContent": "找到适当的 API 组和 API 版本"
				},
				{
					"Type": "NodeText",
					"Data": "，然后"
				}
			]
		},
		{
			"ID": "20221220172504-bkyvluq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-bkyvluq",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/cmd/run.go#L598",
					"TextMarkTextContent": "组装成一个版本化客户端"
				},
				{
					"Type": "NodeText",
					"Data": "，该客户端知道资源的各种 REST 语义。该阶段被称为版本协商，kubectl 会扫描 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "remote API"
				},
				{
					"Type": "NodeText",
					"Data": " 上的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "/apis"
				},
				{
					"Type": "NodeText",
					"Data": " 路径来检索所有可能的 API 组。由于 kube-apiserver 在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "/apis"
				},
				{
					"Type": "NodeText",
					"Data": " 路径上公开了 OpenAPI 格式的规范文档， 因此客户端很容易找到合适的 API。"
				}
			]
		},
		{
			"ID": "20221220172504-k6xp21c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-k6xp21c",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了提高性能，kubectl"
				}
			]
		},
		{
			"ID": "20221220172504-r9ybhx4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-r9ybhx4",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/kubectl/cmd/util/factory_client_access.go#L117",
					"TextMarkTextContent": "将 OpenAPI 规范缓存"
				},
				{
					"Type": "NodeText",
					"Data": "到了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "~/.kube/cache"
				},
				{
					"Type": "NodeText",
					"Data": " 目录。如果你想了解 API 发现的过程，请尝试删除该目录并在运行 kubectl 命令时将 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "-v"
				},
				{
					"Type": "NodeText",
					"Data": " 参数的值设为最大值，然后你将会看到所有试图找到这些 API 版本的HTTP 请求。参考"
				}
			]
		},
		{
			"ID": "20221220172504-bhju3zq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-bhju3zq",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://k8smeetup.github.io/docs/reference/kubectl/cheatsheet/",
					"TextMarkTextContent": "kubectl 备忘单"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221220172504-1ysesq9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-1ysesq9",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最后一步才是真正地发送 HTTP 请求。一旦请求发送之后获得成功的响应，kubectl 将会根据所需的输出格式打印 success message。"
				}
			]
		},
		{
			"ID": "20221220172504-yn8oouk",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-yn8oouk",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "客户端身份认证"
				}
			]
		},
		{
			"ID": "20221220172504-dexz505",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-dexz505",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在发送 HTTP 请求之前还要进行客户端认证，这是之前没有提到的，现在可以来看一下。"
				}
			]
		},
		{
			"ID": "20221220172504-c1vu7wf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-c1vu7wf",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了能够成功发送请求，kubectl 需要先进行身份认证。用户凭证保存在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kubeconfig"
				},
				{
					"Type": "NodeText",
					"Data": " 文件中，kubectl 通过以下顺序来找到 kubeconfig 文件："
				}
			]
		},
		{
			"ID": "20221220172504-vbb095i",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-vbb095i",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-drxqlzb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-drxqlzb",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-4e1g3rf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-4e1g3rf",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果提供了 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "--kubeconfig"
								},
								{
									"Type": "NodeText",
									"Data": " 参数， kubectl 就使用 –kubeconfig 参数提供的 kubeconfig 文件。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-bifjm6w",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-bifjm6w",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-aexi5j8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-aexi5j8",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果没有提供 –kubeconfig 参数，但设置了环境变量 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "$KUBECONFIG"
								},
								{
									"Type": "NodeText",
									"Data": "，则使用该环境变量提供的 kubeconfig 文件。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-34tblpz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-34tblpz",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-tlyktf4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-tlyktf4",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 –kubeconfig 参数和环境变量 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "$KUBECONFIG"
								},
								{
									"Type": "NodeText",
									"Data": " 都没有提供，kubectl 就使用默认的 kubeconfig 文件 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "$HOME/.kube/config"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-erza0ox",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-erza0ox",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解析完 kubeconfig 文件后，kubectl 会确定当前要使用的上下文、当前指向的群集以及与当前用户关联的任何认证信息。如果用户提供了额外的参数（例如 –username），则优先使用这些参数覆盖 kubeconfig 中指定的值。一旦拿到这些信息之后， kubectl 就会把这些信息填充到将要发送的 HTTP 请求头中："
				}
			]
		},
		{
			"ID": "20221220172504-5vb4evz",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-5vb4evz",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-u76ui94",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-u76ui94",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-7hd6ocp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-7hd6ocp",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "x509 证书使用"
								}
							]
						},
						{
							"ID": "20221220172504-oomtp4u",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-oomtp4u",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/client-go/blob/82aa063804cf055e16e8911250f888bc216e8b61/rest/transport.go#L80-L89",
									"TextMarkTextContent": "tls.TLSConfig"
								},
								{
									"Type": "NodeText",
									"Data": " 发送（包括 CA 证书）。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-r67vg9o",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-r67vg9o",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-4uysyxf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-4uysyxf",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "bearer tokens"
								},
								{
									"Type": "NodeText",
									"Data": " 在 HTTP 请求头 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Authorization"
								},
								{
									"Type": "NodeText",
									"Data": " 中"
								}
							]
						},
						{
							"ID": "20221220172504-z2xl4nw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-z2xl4nw",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L314",
									"TextMarkTextContent": "发送"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-h4ghzu8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-h4ghzu8",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-jgrjpol",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-jgrjpol",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "用户名和密码通过 HTTP 基本认证"
								}
							]
						},
						{
							"ID": "20221220172504-89m1zcy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-89m1zcy",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/client-go/blob/c6f8cf2c47d21d55fa0df928291b2580544886c8/transport/round_trippers.go#L223",
									"TextMarkTextContent": "发送"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-u55ig5d",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-u55ig5d",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-7yy5tay",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-7yy5tay",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "OpenID"
								},
								{
									"Type": "NodeText",
									"Data": " 认证过程是由用户事先手动处理的，产生一个像 bearer token 一样被发送的 token。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-d8silz5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-d8silz5",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2. kube-apiserver"
				}
			]
		},
		{
			"ID": "20221220172504-xeb6ykx",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-xeb6ykx",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-aaevp96",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-aaevp96",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-yt33uh1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-yt33uh1",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://k8smeetup.github.io/docs/admin/authentication/",
					"TextMarkTextContent": "认证"
				}
			]
		},
		{
			"ID": "20221220172504-jyqzc0f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-jyqzc0f",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在我们的请求已经发送成功了，接下来将会发生什么？这时候就该 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kube-apiserver"
				},
				{
					"Type": "NodeText",
					"Data": " 闪亮登场了！kube-apiserver 是客户端和系统组件用来保存和检索集群状态的主要接口。为了执行相应的功能，kube-apiserver 需要能够验证请求者是合法的，这个过程被称为认证。"
				}
			]
		},
		{
			"ID": "20221220172504-suv9w7v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-suv9w7v",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么 apiserver 如何对请求进行认证呢？当 kube-apiserver 第一次启动时，它会查看用户提供的所有"
				}
			]
		},
		{
			"ID": "20221220172504-tsn1kf2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-tsn1kf2",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/",
					"TextMarkTextContent": "CLI 参数"
				},
				{
					"Type": "NodeText",
					"Data": "，并组合成一个合适的令牌列表。"
				}
			]
		},
		{
			"ID": "20221220172504-loc9qlc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-loc9qlc",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "举个例子 :"
				},
				{
					"Type": "NodeText",
					"Data": " 如果提供了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--client-ca-file"
				},
				{
					"Type": "NodeText",
					"Data": " 参数，则会将 x509 客户端证书认证添加到令牌列表中；如果提供了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--token-auth-file"
				},
				{
					"Type": "NodeText",
					"Data": " 参数，则会将 breaer token 添加到令牌列表中。"
				}
			]
		},
		{
			"ID": "20221220172504-lkigr63",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-lkigr63",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "每次收到请求时，apiserver 都会"
				}
			]
		},
		{
			"ID": "20221220172504-43hwkic",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-43hwkic",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/union/union.go#L54",
					"TextMarkTextContent": "通过令牌链进行认证，直到某一个认证成功为止"
				},
				{
					"Type": "NodeText",
					"Data": "："
				}
			]
		},
		{
			"ID": "20221220172504-e9ye5zm",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-e9ye5zm",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-6m6yszu",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-6m6yszu",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-gl9630o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-gl9630o",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/x509/x509.go#L60",
									"TextMarkTextContent": "x509 处理程序"
								},
								{
									"Type": "NodeText",
									"Data": "将验证 HTTP 请求是否是由 CA 根证书签名的 TLS 密钥进行编码的。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-2dujlky",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-2dujlky",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-lzeipss",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-lzeipss",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/pkg/authentication/request/bearertoken/bearertoken.go#L38",
									"TextMarkTextContent": "bearer token 处理程序"
								},
								{
									"Type": "NodeText",
									"Data": "将验证 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "--token-auth-file"
								},
								{
									"Type": "NodeText",
									"Data": " 参数提供的 token 文件是否存在。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-s4dsfwr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-s4dsfwr",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-4vqko3y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-4vqko3y",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/51bebaffa01be9dc28195140da276c2f39a10cd4/plugin/pkg/authenticator/request/basicauth/basicauth.go#L37",
									"TextMarkTextContent": "基本认证处理程序"
								},
								{
									"Type": "NodeText",
									"Data": "确保 HTTP 请求的基本认证凭证与本地的状态匹配。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-61onjm8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-61onjm8",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果"
				}
			]
		},
		{
			"ID": "20221220172504-9cqfgzd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-9cqfgzd",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/20bfbdf738a0643fe77ffd527b88034dcde1b8e3/pkg/authentication/request/union/union.go#L71",
					"TextMarkTextContent": "认证失败"
				},
				{
					"Type": "NodeText",
					"Data": "，则请求失败并返回相应的错误信息；如果验证成功，则将请求中的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Authorization"
				},
				{
					"Type": "NodeText",
					"Data": " 请求头删除，并"
				}
			]
		},
		{
			"ID": "20221220172504-xzd08aj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-xzd08aj",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authentication.go#L71-L75",
					"TextMarkTextContent": "将用户信息添加到"
				},
				{
					"Type": "NodeText",
					"Data": "其上下文中。这给后续的授权和准入控制器提供了访问之前建立的用户身份的能力。"
				}
			]
		},
		{
			"ID": "20221220172504-2gzcwfr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-2gzcwfr",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "OK，现在请求已经发送，并且 kube-apiserver 已经成功验证我们是谁，终于解脱了！"
				}
			]
		},
		{
			"ID": "20221220172504-4uar13b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-4uar13b",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然而事情并没有结束，虽然我们已经证明了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "我们是合法的"
				},
				{
					"Type": "NodeText",
					"Data": " ，但我们有权执行此操作吗？毕竟身份和权限不是一回事。为了进行后续的操作，kube-apiserver 还要对用户进行授权。"
				}
			]
		},
		{
			"ID": "20221220172504-iuwqju1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-iuwqju1",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "kube-apiserver 处理授权的方式与处理身份验证的方式相似：通过 kube-apiserver 的启动参数 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--authorization_mode"
				},
				{
					"Type": "NodeText",
					"Data": " 参数设置。它将组合一系列授权者，这些授权者将针对每个传入的请求进行授权。如果所有授权者都拒绝该请求，则该请求会被禁止响应并且"
				}
			]
		},
		{
			"ID": "20221220172504-iqzyurt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-iqzyurt",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/e30df5e70ef9127ea69d607207c894251025e55b/pkg/endpoints/filters/authorization.go#L60",
					"TextMarkTextContent": "不会再继续响应"
				},
				{
					"Type": "NodeText",
					"Data": "。如果某个授权者批准了该请求，则请求继续。"
				}
			]
		},
		{
			"ID": "20221220172504-xenlpmw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-xenlpmw",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "kube-apiserver 目前支持以下几种授权方法："
				}
			]
		},
		{
			"ID": "20221220172504-mqxw0pv",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-mqxw0pv",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-ifro3iv",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-ifro3iv",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-rmvoyzf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-rmvoyzf",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://k8smeetup.github.io/docs/admin/authorization/webhook/",
									"TextMarkTextContent": "webhook"
								},
								{
									"Type": "NodeText",
									"Data": ": 它与集群外的 HTTP(S) 服务交互。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-1yhe13h",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-1yhe13h",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-j5hzgwk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-j5hzgwk",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://k8smeetup.github.io/docs/admin/authorization/abac/",
									"TextMarkTextContent": "ABAC"
								},
								{
									"Type": "NodeText",
									"Data": ": 它执行静态文件中定义的策略。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-1j2jtgm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-1j2jtgm",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-6me22rv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-6me22rv",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://k8smeetup.github.io/docs/admin/authorization/rbac/",
									"TextMarkTextContent": "RBAC"
								},
								{
									"Type": "NodeText",
									"Data": ": 它使用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "rbac.authorization.k8s.io"
								},
								{
									"Type": "NodeText",
									"Data": "  API Group实现授权决策，允许管理员通过 Kubernetes API 动态配置策略。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-44o0nqm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-44o0nqm",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-zol0e9t",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-zol0e9t",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://k8smeetup.github.io/docs/admin/authorization/node/",
									"TextMarkTextContent": "Node"
								},
								{
									"Type": "NodeText",
									"Data": ": 它确保 kubelet 只能访问自己节点上的资源。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-510sqci",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-510sqci",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-t7lf6oc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-t7lf6oc",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://k8smeetup.github.io/docs/admin/admission-controllers/",
					"TextMarkTextContent": "准入控制"
				}
			]
		},
		{
			"ID": "20221220172504-h7urw38",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-h7urw38",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "突破了之前所说的认证和授权两道关口之后，客户端的调用请求就能够得到 API Server 的真正响应了吗？答案是：不能！"
				}
			]
		},
		{
			"ID": "20221220172504-421tmrn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-421tmrn",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从 kube-apiserver 的角度来看，它已经验证了我们的身份并且赋予了相应的权限允许我们继续，但对于 Kubernetes 而言，其他组件对于应不应该允许发生的事情还是很有意见的。所以这个请求还需要通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Admission Controller"
				},
				{
					"Type": "NodeText",
					"Data": " 所控制的一个 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "准入控制链"
				},
				{
					"Type": "NodeText",
					"Data": " 的层层考验，官方标准的 “关卡” 有近十个之多，而且还能自定义扩展！"
				}
			]
		},
		{
			"ID": "20221220172504-vyu6lju",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-vyu6lju",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然授权的重点是回答用户是否有权限，但准入控制器会拦截请求以确保它符合集群的更广泛的期望和规则。它们是资源对象保存到 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "etcd"
				},
				{
					"Type": "NodeText",
					"Data": " 之前的最后一个堡垒，封装了一系列额外的检查以确保操作不会产生意外或负面结果。不同于授权和认证只关心请求的用户和操作，准入控制还处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等有效，而对读操作无效。"
				}
			]
		},
		{
			"ID": "20221220172504-4nm8fh5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-4nm8fh5",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "  准入控制器的工作方式与授权者和验证者的工作方式类似，但有一点区别：与验证链和授权链不同，如果某个准入控制器检查不通过，则整个链会中断，整个请求将立即被拒绝并且返回一个错误给终端用户。"
				}
			]
		},
		{
			"ID": "20221220172504-el5mn2v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-el5mn2v",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "准入控制器设计的重点在于提高可扩展性，某个控制器都作为一个插件存储在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "plugin/pkg/admission"
				},
				{
					"Type": "NodeText",
					"Data": " 目录中，并且与某一个接口相匹配，最后被编译到 kube-apiserver 二进制文件中。"
				}
			]
		},
		{
			"ID": "20221220172504-a377yno",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-a377yno",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大部分准入控制器都比较容易理解，接下来着重介绍 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "SecurityContextDeny"
				},
				{
					"Type": "NodeText",
					"Data": "、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ResourceQuota"
				},
				{
					"Type": "NodeText",
					"Data": " 及 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "LimitRanger"
				},
				{
					"Type": "NodeText",
					"Data": " 这三个准入控制器。"
				}
			]
		},
		{
			"ID": "20221220172504-j5y6lkg",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-j5y6lkg",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-shjd575",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-shjd575",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-yl017l5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-yl017l5",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "SecurityContextDeny 该插件将禁止创建设置了 Security Context 的 Pod。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-wg2kvqn",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-wg2kvqn",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-nwlgvnl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-nwlgvnl",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "ResourceQuota 不仅能限制某个 Namespace 中创建资源的数量，而且能限制某个 Namespace 中被 Pod 所请求的资源总量。该准入控制器和资源对象 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ResourceQuota"
								},
								{
									"Type": "NodeText",
									"Data": " 一起实现了资源配额管理。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-yyruv15",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-yyruv15",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-uoaun9b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-uoaun9b",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "LimitRanger 作用类似于上面的 ResourceQuota 控制器，针对 Namespace 资源的每个个体（Pod 与 Container 等）的资源配额。该插件和资源对象 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "LimitRange"
								},
								{
									"Type": "NodeText",
									"Data": " 一起实现资源配额管理。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-dedk9p4",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-dedk9p4",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3. etcd"
				}
			]
		},
		{
			"ID": "20221220172504-i70bto4",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-i70bto4",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-1r1cj33",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-1r1cj33",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到现在为止，Kubernetes 已经对该客户端的调用请求进行了全面彻底地审查，并且已经验证通过，运行它进入下一个环节。下一步 kube-apiserver 将对 HTTP 请求进行反序列化，然后利用得到的结果构建运行时对象（有点像 kubectl 生成器的逆过程），并保存到 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "etcd"
				},
				{
					"Type": "NodeText",
					"Data": " 中。下面我们将这个过程分解一下。"
				}
			]
		},
		{
			"ID": "20221220172504-7g7mgaa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-7g7mgaa",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当收到请求时，kube-apiserver 是如何知道它该怎么做的呢？事实上，在客户端发送调用请求之前就已经产生了一系列非常复杂的流程。我们就从 kube-apiserver 二进制文件首次运行开始分析吧："
				}
			]
		},
		{
			"ID": "20221220172504-1n1m21o",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221220172504-1n1m21o",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-6azkyzm",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221220172504-6azkyzm",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-vzjy74h",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-vzjy74h",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当运行 kube-apiserver 二进制文件时，它会"
								}
							]
						},
						{
							"ID": "20221220172504-0ox2os2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-0ox2os2",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/cmd/kube-apiserver/app/server.go#L119",
									"TextMarkTextContent": "创建一个允许 apiserver 聚合的服务链"
								},
								{
									"Type": "NodeText",
									"Data": "。这是一种对 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Kubernetes API"
								},
								{
									"Type": "NodeText",
									"Data": " 进行扩展的方式。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-90huwnd",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221220172504-90huwnd",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-wspm60q",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-wspm60q",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "同时会创建一个 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "generic apiserver"
								},
								{
									"Type": "NodeText",
									"Data": " 作为默认的 apiserver。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-bbyz18l",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20221220172504-bbyz18l",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-eywceac",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-eywceac",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后利用"
								}
							]
						},
						{
							"ID": "20221220172504-6j9yezw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-6j9yezw",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/config.go#L149",
									"TextMarkTextContent": "生成的 OpenAPI 规范"
								},
								{
									"Type": "NodeText",
									"Data": "来填充 apiserver 的配置。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-hs90twb",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20221220172504-hs90twb",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-ioxrnw6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-ioxrnw6",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后 kube-apiserver 遍历数据结构中指定的所有 API 组，并将每一个 API 组作为通用的存储抽象保存到 etcd 中。当你访问或变更资源状态时，kube-apiserver 就会调用这些 API 组。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-dql5exu",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20221220172504-dql5exu",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-4yz9a88",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-4yz9a88",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "每个 API 组都会遍历它的所有组版本，并且将每个 HTTP 路由"
								}
							]
						},
						{
							"ID": "20221220172504-urlrmj0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-urlrmj0",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/groupversion.go#L92",
									"TextMarkTextContent": "映射到 REST 路径中"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-1j5g0v9",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20221220172504-1j5g0v9",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-f0cc2mi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-f0cc2mi",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当请求的 METHOD 是 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "POST"
								},
								{
									"Type": "NodeText",
									"Data": " 时，kube-apiserver 就会将请求转交给"
								}
							]
						},
						{
							"ID": "20221220172504-a9i9ynt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-a9i9ynt",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37",
									"TextMarkTextContent": "资源创建处理器"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-m43ak1k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-m43ak1k",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在 kube-apiserver 已经知道了所有的路由及其对应的 REST 路径，以便在请求匹配时知道调用哪些处理器和键值存储。多么机智的设计！现在假设客户端的 HTTP 请求已经被 kube-apiserver 收到了："
				}
			]
		},
		{
			"ID": "20221220172504-hig3bsj",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221220172504-hig3bsj",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-nidi4uz",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221220172504-nidi4uz",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-50hds2v",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-50hds2v",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果处理链可以将请求与已经注册的路由进行匹配，就会将该请求交给注册到该路由的"
								}
							]
						},
						{
							"ID": "20221220172504-cx8ak72",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-cx8ak72",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/handler.go#L143",
									"TextMarkTextContent": "专用处理器"
								},
								{
									"Type": "NodeText",
									"Data": "来处理；如果没有任何一个路由可以匹配该请求，就会将请求转交给"
								}
							]
						},
						{
							"ID": "20221220172504-eg41czn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-eg41czn",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L248",
									"TextMarkTextContent": "基于路径的处理器"
								},
								{
									"Type": "NodeText",
									"Data": "（比如当调用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "/apis"
								},
								{
									"Type": "NodeText",
									"Data": " 时）；如果没有任何一个基于路径的处理器注册到该路径，请求就会被转交给"
								}
							]
						},
						{
							"ID": "20221220172504-joaogte",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-joaogte",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L254",
									"TextMarkTextContent": "not found 处理器"
								},
								{
									"Type": "NodeText",
									"Data": "，最后返回 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "404"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-95huj5j",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221220172504-95huj5j",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-gz1ibuw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-gz1ibuw",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "幸运的是，我们有一个名为 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "createHandler"
								},
								{
									"Type": "NodeText",
									"Data": " 的注册路由！它有什么作用呢？首先它会解码 HTTP 请求并进行基本的验证，例如确保请求提供的 json 与 API 资源的版本相匹配。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-dl7jgb5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20221220172504-dl7jgb5",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-xy87pnu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-xy87pnu",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接下来进入"
								}
							]
						},
						{
							"ID": "20221220172504-7wpsnd5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-7wpsnd5",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L93-L104",
									"TextMarkTextContent": "审计和准入控制"
								},
								{
									"Type": "NodeText",
									"Data": "阶段。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-hotmc70",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20221220172504-hotmc70",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-l65buh0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-l65buh0",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后资源将会通过"
								}
							]
						},
						{
							"ID": "20221220172504-41ovfzt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-41ovfzt",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/19667a1afc13cc13930c40a20f2c12bbdcaaa246/pkg/registry/generic/registry/store.go#L327",
									"TextMarkTextContent": "storage provider"
								},
								{
									"Type": "NodeText",
									"Data": " 保存"
								}
							]
						},
						{
							"ID": "20221220172504-wifb9aj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-wifb9aj",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L111",
									"TextMarkTextContent": "到 etcd"
								},
								{
									"Type": "NodeText",
									"Data": " 中。默认情况下保存到 etcd 中的键的格式为 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;"
								},
								{
									"Type": "NodeText",
									"Data": "，你也可以自定义。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-1828dhh",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20221220172504-1828dhh",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-umcd73e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-umcd73e",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "资源创建过程中出现的任何错误都会被捕获，最后 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "storage provider"
								},
								{
									"Type": "NodeText",
									"Data": " 会执行 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "get"
								},
								{
									"Type": "NodeText",
									"Data": " 调用来确认该资源是否被成功创建。如果需要额外的清理工作，就会调用后期创建的处理器和装饰器。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-f03ev7p",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20221220172504-f03ev7p",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-xnu7oms",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-xnu7oms",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后构造 HTTP 响应并返回给客户端。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-68iv7kw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-68iv7kw",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原来 apiserver 做了这么多的工作，以前竟然没有发现呢！到目前为止，我们创建的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Deployment"
				},
				{
					"Type": "NodeText",
					"Data": " 资源已经保存到了 etcd 中，但 apiserver 仍然看不到它。"
				}
			]
		},
		{
			"ID": "20221220172504-u3aj3jb",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-u3aj3jb",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "4. 初始化"
				}
			]
		},
		{
			"ID": "20221220172504-ditm1on",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-ditm1on",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-ih1sql9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-ih1sql9",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在一个资源对象被持久化到数据存储之后，apiserver 还无法完全看到或调度它，在此之前还要执行一系列"
				}
			]
		},
		{
			"ID": "20221220172504-ir1dy5n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-ir1dy5n",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://v1-13.docs.kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#initializers",
					"TextMarkTextContent": "Initializers"
				},
				{
					"Type": "NodeText",
					"Data": "。Initializers是一种与资源类型相关联的控制器，它会在资源对外可用之前执行某些逻辑。如果某个资源类型没有Initializers，就会跳过此初始化步骤立即使资源对外可见。"
				}
			]
		},
		{
			"ID": "20221220172504-b45u485",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-b45u485",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "正如"
				}
			]
		},
		{
			"ID": "20221220172504-kwe29u0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-kwe29u0",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://ahmet.im/blog/initializers/",
					"TextMarkTextContent": "大佬的博客"
				},
				{
					"Type": "NodeText",
					"Data": "指出的那样，Initializers是一个强大的功能，因为它允许我们执行通用引导操作。例如："
				}
			]
		},
		{
			"ID": "20221220172504-p8uzcl9",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-p8uzcl9",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-uquxey4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-uquxey4",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-alxqtnd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-alxqtnd",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将代理边车容器注入到暴露 80 端口的 Pod 中，或者加上特定的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "annotation"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-ih3fdg7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-ih3fdg7",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-yf90yut",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-yf90yut",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将保存着测试证书的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "volume"
								},
								{
									"Type": "NodeText",
									"Data": " 注入到特定命名空间的所有 Pod 中。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-73syxao",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-73syxao",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-2ukzd0p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-2ukzd0p",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Secret"
								},
								{
									"Type": "NodeText",
									"Data": " 中的密码小于 20 个字符，就组织其创建。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-014wi2r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-014wi2r",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "initializerConfiguration"
				},
				{
					"Type": "NodeText",
					"Data": " 资源对象允许你声明某些资源类型应该运行哪些Initializers。如果你想每创建一个 Pod 时就运行一个自定义Initializers，你可以这样做："
				}
			]
		},
		{
			"ID": "20221220172504-54ffzxy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221220172504-54ffzxy",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eWFtbA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "apiVersion: admissionregistration.k8s.io/v1alpha1\nkind: InitializerConfiguration\nmetadata:\n  name: custom-pod-initializer\ninitializers:\n  - name: podimage.example.com\n    rules:\n      - apiGroups:\n          - \"\"\n        apiVersions:\n          - v1\n        resources:\n          - pods\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221220172504-z0mh15a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-z0mh15a",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过该配置创建资源对象 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "InitializerConfiguration"
				},
				{
					"Type": "NodeText",
					"Data": " 之后，就会在每个 Pod 的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "metadata.initializers.pending"
				},
				{
					"Type": "NodeText",
					"Data": " 字段中添加 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "custom-pod-initializer"
				},
				{
					"Type": "NodeText",
					"Data": " 字段。该初始化控制器会定期扫描新的 Pod，一旦在 Pod 的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "pending"
				},
				{
					"Type": "NodeText",
					"Data": " 字段中检测到自己的名称，就会执行其逻辑，执行完逻辑之后就会将 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "pending"
				},
				{
					"Type": "NodeText",
					"Data": " 字段下的自己的名称删除。"
				}
			]
		},
		{
			"ID": "20221220172504-p65pn7w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-p65pn7w",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "只有在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "pending"
				},
				{
					"Type": "NodeText",
					"Data": " 字段下的列表中的第一个Initializers可以对资源进行操作，当所有的Initializers执行完成，并且 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "pending"
				},
				{
					"Type": "NodeText",
					"Data": " 字段为空时，该对象就会被认为初始化成功。"
				}
			]
		},
		{
			"ID": "20221220172504-jbur9d3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-jbur9d3",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "你可能会注意到一个问题：如果 kube-apiserver 不能显示这些资源，那么用户级控制器是如何处理资源的呢？"
				}
			]
		},
		{
			"ID": "20221220172504-hdcgf6i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-hdcgf6i",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了解决这个问题，kube-apiserver 暴露了一个 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "?includeUninitialized"
				},
				{
					"Type": "NodeText",
					"Data": " 查询参数，它会返回所有的资源对象（包括未初始化的）。"
				}
			]
		},
		{
			"ID": "20221220172504-pjvpuyf",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-pjvpuyf",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "5. 控制循环"
				}
			]
		},
		{
			"ID": "20221220172504-2tgt3ub",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-2tgt3ub",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-5sl3a2g",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-5sl3a2g",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Deployments controller"
				}
			]
		},
		{
			"ID": "20221220172504-jl1irxn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-jl1irxn",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到了这个阶段，我们的 Deployment 记录已经保存在 etcd 中，并且所有的初始化逻辑都执行完成，接下来的阶段将会涉及到该资源所依赖的拓扑结构。在 Kubernetes 中，Deployment 实际上只是一系列 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Replicaset"
				},
				{
					"Type": "NodeText",
					"Data": " 的集合，而 Replicaset 是一系列 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Pod"
				},
				{
					"Type": "NodeText",
					"Data": " 的集合。那么 Kubernetes 是如何从一个 HTTP 请求按照层级结构依次创建这些资源的呢？其实这些工作都是由 Kubernetes 内置的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Controller"
				},
				{
					"Type": "NodeText",
					"Data": "(控制器) 来完成的。"
				}
			]
		},
		{
			"ID": "20221220172504-p0eomds",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-p0eomds",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Kubernetes 在整个系统中使用了大量的 Controller，Controller 是一个用于将系统状态从“当前状态”修正到“期望状态”的异步脚本。所有 Controller 都通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "kube-controller-manager"
				},
				{
					"Type": "NodeText",
					"Data": " 组件并行运行，每种 Controller 都负责一种具体的控制流程。首先介绍一下 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Deployment Controller"
				},
				{
					"Type": "NodeText",
					"Data": "："
				}
			]
		},
		{
			"ID": "20221220172504-315eesp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-315eesp",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将 Deployment 记录存储到 etcd 并初始化后，就可以通过 kube-apiserver 使其可见，然后 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Deployment Controller"
				},
				{
					"Type": "NodeText",
					"Data": " 就会检测到它（它的工作就是负责监听 Deployment 记录的更改）。在我们的例子中，控制器通过一个 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Informer"
				}
			]
		},
		{
			"ID": "20221220172504-w5eio52",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-w5eio52",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L122",
					"TextMarkTextContent": "注册一个创建事件的特定回调函数"
				},
				{
					"Type": "NodeText",
					"Data": "（更多信息参加下文）。"
				}
			]
		},
		{
			"ID": "20221220172504-w8l706c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-w8l706c",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当 Deployment 第一次对外可见时，该 Controller 就会"
				}
			]
		},
		{
			"ID": "20221220172504-zcdfscz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-zcdfscz",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L170",
					"TextMarkTextContent": "将该资源对象添加到内部工作队列"
				},
				{
					"Type": "NodeText",
					"Data": "，然后开始处理这个资源对象："
				}
			]
		},
		{
			"ID": "20221220172504-kxduu4t",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221220172504-kxduu4t",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221220172504-d6fqlwo",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221220172504-d6fqlwo",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "通过使用标签选择器查询 kube-apiserver 来"
						}
					]
				},
				{
					"ID": "20221220172504-j0zznsh",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221220172504-j0zznsh",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "a",
							"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/deployment_controller.go#L633",
							"TextMarkTextContent": "检查"
						},
						{
							"Type": "NodeText",
							"Data": "该 Deployment 是否有与其关联的 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "ReplicaSet"
						},
						{
							"Type": "NodeText",
							"Data": " 或 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "Pod"
						},
						{
							"Type": "NodeText",
							"Data": " 记录。"
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-2lfrpme",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-2lfrpme",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有趣的是，这个同步过程是状态不可知的，它核对新记录与核对已经存在的记录采用的是相同的方式。"
				}
			]
		},
		{
			"ID": "20221220172504-z03eu54",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-z03eu54",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在意识到没有与其关联的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ReplicaSet"
				},
				{
					"Type": "NodeText",
					"Data": " 或 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Pod"
				},
				{
					"Type": "NodeText",
					"Data": " 记录后，Deployment Controller 就会开始执行"
				}
			]
		},
		{
			"ID": "20221220172504-08g1u5h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-08g1u5h",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/deployment/sync.go#L385",
					"TextMarkTextContent": "弹性伸缩流程"
				},
				{
					"Type": "NodeText",
					"Data": "："
				}
			]
		},
		{
			"ID": "20221220172504-eo31uj2",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221220172504-eo31uj2",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221220172504-2ay5lt7",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221220172504-2ay5lt7",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "创建 ReplicaSet 资源，为其分配一个标签选择器并将其版本号设置为 1。"
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-hcc1y55",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-hcc1y55",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ReplicaSet 的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "PodSpec"
				},
				{
					"Type": "NodeText",
					"Data": " 字段从 Deployment 的 manifest 以及其他相关元数据中复制而来。有时 Deployment 记录在此之后也需要更新（例如，如果设置了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "process deadline"
				},
				{
					"Type": "NodeText",
					"Data": "）。"
				}
			]
		},
		{
			"ID": "20221220172504-87nv4rg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-87nv4rg",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当完成以上步骤之后，该 Deployment 的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "status"
				},
				{
					"Type": "NodeText",
					"Data": " 就会被更新，然后重新进入与之前相同的循环，等待 Deployment 与期望的状态相匹配。由于 Deployment Controller 只关心 ReplicaSet，因此需要通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ReplicaSet Controller"
				},
				{
					"Type": "NodeText",
					"Data": " 来继续协调。"
				}
			]
		},
		{
			"ID": "20221220172504-112g653",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-112g653",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "ReplicaSets controller"
				}
			]
		},
		{
			"ID": "20221220172504-a4j6pre",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-a4j6pre",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在前面的步骤中，Deployment Controller 创建了第一个 ReplicaSet，但仍然还是没有 Pod，这时候就该 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ReplicaSet Controller"
				},
				{
					"Type": "NodeText",
					"Data": " 登场了！ReplicaSet Controller 的工作是监视 ReplicaSets 及其相关资源（Pod）的生命周期。和大多数其他 Controller 一样，它通过触发某些事件的处理器来实现此目的。"
				}
			]
		},
		{
			"ID": "20221220172504-jjk7vup",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-jjk7vup",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当创建 ReplicaSet 时（由 Deployment Controller 创建），RS Controller"
				}
			]
		},
		{
			"ID": "20221220172504-cd2sq80",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-cd2sq80",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/replicaset/replica_set.go#L583",
					"TextMarkTextContent": "检查新 ReplicaSet 的状态"
				},
				{
					"Type": "NodeText",
					"Data": "，并检查当前状态与期望状态之间存在的偏差，然后通过"
				}
			]
		},
		{
			"ID": "20221220172504-nf6bpb8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-nf6bpb8",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/7650665059e65b4b22375d1e28da5306536a12fb/pkg/controller/replicaset/replica_set.go#L460",
					"TextMarkTextContent": "调整 Pod 的副本数"
				},
				{
					"Type": "NodeText",
					"Data": "来达到期望的状态。"
				}
			]
		},
		{
			"ID": "20221220172504-h5ziml0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-h5ziml0",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Pod 的创建也是批量进行的，从 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "SlowStartInitialBatchSize"
				},
				{
					"Type": "NodeText",
					"Data": " 开始，然后在每次成功的迭代中以一种 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "slow start"
				},
				{
					"Type": "NodeText",
					"Data": " 操作加倍。这样做的目的是在大量 Pod 启动失败时（例如，由于资源配额），可以减轻 kube-apiserver 被大量不必要的 HTTP 请求吞没的风险。如果创建失败，最好能够优雅地失败，并且对其他的系统组件造成的影响最小！"
				}
			]
		},
		{
			"ID": "20221220172504-4c5xbuk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-4c5xbuk",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Kubernetes 通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Owner References"
				},
				{
					"Type": "NodeText",
					"Data": "（在子级资源的某个字段中引用其父级资源的 ID） 来构造严格的资源对象层级结构。这确保了一旦 Controller 管理的资源被删除（级联删除），子资源就会被垃圾收集器删除，同时还为父级资源提供了一种有效的方式来避免他们竞争同一个子级资源（想象两对父母都认为他们拥有同一个孩子的场景）。"
				}
			]
		},
		{
			"ID": "20221220172504-5gnf82f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-5gnf82f",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Owner References 的另一个好处是：它是有状态的。如果有任何 Controller 重启了，那么由于资源对象的拓扑关系与 Controller 无关，该操作不会影响到系统的稳定运行。这种对资源隔离的重视也体现在 Controller 本身的设计中：Controller 不能对自己没有明确拥有的资源进行操作，它们应该选择对资源的所有权，互不干涉，互不共享。"
				}
			]
		},
		{
			"ID": "20221220172504-gxxc5dk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-gxxc5dk",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有时系统中也会出现孤儿（orphaned）资源，通常由以下两种途径产生："
				}
			]
		},
		{
			"ID": "20221220172504-c3j28qs",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-c3j28qs",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-0y09lw8",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-0y09lw8",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-gqr10lm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-gqr10lm",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "父级资源被删除，但子级资源没有被删除"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-4ie9o2g",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-4ie9o2g",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-2rtlcva",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-2rtlcva",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "垃圾收集策略禁止删除子级资源"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-jxvtc41",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-jxvtc41",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当发生这种情况时，Controller 将会确保孤儿资源拥有新的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Owner"
				},
				{
					"Type": "NodeText",
					"Data": "。多个父级资源可以相互竞争同一个孤儿资源，但只有一个会成功（其他父级资源会收到验证错误）。"
				}
			]
		},
		{
			"ID": "20221220172504-9ewwrmu",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-9ewwrmu",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Informers"
				}
			]
		},
		{
			"ID": "20221220172504-1dvmjwk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-1dvmjwk",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "你可能已经注意到，某些 Controller（例如 RBAC 授权器或 Deployment Controller）需要先检索集群状态然后才能正常运行。拿 RBAC 授权器举例，当请求进入时，授权器会将用户的初始状态缓存下来，然后用它来检索与 etcd 中的用户关联的所有  角色（"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Role"
				},
				{
					"Type": "NodeText",
					"Data": "）和 角色绑定（"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "RoleBinding"
				},
				{
					"Type": "NodeText",
					"Data": "）。那么问题来了，Controller 是如何访问和修改这些资源对象的呢？事实上 Kubernetes 是通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Informer"
				},
				{
					"Type": "NodeText",
					"Data": " 机制来解决这个问题的。"
				}
			]
		},
		{
			"ID": "20221220172504-h2lnvh9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-h2lnvh9",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Infomer 是一种模式，它允许 Controller 查找缓存在本地内存中的数据(这份数据由 Informer 自己维护)并列出它们感兴趣的资源。"
				}
			]
		},
		{
			"ID": "20221220172504-vczqml4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-vczqml4",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然 Informer 的设计很抽象，但它在内部实现了大量的对细节的处理逻辑（例如缓存），缓存很重要，因为它不但可以减少对 Kubenetes API 的直接调用，同时也能减少 Server 和 Controller 的大量重复性工作。通过使用 Informer，不同的 Controller 之间以线程安全（Thread safety）的方式进行交互，而不必担心多个线程访问相同的资源时会产生冲突。"
				}
			]
		},
		{
			"ID": "20221220172504-n3t2igs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-n3t2igs",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有关 Informer 的更多详细解析，请参考这篇文章："
				}
			]
		},
		{
			"ID": "20221220172504-ool1f1v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-ool1f1v",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://borismattijssen.github.io/articles/kubernetes-informers-controllers-reflectors-stores",
					"TextMarkTextContent": "Kubernetes: Controllers, Informers, Reflectors and Stores"
				}
			]
		},
		{
			"ID": "20221220172504-8598bkl",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-8598bkl",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Scheduler"
				}
			]
		},
		{
			"ID": "20221220172504-16gjmy9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-16gjmy9",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当所有的 Controller 正常运行后，etcd 中就会保存一个 Deployment、一个 ReplicaSet 和 三个 Pod 资源记录，并且可以通过 kube-apiserver 查看。然而，这些 Pod 资源现在还处于 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Pending"
				},
				{
					"Type": "NodeText",
					"Data": " 状态，因为它们还没有被调度到集群中合适的 Node 上运行。这个问题最终要靠调度器（Scheduler）来解决。"
				}
			]
		},
		{
			"ID": "20221220172504-itat5dv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-itat5dv",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Scheduler"
				},
				{
					"Type": "NodeText",
					"Data": " 作为一个独立的组件运行在集群控制平面上，工作方式与其他 Controller 相同：监听实际并将系统状态调整到期望的状态。具体来说，Scheduler 的作用是将待调度的 Pod 按照特定的算法和调度策略绑定（Binding）到集群中某个合适的 Node 上，并将绑定信息写入 etcd 中（它会过滤其 PodSpec 中 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "NodeName"
				},
				{
					"Type": "NodeText",
					"Data": " 字段为空的 Pod），默认的调度算法的工作方式如下："
				}
			]
		},
		{
			"ID": "20221220172504-931j4re",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221220172504-931j4re",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-k9ey8ju",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221220172504-k9ey8ju",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-9mkd144",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-9mkd144",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当 Scheduler 启动时，会"
								}
							]
						},
						{
							"ID": "20221220172504-w3oxvqy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-w3oxvqy",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/algorithmprovider/defaults/defaults.go#L65-L81",
									"TextMarkTextContent": "注册一个默认的预选策略链"
								},
								{
									"Type": "NodeText",
									"Data": "，这些 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "预选策略"
								},
								{
									"Type": "NodeText",
									"Data": " 会对备选节点进行评估，判断备选节点是否"
								}
							]
						},
						{
							"ID": "20221220172504-1esfuj2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-1esfuj2",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/core/generic_scheduler.go#L117",
									"TextMarkTextContent": "满足备选 Pod 的需求"
								},
								{
									"Type": "NodeText",
									"Data": "。例如，如果 PodSpec 字段限制了 CPU 和内存资源，那么当备选节点的资源容量不满足备选 Pod 的需求时，备选 Pod 就不会被调度到该节点上（ "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "资源容量=备选节点资源总量-节点中已存在 Pod 的所有容器的需求资源（CPU 和内存）的总和"
								},
								{
									"Type": "NodeText",
									"Data": " ）"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-elhnw1s",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221220172504-elhnw1s",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-3hn9i6s",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-3hn9i6s",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "一旦筛选出符合要求的候选节点，就会采用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "优选策略"
								},
								{
									"Type": "NodeText",
									"Data": " 计算出每个候选节点的积分，然后对这些候选节点进行排序，积分最高者胜出。例如，为了在整个系统中分摊工作负载，这些优选策略会从备选节点列表中选出资源消耗最小的节点。每个节点通过优选策略时都会算出一个得分，计算各项得分，最终选出分值大的节点作为优选的结果。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-5wy1nw6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-5wy1nw6",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一旦找到了合适的节点，Scheduler 就会创建一个 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Binding"
				},
				{
					"Type": "NodeText",
					"Data": " 对象，该对象的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Name"
				},
				{
					"Type": "NodeText",
					"Data": " 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Uid"
				},
				{
					"Type": "NodeText",
					"Data": " 与 Pod 相匹配，并且其 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ObjectReference"
				},
				{
					"Type": "NodeText",
					"Data": " 字段包含所选节点的名称，然后通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "POST"
				},
				{
					"Type": "NodeText",
					"Data": " 请求"
				}
			]
		},
		{
			"ID": "20221220172504-247d0fy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-247d0fy",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/plugin/pkg/scheduler/factory/factory.go#L1095",
					"TextMarkTextContent": "发送给 apiserver"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221220172504-fap1boh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-fap1boh",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当 kube-apiserver 接收到此 Binding 对象时，注册吧会将该对象"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "反序列化"
				},
				{
					"Type": "NodeText",
					"Data": "并更新 Pod 资源中的以下字段："
				}
			]
		},
		{
			"ID": "20221220172504-gpjq49y",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-gpjq49y",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-60m9heg",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-60m9heg",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-z54pq1w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-z54pq1w",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "NodeName"
								},
								{
									"Type": "NodeText",
									"Data": " 的值设置为 ObjectReference 中的 NodeName。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-wrq7qvt",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-wrq7qvt",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-5itd1xj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-5itd1xj",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "添加相关的注释。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-fhki2cj",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-fhki2cj",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-ofjt95l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-ofjt95l",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "PodScheduled"
								},
								{
									"Type": "NodeText",
									"Data": " 的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "status"
								},
								{
									"Type": "NodeText",
									"Data": " 值设置为 True。可以通过 kubectl 来查看："
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-b69alan",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221220172504-b69alan",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "YmFzaA=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "$ kubectl get \u003cPODNAME\u003e -o go-template='{{range .status.conditions}}{{if eq .type \"PodScheduled\"}}{{.status}}{{end}}{{end}}'\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221220172504-g7vt2k1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-g7vt2k1",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一旦 Scheduler 将 Pod 调度到某个节点上，该节点的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Kubelet"
				},
				{
					"Type": "NodeText",
					"Data": " 就会接管该 Pod 并开始部署。"
				}
			]
		},
		{
			"ID": "20221220172504-bp3ill1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-bp3ill1",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "  预选策略和优选策略都可以通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "–policy-config-file"
				},
				{
					"Type": "NodeText",
					"Data": " 参数来扩展，如果默认的调度器不满足要求，还可以部署自定义的调度器。如果  "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "podSpec.schedulerName"
				},
				{
					"Type": "NodeText",
					"Data": " 的值设置为其他的调度器，则 Kubernetes 会将该 Pod 的调度转交给那个调度器。"
				}
			]
		},
		{
			"ID": "20221220172504-bc299ce",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-bc299ce",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "6. Kubelet"
				}
			]
		},
		{
			"ID": "20221220172504-uh5ud37",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-uh5ud37",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-9k0o887",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-9k0o887",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Pod 同步"
				}
			]
		},
		{
			"ID": "20221220172504-p4u3xvl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-p4u3xvl",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在，所有的 Controller 都完成了工作，我们来总结一下："
				}
			]
		},
		{
			"ID": "20221220172504-tbnxok3",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-tbnxok3",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-tppl3f7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-tppl3f7",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-c7ocveq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-c7ocveq",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "HTTP 请求通过了认证、授权和准入控制阶段。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-sq3jvwu",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-sq3jvwu",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-fo8cszw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-fo8cszw",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "一个 Deployment、ReplicaSet 和三个 Pod 资源被持久化到 etcd 存储中。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-lv18x1d",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-lv18x1d",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-w3vwmzm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-w3vwmzm",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后运行了一系列Initializers。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-hz6kp5b",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-hz6kp5b",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-jvih65h",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-jvih65h",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后每个 Pod 都被调度到合适的节点。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-hy8nyc7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-hy8nyc7",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然而到目前为止，所有的状态变化仅仅只是针对保存在 etcd 中的资源记录，接下来的步骤涉及到运行在工作节点之间的 Pod 的分布状况，这是分布式系统（比如 Kubernetes）的关键因素。这些任务都是由 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Kubelet"
				},
				{
					"Type": "NodeText",
					"Data": " 组件完成的，让我们开始吧！"
				}
			]
		},
		{
			"ID": "20221220172504-vyj1pf8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-vyj1pf8",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Kubernetes 集群中，每个 Node 节点上都会启动一个 Kubelet 服务进程，该进程用于处理 Scheduler 下发到本节点的任务，管理 Pod 的生命周期，包括挂载卷、容器日志记录、垃圾回收以及其他与 Pod 相关的事件。"
				}
			]
		},
		{
			"ID": "20221220172504-ykyjiq5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-ykyjiq5",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果换一种思维模式，你可以把 Kubelet 当成一种特殊的 Controller，它每隔 20 秒（可以自定义）向 kube-apiserver 通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "NodeName"
				},
				{
					"Type": "NodeText",
					"Data": " 获取自身 Node 上所要运行的 Pod 清单。一旦获取到了这个清单，它就会通过与自己的内部缓存进行比较来检测新增加的 Pod，如果有差异，就开始同步 Pod 列表。我们来详细分析一下同步过程："
				}
			]
		},
		{
			"ID": "20221220172504-y94b58z",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221220172504-y94b58z",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-m6sl08g",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221220172504-m6sl08g",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-n4nxvsp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-n4nxvsp",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 Pod 正在创建， Kubelet 就会"
								}
							]
						},
						{
							"ID": "20221220172504-7i9kzov",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-7i9kzov",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L1519",
									"TextMarkTextContent": "记录一些在 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a code",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L1519",
									"TextMarkTextContent": "Prometheus"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L1519",
									"TextMarkTextContent": " 中用于追踪 Pod 启动延时的指标"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-plrsthn",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221220172504-plrsthn",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-q36l852",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-q36l852",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后生成一个 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "PodStatus"
								},
								{
									"Type": "NodeText",
									"Data": " 对象，它表示 Pod 当前阶段的状态。Pod 的状态("
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Phase"
								},
								{
									"Type": "NodeText",
									"Data": ") 是 Pod 在其生命周期中的最精简的概要，包括 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Pending"
								},
								{
									"Type": "NodeText",
									"Data": "，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Running"
								},
								{
									"Type": "NodeText",
									"Data": "，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Succeeded"
								},
								{
									"Type": "NodeText",
									"Data": "，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Failed"
								},
								{
									"Type": "NodeText",
									"Data": " 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Unkown"
								},
								{
									"Type": "NodeText",
									"Data": " 这几个值。状态的产生过程非常过程，所以很有必要深入了解一下背后的原理："
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-kqmgxks",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-kqmgxks",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-gwrj8mz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-gwrj8mz",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-pkhya66",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-pkhya66",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "首先串行执行一系列 Pod 同步处理器（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "PodSyncHandlers"
								},
								{
									"Type": "NodeText",
									"Data": "），每个处理器检查检查 Pod 是否应该运行在该节点上。当所有的处理器都认为该 Pod 不应该运行在该节点上，则 Pod 的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Phase"
								},
								{
									"Type": "NodeText",
									"Data": " 值就会变成 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "PodFailed"
								},
								{
									"Type": "NodeText",
									"Data": "，并且将该 Pod 从该节点上驱逐出去。例如当你创建一个 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Job"
								},
								{
									"Type": "NodeText",
									"Data": " 时，如果 Pod 失败重试的时间超过了 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "spec.activeDeadlineSeconds"
								},
								{
									"Type": "NodeText",
									"Data": " 设置的值，就会将 Pod 从该节点驱逐出去。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-f2u7cn4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-f2u7cn4",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-2v41fny",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-2v41fny",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接下来，Pod 的 Phase 值由 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "init 容器"
								},
								{
									"Type": "NodeText",
									"Data": " 和应用容器的状态共同来决定。因为目前容器还没有启动，容器被视为"
								}
							]
						},
						{
							"ID": "20221220172504-yoohdrv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-yoohdrv",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1244",
									"TextMarkTextContent": "处于等待阶段"
								},
								{
									"Type": "NodeText",
									"Data": "，如果 Pod 中至少有一个容器处于等待阶段，则其 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Phase"
								},
								{
									"Type": "NodeText",
									"Data": " 值为"
								}
							]
						},
						{
							"ID": "20221220172504-tgk1mxt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-tgk1mxt",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet_pods.go#L1258-L1261",
									"TextMarkTextContent": "Pending"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-ab3q0zm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-ab3q0zm",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-8uskakw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-8uskakw",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后，Pod 的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Condition"
								},
								{
									"Type": "NodeText",
									"Data": " 字段由 Pod 内所有容器的状态决定。现在我们的容器还没有被容器运行时创建，所以"
								}
							]
						},
						{
							"ID": "20221220172504-o2gwpne",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-o2gwpne",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a code",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/status/generate.go#L70-L81",
									"TextMarkTextContent": "PodReady"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/status/generate.go#L70-L81",
									"TextMarkTextContent": " 的状态被设置为 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a code",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/status/generate.go#L70-L81",
									"TextMarkTextContent": "False"
								},
								{
									"Type": "NodeText",
									"Data": "。可以通过 kubectl 查看：\n"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "bash $ kubectl get \u0026lt;PODNAME\u0026gt; -o go-template='{{range .status.conditions}}{{if eq .type \u0026quot;Ready\u0026quot;}}{{.status}}{{end}}{{end}}' "
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-ikyd4lw",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221220172504-ikyd4lw",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-22g1ub4",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20221220172504-22g1ub4",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-j9k9zhl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-j9k9zhl",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "生成 PodStatus 之后（Pod 中的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "status"
								},
								{
									"Type": "NodeText",
									"Data": " 字段），Kubelet 就会将它发送到 Pod 的状态管理器，该管理器的任务是通过 apiserver 异步更新 etcd 中的记录。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-7ax777d",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20221220172504-7ax777d",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-kp9lj0e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-kp9lj0e",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接下来运行一系列"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "准入处理器"
								},
								{
									"Type": "NodeText",
									"Data": "来确保该 Pod 是否具有相应的权限（包括强制执行"
								}
							]
						},
						{
							"ID": "20221220172504-2pulkg4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-2pulkg4",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a code",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L883-L884",
									"TextMarkTextContent": "AppArmor"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L883-L884",
									"TextMarkTextContent": " 配置文件和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a code",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/fc8bfe2d8929e11a898c4557f9323c482b5e8842/pkg/kubelet/kubelet.go#L883-L884",
									"TextMarkTextContent": "NO_NEW_PRIVS"
								},
								{
									"Type": "NodeText",
									"Data": "），被准入控制器拒绝的 Pod 将一直保持 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Pending"
								},
								{
									"Type": "NodeText",
									"Data": " 状态。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-xi0s98m",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20221220172504-xi0s98m",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-t1zbvfz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-t1zbvfz",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 Kubelet 启动时指定了 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "cgroups-per-qos"
								},
								{
									"Type": "NodeText",
									"Data": " 参数，Kubelet 就会为该 Pod 创建 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "cgroup"
								},
								{
									"Type": "NodeText",
									"Data": " 并进行相应的资源限制。这是为了更方便地对 Pod 进行服务质量（QoS）管理。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-zo2j3me",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20221220172504-zo2j3me",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-yxh65wa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-yxh65wa",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后为 Pod 创建相应的目录，包括 Pod 的目录（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "/var/run/kubelet/pods/\u0026lt;podID\u0026gt;"
								},
								{
									"Type": "NodeText",
									"Data": "），该 Pod 的卷目录（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "\u0026lt;podDir\u0026gt;/volumes"
								},
								{
									"Type": "NodeText",
									"Data": "）和该 Pod 的插件目录（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "\u0026lt;podDir\u0026gt;/plugins"
								},
								{
									"Type": "NodeText",
									"Data": "）。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-x8rf93s",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ny4=",
						"Num": 7
					},
					"Properties": {
						"id": "20221220172504-x8rf93s",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-pux4wja",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-pux4wja",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "卷管理器"
								},
								{
									"Type": "NodeText",
									"Data": "会"
								}
							]
						},
						{
							"ID": "20221220172504-lrta8v8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-lrta8v8",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/2723e06a251a4ec3ef241397217e73fa782b0b98/pkg/kubelet/volumemanager/volume_manager.go#L330",
									"TextMarkTextContent": "挂载 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a code",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/2723e06a251a4ec3ef241397217e73fa782b0b98/pkg/kubelet/volumemanager/volume_manager.go#L330",
									"TextMarkTextContent": "Spec.Volumes"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/2723e06a251a4ec3ef241397217e73fa782b0b98/pkg/kubelet/volumemanager/volume_manager.go#L330",
									"TextMarkTextContent": " 中定义的相关数据卷，然后等待是否挂载成功"
								},
								{
									"Type": "NodeText",
									"Data": "。根据挂载卷类型的不同，某些 Pod 可能需要等待更长的时间（比如 NFS 卷）。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-9mhfpsd",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "OC4=",
						"Num": 8
					},
					"Properties": {
						"id": "20221220172504-9mhfpsd",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-15p5wxh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-15p5wxh",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/dd9981d038012c120525c9e6df98b3beb3ef19e1/pkg/kubelet/kubelet_pods.go#L788",
									"TextMarkTextContent": "从 apiserver 中检索"
								},
								{
									"Type": "NodeText",
									"Data": " "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Spec.ImagePullSecrets"
								},
								{
									"Type": "NodeText",
									"Data": " 中定义的所有 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Secret"
								},
								{
									"Type": "NodeText",
									"Data": "，然后将其注入到容器中。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-vh4mmoq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "OS4=",
						"Num": 9
					},
					"Properties": {
						"id": "20221220172504-vh4mmoq",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-m8dql5x",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-m8dql5x",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后通过容器运行时接口（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Container Runtime Interface（CRI）"
								},
								{
									"Type": "NodeText",
									"Data": "）开始启动容器（下面会详细描述）。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-qykxwa7",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-qykxwa7",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "CRI 与 pause 容器"
				}
			]
		},
		{
			"ID": "20221220172504-wrqhuca",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-wrqhuca",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到了这个阶段，大量的初始化工作都已经完成，容器已经准备好开始启动了，而容器是由 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "容器运行时"
				},
				{
					"Type": "NodeText",
					"Data": " （例如 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Docker"
				},
				{
					"Type": "NodeText",
					"Data": " 和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Rkt"
				},
				{
					"Type": "NodeText",
					"Data": "）启动的。"
				}
			]
		},
		{
			"ID": "20221220172504-tuwx7zt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-tuwx7zt",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了更容易扩展，Kubelet 从 1.5.0 开始通过"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "容器运行时接口"
				},
				{
					"Type": "NodeText",
					"Data": "与容器运行时（Container Runtime）交互。简而言之，CRI 提供了 Kubelet 和特定的运行时之间的抽象接口，它们之间通过"
				}
			]
		},
		{
			"ID": "20221220172504-nrt9gwj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-nrt9gwj",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/google/protobuf",
					"TextMarkTextContent": "协议缓冲区"
				},
				{
					"Type": "NodeText",
					"Data": "（它像一个更快的 JSON）和"
				}
			]
		},
		{
			"ID": "20221220172504-0fa4b7z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-0fa4b7z",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://grpc.io/",
					"TextMarkTextContent": "gRPC API"
				},
				{
					"Type": "NodeText",
					"Data": "（一种非常适合执行 Kubernetes 操作的 API）。这是一个非常酷的想法，通过使用 Kubelet 和运行时之间定义的契约关系，容器如何编排的具体实现细节已经变得无关紧要。由于不需要修改 Kubernetes 的核心代码，开发者可以以最小的开销添加新的运行时。"
				}
			]
		},
		{
			"ID": "20221220172504-mm9voqk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-mm9voqk",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不好意思有点跑题了，让我们继续回到容器启动的阶段。第一次启动 Pod 时，Kubelet 会通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Remote Procedure Command"
				},
				{
					"Type": "NodeText",
					"Data": "(RPC) 协议调用"
				}
			]
		},
		{
			"ID": "20221220172504-ux0se22",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-ux0se22",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/2d64ce5e8e45e26b02492d2b6c85e5ebfb1e4761/pkg/kubelet/kuberuntime/kuberuntime_sandbox.go#L51",
					"TextMarkTextContent": "RunPodSandbox"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "sandbox"
				},
				{
					"Type": "NodeText",
					"Data": " 用于描述一组容器，例如在 Kubernetes 中它表示的是 Pod。"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "sandbox"
				},
				{
					"Type": "NodeText",
					"Data": " 是一个很宽泛的概念，所以对于其他没有使用容器的运行时仍然是有意义的（比如在一个基于 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "hypervisor"
				},
				{
					"Type": "NodeText",
					"Data": " 的运行时中，sandbox 可能指的就是虚拟机）。"
				}
			]
		},
		{
			"ID": "20221220172504-d25oxmj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-d25oxmj",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们的例子中使用的容器运行时是 Docker，创建 sandbox 时首先创建的是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "pause"
				},
				{
					"Type": "NodeText",
					"Data": " 容器。pause 容器作为同一个 Pod 中所有其他容器的基础容器，它为 Pod 中的每个业务容器提供了大量的 Pod 级别资源，这些资源都是 Linux 命名空间（包括网络命名空间，IPC 命名空间和 PID 命名空间）。"
				}
			]
		},
		{
			"ID": "20221220172504-e0crmyy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-e0crmyy",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "pause 容器提供了一种方法来管理所有这些命名空间并允许业务容器共享它们，在同一个网络命名空间中的好处是：同一个 Pod 中的容器可以使用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "localhost"
				},
				{
					"Type": "NodeText",
					"Data": " 来相互通信。pause 容器的第二个功能与 PID 命名空间的工作方式相关，在 PID 命名空间中，进程之间形成一个树状结构，一旦某个子进程由于父进程的错误而变成了“孤儿进程”，其便会被 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "init"
				},
				{
					"Type": "NodeText",
					"Data": " 进程进行收养并最终回收资源。关于 pause 工作方式的详细信息可以参考："
				}
			]
		},
		{
			"ID": "20221220172504-e9nm43c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-e9nm43c",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.ianlewis.org/en/almighty-pause-container",
					"TextMarkTextContent": "The Almighty Pause Container"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221220172504-z8ia8aa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-z8ia8aa",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一旦创建好了 pause 容器，下面就会开始检查磁盘状态然后开始启动业务容器。"
				}
			]
		},
		{
			"ID": "20221220172504-lcpnqk5",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-lcpnqk5",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "CNI 和 Pod 网络"
				}
			]
		},
		{
			"ID": "20221220172504-1v87zjb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-1v87zjb",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在我们的 Pod 已经有了基本的骨架：一个共享所有命名空间以允许业务容器在同一个 Pod 里进行通信的 pause 容器。但现在还有一个问题，那就是容器的网络是如何建立的？"
				}
			]
		},
		{
			"ID": "20221220172504-paf6esm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-paf6esm",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当 Kubelet 为 Pod 创建网络时，它会将创建网络的任务交给 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "CNI"
				},
				{
					"Type": "NodeText",
					"Data": " 插件。CNI 表示容器网络接口（Container Network Interface），和容器运行时的运行方式类似，它也是一种抽象，允许不同的网络提供商为容器提供不同的网络实现。通过将 json 配置文件（默认在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "/etc/cni/net.d"
				},
				{
					"Type": "NodeText",
					"Data": " 路径下）中的数据传送到相关的 CNI 二进制文件（默认在 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "/opt/cni/bin"
				},
				{
					"Type": "NodeText",
					"Data": " 路径下）中，cni 插件可以给 pause 容器配置相关的网络，然后 Pod 中其他的容器都使用 pause 容器的网络。下面是一个简单的示例配置文件："
				}
			]
		},
		{
			"ID": "20221220172504-oqa03dz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221220172504-oqa03dz",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "anNvbg=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "{\n    \"cniVersion\": \"0.3.1\",\n    \"name\": \"bridge\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cnio0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"ranges\": [\n          [{\"subnet\": \"${POD_CIDR}\"}]\n        ],\n        \"routes\": [{\"dst\": \"0.0.0.0/0\"}]\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221220172504-j6ciaa4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-j6ciaa4",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "CNI 插件还会通过 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "CNI_ARGS"
				},
				{
					"Type": "NodeText",
					"Data": " 环境变量为 Pod 指定其他的元数据，包括 Pod 名称和命名空间。"
				}
			]
		},
		{
			"ID": "20221220172504-okezcnz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-okezcnz",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的步骤因 CNI 插件而异，我们以 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "bridge"
				},
				{
					"Type": "NodeText",
					"Data": " 插件举例："
				}
			]
		},
		{
			"ID": "20221220172504-q7vfr7f",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-q7vfr7f",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-3o2zuni",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-3o2zuni",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-85ksqyp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-85ksqyp",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "该插件首先会在根网络命名空间（也就是宿主机的网络命名空间）中设置本地 Linux 网桥，以便为该主机上的所有容器提供网络服务。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-f19vq2m",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-f19vq2m",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-x29ibu8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-x29ibu8",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后它会将一个网络接口（"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "veth"
								},
								{
									"Type": "NodeText",
									"Data": " 设备对的一端）插入到 pause 容器的网络命名空间中，并将另一端连接到网桥上。你可以这样来理解 veth 设备对：它就像一根很长的管道，一端连接到容器，一端连接到根网络命名空间中，数据包就在管道中进行传播。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-38wwt5h",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-38wwt5h",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-fhqipi0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-fhqipi0",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接下来 json 文件中指定的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "IPAM"
								},
								{
									"Type": "NodeText",
									"Data": " Plugin 会为 pause 容器的网络接口分配一个 IP 并设置相应的路由，现在 Pod 就有了自己的 IP。"
								}
							]
						},
						{
							"ID": "20221220172504-m5236sy",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20221220172504-m5236sy",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"ID": "20221220172504-r4pfnnc",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221220172504-r4pfnnc",
										"updated": "20221220172504"
									},
									"Children": [
										{
											"ID": "20221220172504-qzf8nfb",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221220172504-qzf8nfb",
												"updated": "20221220172504"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "IPAM Plugin 的工作方式和 CNI Plugin 类似：通过二进制文件调用并具有标准化的接口，每一个 IPAM Plugin 都必须要确定容器网络接口的 IP、子网以及网关和路由，并将信息返回给 CNI 插件。最常见的 IPAM Plugin 是 "
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "code",
													"TextMarkTextContent": "host-local"
												},
												{
													"Type": "NodeText",
													"Data": "，它从预定义的一组地址池中为容器分配 IP 地址。它将地址池的信息以及分配信息保存在主机的文件系统中，从而确保了同一主机上每个容器的 IP 地址的唯一性。"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-c90pucm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-c90pucm",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-lnjyl1d",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-lnjyl1d",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后 Kubelet 会将集群内部的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "DNS"
								},
								{
									"Type": "NodeText",
									"Data": " 服务器的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Cluster IP"
								},
								{
									"Type": "NodeText",
									"Data": " 地址传给 CNI 插件，然后 CNI 插件将它们写到容器的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "/etc/resolv.conf"
								},
								{
									"Type": "NodeText",
									"Data": " 文件中。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-f12tla2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-f12tla2",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一旦完成了上面的步骤，CNI 插件就会将操作的结果以 json 的格式返回给 Kubelet。"
				}
			]
		},
		{
			"ID": "20221220172504-26j039o",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-26j039o",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "跨主机容器网络"
				}
			]
		},
		{
			"ID": "20221220172504-2oih4kp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-2oih4kp",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到目前为止，我们已经描述了容器如何与宿主机进行通信，但跨主机之间的容器如何通信呢？"
				}
			]
		},
		{
			"ID": "20221220172504-q2zc3td",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-q2zc3td",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通常情况下使用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "overlay"
				},
				{
					"Type": "NodeText",
					"Data": " 网络来进行跨主机容器通信，这是一种动态同步多个主机间路由的方法。 其中最常用的 overlay 网络插件是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "flannel"
				},
				{
					"Type": "NodeText",
					"Data": "，flannel 具体的工作方式可以参考"
				}
			]
		},
		{
			"ID": "20221220172504-odiiqci",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-odiiqci",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/coreos/flannel",
					"TextMarkTextContent": "CoreOS 的文档"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221220172504-kj18vl0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221220172504-kj18vl0",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "容器启动"
				}
			]
		},
		{
			"ID": "20221220172504-mb22z8p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-mb22z8p",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所有网络都配置完成后，接下来就开始真正启动业务容器了！"
				}
			]
		},
		{
			"ID": "20221220172504-61ioa86",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-61ioa86",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一旦 sanbox 完成初始化并处于 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "active"
				},
				{
					"Type": "NodeText",
					"Data": " 状态，Kubelet 就可以开始为其创建容器了。首先"
				}
			]
		},
		{
			"ID": "20221220172504-t2vsjhn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-t2vsjhn",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/5adfb24f8f25a0d57eb9a7b158db46f9f46f0d80/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L690",
					"TextMarkTextContent": "启动 PodSpec 中定义的 init 容器"
				},
				{
					"Type": "NodeText",
					"Data": "，然后再启动业务容器。具体过程如下："
				}
			]
		},
		{
			"ID": "20221220172504-zys2ps8",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221220172504-zys2ps8",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"ID": "20221220172504-7fgnrhw",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221220172504-7fgnrhw",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-i6pdnao",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-i6pdnao",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "首先拉取容器的镜像。如果是私有仓库的镜像，就会利用 PodSpec 中指定的 Secret 来拉取该镜像。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-0nxpzdh",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221220172504-0nxpzdh",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-g1iciy6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-g1iciy6",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后通过 CRI 接口创建容器。Kubelet 向 PodSpec 中填充了一个 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "ContainerConfig"
								},
								{
									"Type": "NodeText",
									"Data": " 数据结构（在其中定义了命令，镜像，标签，挂载卷，设备，环境变量等待），然后通过 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "protobufs"
								},
								{
									"Type": "NodeText",
									"Data": " 发送给 CRI 接口。对于 Docker 来说，它会将这些信息反序列化并填充到自己的配置信息中，然后再发送给 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Dockerd"
								},
								{
									"Type": "NodeText",
									"Data": " 守护进程。在这个过程中，它会将一些元数据标签（例如容器类型，日志路径，dandbox ID 等待）添加到容器中。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-xvpfgnn",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20221220172504-xvpfgnn",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-kqukjn4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-kqukjn4",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接下来会使用 CPU 管理器来约束容器，这是 Kubelet 1.8 中新添加的 alpha 特性，它使用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "UpdateContainerResources"
								},
								{
									"Type": "NodeText",
									"Data": " CRI 方法将容器分配给本节点上的 CPU 资源池。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-t3nbr1d",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20221220172504-t3nbr1d",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-of2uw6h",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-of2uw6h",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后容器开始真正"
								}
							]
						},
						{
							"ID": "20221220172504-msou7kq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-msou7kq",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/kubernetes/kubernetes/blob/5f9f4a1c5939436fa320e9bc5973a55d6446e59f/pkg/kubelet/kuberuntime/kuberuntime_container.go#L135",
									"TextMarkTextContent": "启动"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221220172504-vq4uwrl",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20221220172504-vq4uwrl",
						"updated": "20221220172504"
					},
					"Children": [
						{
							"ID": "20221220172504-i8uehqz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-i8uehqz",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果 Pod 中配置了容器生命周期钩子（Hook），容器启动之后就会运行这些 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Hook"
								},
								{
									"Type": "NodeText",
									"Data": "。Hook 的类型包括两种："
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Exec"
								},
								{
									"Type": "NodeText",
									"Data": "（执行一段命令） 和 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "HTTP"
								},
								{
									"Type": "NodeText",
									"Data": "（发送HTTP请求）。如果 PostStart Hook 启动的时间过长、挂起或者失败，容器将永远不会变成 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "running"
								},
								{
									"Type": "NodeText",
									"Data": " 状态。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221220172504-7bic5ej",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-7bic5ej",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "7. 总结"
				}
			]
		},
		{
			"ID": "20221220172504-oiitv6x",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20221220172504-oiitv6x",
				"updated": "20221220172504"
			}
		},
		{
			"ID": "20221220172504-5xez967",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-5xez967",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果上面一切顺利，现在你的集群上应该会运行三个容器，所有的网络，数据卷和秘钥都被通过 CRI 接口添加到容器中并配置成功。"
				}
			]
		},
		{
			"ID": "20221220172504-tvi19i2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-tvi19i2",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上文所述的创建 Pod 整个过程的流程图如下所示："
				}
			]
		},
		{
			"ID": "20221220172504-quni1je",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-quni1je",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://hugo-picture.oss-cn-beijing.aliyuncs.com/what-happens-when-k8s.svg"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20221220172504-s1ry28i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172504-s1ry28i",
				"updated": "20221220172504"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Kubelet 创建 Pod 的流程"
				}
			]
		},
		{
			"ID": "20221220172504-sa6jlsz",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221220172504-sa6jlsz",
				"updated": "20221220172714"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "s",
					"TextMarkTextContent": "8"
				},
				{
					"Type": "NodeText",
					"Data": ". 原文链接"
				}
			]
		},
		{
			"ID": "20221220172504-4x76b49",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221220172504-4x76b49",
				"updated": "20221220172712"
			},
			"Children": [
				{
					"ID": "20221220172504-lm2tgja",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221220172504-lm2tgja",
						"updated": "20221220172712"
					},
					"Children": [
						{
							"ID": "20221220172504-o4jtrzl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-o4jtrzl",
								"updated": "20221220172504"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://github.com/jamiehannaford/what-happens-when-k8s",
									"TextMarkTextContent": "What happens when … Kubernetes edition!"
								}
							]
						},
						{
							"ID": "20221220172504-isaxhof",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221220172504-isaxhof",
								"updated": "20221220172712"
							}
						}
					]
				}
			]
		},
		{
			"ID": "20221220172708-scwfdmd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221220172708-scwfdmd"
			}
		}
	]
}